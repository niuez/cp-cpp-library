<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>cp-cpp-library Document</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/index.html"><strong aria-hidden="true">1.1.</strong> Data Structures</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/segment_tree/index.html"><strong aria-hidden="true">1.1.1.</strong> Segment Trees</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/segment_tree/segment_tree.html"><strong aria-hidden="true">1.1.1.1.</strong> Segment Tree</a></li><li class="expanded "><a href="data_structures/segment_tree/lazy_segment_tree.html"><strong aria-hidden="true">1.1.1.2.</strong> Lazy Segment Tree</a></li><li class="expanded "><a href="data_structures/segment_tree/persistent_segment_tree.html"><strong aria-hidden="true">1.1.1.3.</strong> Persistent Segment Tree</a></li><li class="expanded "><a href="data_structures/segment_tree/dynamic_segment_tree.html"><strong aria-hidden="true">1.1.1.4.</strong> Dynamic Segment Tree</a></li><li class="expanded "><a href="data_structures/segment_tree/li_chao.html"><strong aria-hidden="true">1.1.1.5.</strong> Li-Chao Segment Tree</a></li></ol></li><li class="expanded "><a href="data_structures/heap/index.html"><strong aria-hidden="true">1.1.2.</strong> Heaps</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/heap/pairing_heap.html"><strong aria-hidden="true">1.1.2.1.</strong> Pairing Heap</a></li></ol></li><li class="expanded "><a href="data_structures/trees/index.html"><strong aria-hidden="true">1.1.3.</strong> Trees</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/trees/euler_tour_subtree.html"><strong aria-hidden="true">1.1.3.1.</strong> EulerTour Subtree</a></li><li class="expanded "><a href="data_structures/trees/euler_tour_path.html"><strong aria-hidden="true">1.1.3.2.</strong> EulerTour Path</a></li><li class="expanded "><a href="data_structures/trees/heavy_light_decomposition.html"><strong aria-hidden="true">1.1.3.3.</strong> Heavy Light Decomposition</a></li><li class="expanded "><a href="data_structures/trees/link_cut_tree.html"><strong aria-hidden="true">1.1.3.4.</strong> Link Cut Tree</a></li><li class="expanded "><a href="data_structures/trees/toptree.html"><strong aria-hidden="true">1.1.3.5.</strong> Top Tree</a></li></ol></li><li class="expanded "><a href="data_structures/union_find/index.html"><strong aria-hidden="true">1.1.4.</strong> Union Find</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/union_find/union_find.html"><strong aria-hidden="true">1.1.4.1.</strong> Union Find</a></li><li class="expanded "><a href="data_structures/union_find/persistent_union_find.html"><strong aria-hidden="true">1.1.4.2.</strong> Persistent Union Find</a></li></ol></li><li class="expanded "><a href="data_structures/bbst/index.html"><strong aria-hidden="true">1.1.5.</strong> self-Balancing Binary Search Trees</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/bbst/splay_tree_array.html"><strong aria-hidden="true">1.1.5.1.</strong> Splay Tree Array</a></li><li class="expanded "><a href="data_structures/bbst/splay_tree_map.html"><strong aria-hidden="true">1.1.5.2.</strong> Splay Tree Map</a></li><li class="expanded "><a href="data_structures/bbst/avl_tree_array.html"><strong aria-hidden="true">1.1.5.3.</strong> AVL Tree Array</a></li><li class="expanded "><a href="data_structures/bbst/avl_tree_map.html"><strong aria-hidden="true">1.1.5.4.</strong> AVL Tree Map</a></li><li class="expanded "><a href="data_structures/bbst/avl_tree_map_foldable.html"><strong aria-hidden="true">1.1.5.5.</strong> AVL Tree Map Foldable</a></li><li class="expanded "><a href="data_structures/bbst/persistent_avl_tree_array.html"><strong aria-hidden="true">1.1.5.6.</strong> Persistent AVL Tree Array</a></li></ol></li><li class="expanded "><a href="data_structures/sparse_table/sparse_table.html"><strong aria-hidden="true">1.1.6.</strong> Sparse Table</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/sparse_table/sparse_table.html"><strong aria-hidden="true">1.1.6.1.</strong> Sparse Table</a></li></ol></li><li class="expanded "><a href="data_structures/wavelet_matrix/index.html"><strong aria-hidden="true">1.1.7.</strong> Wavelet Matrix</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/wavelet_matrix/wavelet_matrix.html"><strong aria-hidden="true">1.1.7.1.</strong> Wavelet Matrix</a></li><li class="expanded "><a href="data_structures/wavelet_matrix/dynamic_wavelet_matrix.html"><strong aria-hidden="true">1.1.7.2.</strong> Dynamic Wavelet Matrix</a></li></ol></li><li class="expanded "><a href="data_structures/other/index.html"><strong aria-hidden="true">1.1.8.</strong> Other</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/other/swag.html"><strong aria-hidden="true">1.1.8.1.</strong> SWAG</a></li><li class="expanded "><a href="data_structures/other/fenwick_tree.html"><strong aria-hidden="true">1.1.8.2.</strong> Fenwick Tree</a></li></ol></li></ol></li><li class="expanded "><a href="math/index.html"><strong aria-hidden="true">1.2.</strong> Math</a></li><li><ol class="section"><li class="expanded "><a href="math/modint.html"><strong aria-hidden="true">1.2.1.</strong> modint</a></li><li class="expanded "><a href="math/matrix.html"><strong aria-hidden="true">1.2.2.</strong> Matrix</a></li><li class="expanded "><a href="math/garner.html"><strong aria-hidden="true">1.2.3.</strong> Garner's Algorithm</a></li><li class="expanded "><a href="math/formal_power_series.html"><strong aria-hidden="true">1.2.4.</strong> Formal Power Series</a></li><li class="expanded "><a href="math/runtime_fp.html"><strong aria-hidden="true">1.2.5.</strong> Runtime fp</a></li><li class="expanded "><a href="math/convolution/index.html"><strong aria-hidden="true">1.2.6.</strong> Convolution</a></li><li><ol class="section"><li class="expanded "><a href="math/convolution/multiple_transform.html"><strong aria-hidden="true">1.2.6.1.</strong> Multiple Transform</a></li><li class="expanded "><a href="math/convolution/divisor_transform.html"><strong aria-hidden="true">1.2.6.2.</strong> Divisor Transform</a></li><li class="expanded "><a href="math/convolution/fast_fourier_transform.html"><strong aria-hidden="true">1.2.6.3.</strong> Fast Fourier Transform</a></li><li class="expanded "><a href="math/convolution/numeric_theoretic_transform.html"><strong aria-hidden="true">1.2.6.4.</strong> Number Theoretic Transform</a></li></ol></li></ol></li><li class="expanded "><a href="string/index.html"><strong aria-hidden="true">1.3.</strong> String</a></li><li><ol class="section"><li class="expanded "><a href="string/manacher.html"><strong aria-hidden="true">1.3.1.</strong> Manacher</a></li><li class="expanded "><a href="string/mp.html"><strong aria-hidden="true">1.3.2.</strong> MP (Morris Pratt)</a></li><li class="expanded "><a href="string/rolling_hash.html"><strong aria-hidden="true">1.3.3.</strong> Rolling Hash</a></li><li class="expanded "><a href="string/suffix_array.html"><strong aria-hidden="true">1.3.4.</strong> Suffix Array</a></li><li class="expanded "><a href="string/Z-algorithm.html"><strong aria-hidden="true">1.3.5.</strong> Z-algorithm</a></li><li class="expanded "><a href="string/burrows_wheeler.html"><strong aria-hidden="true">1.3.6.</strong> Burrows Wheeler</a></li></ol></li><li class="expanded "><a href="graph/index.html"><strong aria-hidden="true">1.4.</strong> Graph</a></li><li><ol class="section"><li class="expanded "><a href="graph/max_flow/dinic.html"><strong aria-hidden="true">1.4.1.</strong> Max Flow</a></li><li><ol class="section"><li class="expanded "><a href="graph/max_flow/dinic.html"><strong aria-hidden="true">1.4.1.1.</strong> Dinic</a></li></ol></li><li class="expanded "><a href="graph/mcf/primal_dual.html"><strong aria-hidden="true">1.4.2.</strong> Minimum Cost Flow</a></li><li><ol class="section"><li class="expanded "><a href="graph/mcf/primal_dual.html"><strong aria-hidden="true">1.4.2.1.</strong> Successive Shortest Path</a></li></ol></li><li class="expanded "><a href="graph/low_link.html"><strong aria-hidden="true">1.4.3.</strong> Low Link</a></li><li class="expanded "><a href="graph/strongly_connected_components.html"><strong aria-hidden="true">1.4.4.</strong> Strongly Connected Components</a></li><li class="expanded "><a href="graph/two_edge_connected.html"><strong aria-hidden="true">1.4.5.</strong> Two Edge Connected</a></li><li class="expanded "><a href="graph/two_vertex_connected.html"><strong aria-hidden="true">1.4.6.</strong> Two Vertex Connected</a></li></ol></li><li class="expanded "><a href="geometry/geometry.html"><strong aria-hidden="true">1.5.</strong> Geometry</a></li><li class="expanded "><a href="tech/index.html"><strong aria-hidden="true">1.6.</strong> Tech</a></li><li><ol class="section"><li class="expanded "><a href="tech/compression.html"><strong aria-hidden="true">1.6.1.</strong> Compression</a></li><li class="expanded "><a href="tech/grundy.html"><strong aria-hidden="true">1.6.2.</strong> Grundy Number</a></li><li class="expanded "><a href="tech/mongeDP.html"><strong aria-hidden="true">1.6.3.</strong> Monge DP</a></li><li class="expanded "><a href="tech/mo.html"><strong aria-hidden="true">1.6.4.</strong> Mo's Algorithm</a></li><li class="expanded "><a href="tech/slide_min.html"><strong aria-hidden="true">1.6.5.</strong> Slide Min</a></li><li class="expanded "><a href="tech/fastio.html"><strong aria-hidden="true">1.6.6.</strong> FastIO</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">cp-cpp-library Document</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>ここに競技プログラミング用のC++のライブラリをおいていきたい</p>
<h1><a class="header" href="#data-structures" id="data-structures">Data Structures</a></h1>
<p>いろいろ, あるよね</p>
<h1><a class="header" href="#segment-trees" id="segment-trees">Segment Trees</a></h1>
<ul>
<li>
<p><a href="data_structures/segment_tree/./segment_tree.html">Segment Tree</a></p>
</li>
<li>
<p><a href="data_structures/segment_tree/./lazy_segment_tree.html">Lazy Segment Tree</a></p>
</li>
<li>
<p><a href="data_structures/segment_tree/./persistent_segment_tree.html">Persistent Segment Tree</a></p>
</li>
<li>
<p><a href="data_structures/segment_tree/./dynamic_segment_tree.html">Dynamic Segment Tree</a></p>
</li>
<li>
<p><a href="data_structures/segment_tree/./li_chao.html">Li-Chao Segment Tree</a></p>
</li>
</ul>
<h1><a class="header" href="#segment-tree" id="segment-tree">Segment Tree</a></h1>
<h3><a class="header" href="#spec" id="spec">Spec</a></h3>
<ul>
<li>
<p><code>using T = ...</code></p>
<ul>
<li>Segment Treeに載せる型</li>
</ul>
</li>
<li>
<p><code>T ope(const T&amp; a, const T&amp; b)</code></p>
<ul>
<li>Tの演算を指定する</li>
</ul>
</li>
<li>
<p><code>T ide()</code></p>
<ul>
<li>Tの単位元を返す</li>
</ul>
</li>
<li>
<p><code>segment_tree(vector&lt;T&gt; init)</code></p>
<ul>
<li><code>init</code>からSegment Treeを構築する</li>
<li>\( O(n) \)</li>
</ul>
</li>
<li>
<p><code>update(i64 i, T x)</code></p>
<ul>
<li><code>i</code>番目の要素を<code>x</code>にする</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
<li>
<p><code>sum(i64 l, i64 r)</code></p>
<ul>
<li><code>[l, r)</code>の総和を求める</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code" id="code">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
using i64 = long long;

template&lt;class T, class Ope, const T&amp; Ide&gt;
struct segment_tree {
  Ope ope;
 
  i64 n;
  std::vector&lt;T&gt; node;
 
  segment_tree(const std::vector&lt;T&gt;&amp; init) {
    n = 1;
    while(n &lt; init.size()) n *= 2;
    node.resize(2 * n, Ide);
    for(int i = 0;i &lt; init.size();i++) node[i + n] = init[i];
    for(int i = n - 1; i &gt;= 1;i--) node[i] = ope(node[i * 2], node[i * 2 + 1]);
  }
 
  void modify(i64 i, T x) {
    i += n;
    node[i] = ope(node[i], x);
    while(i &gt; 1) {
      i = i / 2;
      node[i] = ope(node[i * 2], node[i * 2 + 1]);
    }
  }

  /* [l, r) */
  T sum(i64 l, i64 r) const {
    T lx = Ide;
    T rx = Ide;
    l += n;
    r += n;
    while(l &lt; r) {
      if(l &amp; 1) { lx = ope(lx, node[l++]); }
      if(r &amp; 1) { rx = ope(node[--r], rx); }
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
    }
    return ope(lx, rx);
  }
};
</code></pre>
<h1><a class="header" href="#lazy-segment-tree" id="lazy-segment-tree">Lazy Segment Tree</a></h1>
<h3><a class="header" href="#spec-1" id="spec-1">Spec</a></h3>
<ul>
<li>
<p><code>using T = ...</code></p>
<ul>
<li>Segment Treeに載せる型</li>
</ul>
</li>
<li>
<p><code>using L = ...</code></p>
<ul>
<li>遅延伝搬させる作用素</li>
</ul>
</li>
<li>
<p><code>T t_ide()</code></p>
<ul>
<li>Tの単位元を返す</li>
</ul>
</li>
<li>
<p><code>L l_ide()</code></p>
<ul>
<li>Lの単位元を返す</li>
</ul>
</li>
<li>
<p><code>T ope(const T&amp; a, const T&amp; b)</code></p>
<ul>
<li>Tの演算を指定する</li>
</ul>
</li>
<li>
<p><code>L lazy_ope(const L&amp; a, const L&amp; b)</code></p>
<ul>
<li>Tの演算を指定する</li>
</ul>
</li>
<li>
<p><code>T effect(const T&amp; t, const L&amp; l, const i64 len)</code></p>
<ul>
<li>長さ<code>len</code>の区間の総和<code>t</code>に作用<code>l</code>をする</li>
</ul>
</li>
<li>
<p><code>lazy_segment_tree(const vector&lt;T&gt;&amp; init)</code></p>
<ul>
<li><code>init</code>からLazy Segment Treeを構築する</li>
<li>\( O(n) \)</li>
</ul>
</li>
<li>
<p><code>update(i64 a, i64 b, L lx)</code></p>
<ul>
<li><code>[a, b)</code>番目の要素に作用<code>lx</code>をする</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
<li>
<p><code>sum(i64 a, i64 b)</code></p>
<ul>
<li><code>[a, b)</code>の総和を求める</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-1" id="code-1">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;iostream&gt;
using i64 = long long;

struct lazy_segment_tree {
  using T = i64;
  using L = i64;
  static inline T t_ide() { return (1LL &lt;&lt; 31) - 1; }
  static inline L l_ide() { return (1LL &lt;&lt; 31) - 1; }
  static inline T ope(const T&amp; a, const T&amp; b) { return std::min(a, b); }
  static inline L lazy_ope(const L&amp; a, const L&amp; b) { return b; }
  static inline T effect(const T&amp; t, const L&amp; l) { return l; }

  int n, h;
  std::vector&lt;T&gt; node;
  std::vector&lt;L&gt; lazy;
  std::vector&lt;bool&gt; flag;

  lazy_segment_tree(int N) {
    n = 1;
    h = 1;
    while(n &lt; N) n &lt;&lt;= 1, h++;
    node.resize(n &lt;&lt; 1, t_ide());
    lazy.resize(n &lt;&lt; 1, l_ide());
    flag.resize(n &lt;&lt; 1, false);
  }
  lazy_segment_tree(const std::vector&lt;T&gt;&amp; init) {
    n = 1;
    h = 1;
    while(n &lt; init.size()) n &lt;&lt;= 1, h++;
    node.resize(n &lt;&lt; 1, t_ide());
    lazy.resize(n &lt;&lt; 1, l_ide());
    flag.resize(n &lt;&lt; 1, false);
    for(int i = 0;i &lt; init.size();i++) node[i + n] = init[i];
    for(int i = n; i --&gt; 1;) node[i] = ope(node[(i &lt;&lt; 1)], node[(i &lt;&lt; 1) + 1]);
  }

  inline void eff(int k, L x) {
    if(k &lt; n &lt;&lt; 1) {
      lazy[k] = lazy_ope(lazy[k], x);
      flag[k] = true;
    }
  }
  inline T eval(int k) const { return flag[k] ? effect(node[k], lazy[k]) : node[k]; }

  inline void push(int k) {
    if(flag[k]) {
      node[k] = eval(k);
      eff(k &lt;&lt; 1, lazy[k]);
      eff((k &lt;&lt; 1) | 1, lazy[k]);
      lazy[k] = l_ide();
      flag[k] = false;
    }
  }

  inline void infuse(int k) {
    k = k &gt;&gt; __builtin_ctz(k);
    while((k &gt;&gt;= 1)) node[k] = ope(eval(k &lt;&lt; 1), eval((k &lt;&lt; 1) + 1));
  }

  inline void infiltrate(int k) {
    if(k == n &lt;&lt; 1) return;
    int kc = __builtin_ctz(k);
    for(int i = h; i --&gt; kc;) push(k &gt;&gt; i);
  }

  inline void infiltrate(int l, int r) {
    if(r == n &lt;&lt; 1) infiltrate(l);
    else {
      int hh = h;
      int x = l ^ r;
      for(; !(x &gt;&gt; --hh);) push(l &gt;&gt; hh);
      int lc = __builtin_ctz(l);
      for(int i = hh + 1; i --&gt; lc;) push(l &gt;&gt; i);
      int rc = __builtin_ctz(r);
      for(int i = hh + 1; i --&gt; rc;) push(r &gt;&gt; i);
    }
  }

  void update(int a, int b, L x) {
    int l = a + n;
    int r = b + n;
    infiltrate(l, r);
    while(l &lt; r) {
      if(l &amp; 1) eff(l++, x);
      if(r &amp; 1) eff(--r, x);
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
    }
    infuse(a + n);
    infuse(b + n);
  }

  T sum(int l, int r) {
    l += n;
    r += n;
    infiltrate(l, r);
    T lx = t_ide();
    T rx = t_ide();
    while(l &lt; r) {
      if(l &amp; 1) lx = ope(lx, eval(l++));
      if(r &amp; 1) rx = ope(eval(--r), rx);
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
    }
    return ope(lx, rx);
  }
};
</code></pre>
<h1><a class="header" href="#persistent-segment-tree" id="persistent-segment-tree">Persistent Segment Tree</a></h1>
<h3><a class="header" href="#spec-2" id="spec-2">Spec</a></h3>
<ul>
<li>
<p><code>using T = ...</code></p>
<ul>
<li>Segment Treeに載せる型</li>
</ul>
</li>
<li>
<p><code>T ope(const T&amp; a, const T&amp; b)</code></p>
<ul>
<li>Tの演算を指定する</li>
</ul>
</li>
<li>
<p><code>T ide()</code></p>
<ul>
<li>Tの単位元を返す</li>
</ul>
</li>
<li>
<p><code>persistent_segment_tree(vector&lt;T&gt; init)</code></p>
<ul>
<li><code>init</code>からPersistent Segment Treeを構築する</li>
<li>\( O(n) \)</li>
</ul>
</li>
<li>
<p><code>update(i64 i, T x)</code></p>
<ul>
<li><code>i</code>番目の要素を<code>x</code>にしたSegment Treeを返す.</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
<li>
<p><code>sum(i64 l, i64 r)</code></p>
<ul>
<li><code>[l, r)</code>の総和を求める</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-2" id="code-2">Code</a></h3>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
using namespace std;
using i64 = long long;

struct persistent_segment_tree {
  using T = pair&lt;i64, i64&gt;;
  struct node {
    using Ptr = node*;
    T data;
    Ptr left;
    Ptr right;
    
    node(T data): data(data), left(), right() {}
    node(T data, Ptr left, Ptr right)
      : data(data), left(left), right(right) {}
  };

  using Ptr = node*;

  static T ope(const T&amp; a, const T&amp; b) { return std::min(a, b); }
  static T ide() { return {(i64)(1e18), (i64)(1e18)}; }

  Ptr root;
  i64 N;

  static Ptr build(i64 l, i64 r, const vector&lt;T&gt;&amp; init) {
    if(l + 1 &gt;= r) return new node(init[l]);
    else {
      Ptr le = build(l , (l + r) / 2, init);
      Ptr ri = build((l + r) / 2, r, init);
      T da = ope(le-&gt;data, ri-&gt;data);
      return new node(da, le, ri);
    }
  }

  static Ptr update(Ptr node, i64 i, T val, i64 l, i64 r) {
    if(i == l &amp;&amp; i + 1 == r) return new struct node(val);
    Ptr left = nullptr;
    Ptr right = nullptr;
    if(l &lt;= i &amp;&amp; i &lt; ((l + r) &gt;&gt; 1)) {
      left = update(node-&gt;left, i, val, l, (l + r) &gt;&gt; 1);
      right = node-&gt;right;
    }
    else {
      left = node-&gt;left;
      right = update(node-&gt;right, i, val, (l + r) &gt;&gt; 1, r);
    }
    return new struct node(ope(left-&gt;data, right-&gt;data), left, right);
  }

  static T sum(Ptr node, i64 a, i64 b, i64 l, i64 r) {
    if(b &lt;= l || r &lt;= a) return ide();
    else if(a &lt;= l &amp;&amp; r &lt;= b) return node-&gt;data;
    else return ope(
        sum(node-&gt;left, a, b, l, (l + r) &gt;&gt; 1),
        sum(node-&gt;right, a, b, (l + r) &gt;&gt; 1, r)
        );
  }

  persistent_segment_tree(const vector&lt;T&gt;&amp; init)
    : root(build(0, init.size(), init)), N(init.size()) {}
  persistent_segment_tree(Ptr root, i64 N): root(root), N(N) {}
  persistent_segment_tree update(i64 i, T x) const {
    return persistent_segment_tree(update(root, i, x, 0, N), N);
  }
  T sum(i64 l, i64 r) { return sum(root, l, r, 0, N); }
};
</code></pre>
<h1><a class="header" href="#dynamic-segment-tree" id="dynamic-segment-tree">Dynamic Segment Tree</a></h1>
<h3><a class="header" href="#spec-3" id="spec-3">Spec</a></h3>
<ul>
<li>
<p><code>using T = ...</code></p>
<ul>
<li>Dynamic Segment Treeに載せる型</li>
</ul>
</li>
<li>
<p><code>T ope(const T&amp; a, const T&amp; b)</code></p>
<ul>
<li>Tの演算を指定する</li>
</ul>
</li>
<li>
<p><code>T ide()</code></p>
<ul>
<li>Tの単位元を返す</li>
</ul>
</li>
<li>
<p><code>dynamic_segment_tree(const i64 n)</code></p>
<ul>
<li><code>[ide; n]</code>の列を扱うDynamic Segment Treeを構築する</li>
<li>\( O(1) \)</li>
</ul>
</li>
<li>
<p><code>update(i64 i, T x)</code></p>
<ul>
<li><code>i</code>番目の要素を<code>x</code>にする</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
<li>
<p><code>sum(i64 l, i64 r)</code></p>
<ul>
<li><code>[l, r)</code>の総和を求める</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-3" id="code-3">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct dynamic_segment_tree {
  using T = i64;
  static T ide() { return 0ll; }
  static T ope(const T&amp; a, const T&amp; b) { return a + b; }

  struct node {
    node* left;
    node* right;
    T val;
    node(T v): val(v), left(nullptr), right(nullptr) {}
  };

  i64 n;
  node* root;
  dynamic_segment_tree(const i64 sz): root(new node(ide())) {
    n = 1;
    while(n &lt; sz) n *= 2;
  }
  T value(node* n) {
    if(n) return n-&gt;val;
    else return ide();
  }
  void update(node* n, i64 i, T x, i64 l, i64 r) {
    if(l + 1 == r) {
      n-&gt;val = x;
    }
    else {
      i64 m = (l + r) / 2;
      if(i &lt; m) {
        if(!n-&gt;left) {
          n-&gt;left = new node(ide());
        }
        update(n-&gt;left, i, x, l, m);
      }
      else {
        if(!n-&gt;right) {
          n-&gt;right = new node(ide());
        }
        update(n-&gt;right, i, x, m, r);
      }
      n-&gt;val = ope(value(n-&gt;left), value(n-&gt;right));
    }
  }

  T get(node* n, i64 a, i64 b, i64 l, i64 r) {
    if(!n) return ide();
    if(a &lt;= l &amp;&amp; r &lt;= b) return value(n);
    else if(r &lt;= a || b &lt;= l) return ide();
    else return ope(get(n-&gt;left, a, b, l, (l + r) / 2), get(n-&gt;right, a, b, (l + r) / 2, r));
  }

  void update(i64 i, T x) {
    update(root, i, x, 0, n);
  }

  T sum(i64 a, i64 b) {
    return get(root, a, b, 0, n);
  }
};
</code></pre>
<h1><a class="header" href="#li-chao-segment-tree" id="li-chao-segment-tree">Li-Chao Segment Tree</a></h1>
<h3><a class="header" href="#spec-4" id="spec-4">Spec</a></h3>
<ul>
<li>
<p>template argments</p>
<ul>
<li><code>class T</code>
<ul>
<li>Li-Chao Segment Treeで扱う型</li>
<li><code>+, *, /</code>, 比較ができる必要がある</li>
</ul>
</li>
<li><code>const T ide</code>
<ul>
<li>Tの単位元(?)</li>
<li>例えば, 最大値を返すLiChaoなら小さい数を入れておく</li>
</ul>
</li>
<li><code>class Compare = greater&lt;T&gt;</code>
<ul>
<li>最大値or最小値</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>li_chao(T mi, T, ma)</code></p>
<ul>
<li><code>[mi, ma]</code>の間の範囲を管理するLiChaoを構築する.</li>
</ul>
</li>
<li>
<p><code>void add_line(T a, T b)</code></p>
<ul>
<li><code>a * x + b</code>の直線を追加する</li>
<li>\( O(\log L) \)</li>
</ul>
</li>
<li>
<p><code>T get(T x)</code></p>
<ul>
<li><code>max{a_i * x + b_i}</code>を返す(Compareで<code>min</code>に変えられる)</li>
<li>\( O(\log L) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-4" id="code-4">Code</a></h3>
<pre><code class="language-cpp">#include &lt;functional&gt;
using namespace std;
template&lt;class T,const T ide,class Compare = greater&lt;T&gt;&gt;
struct li_chao{
  struct Line{
    T a,b;
    Line(T a = 0,T b = 0) : a(a) , b(b) {}
    T get(T x){return a * x + b;}
  };
 
  struct Node{
    Line line;
    Node *lhs,*rhs;
    Node(Line l) : line(l) , lhs(nullptr) , rhs(nullptr){}
  };
 
  const T MI,MA;
 
  Node * root;
 
  Compare comp;
 
  T comp_get(const T &amp; x,const T &amp; y){
    if(comp(x , y)) return x;
    else return y;
  }
 
  li_chao(T mi , T ma) : MI(mi), MA(ma) , root(nullptr){}
 
  Node * insert(Node * p,T l,T r,Line &amp; line){
    if(!p) return new Node(line);
    if(comp(p-&gt;line.get(l) , line.get(l)) &amp;&amp; comp(p-&gt;line.get(r) ,line.get(r))){
      return p;
    }
    if(!comp(p-&gt;line.get(l) , line.get(l)) &amp;&amp; !comp(p-&gt;line.get(r) ,line.get(r))){
      p-&gt;line = line;
      return p;
    }
    T mid = (l + r) / 2;
    if(comp(line.get(mid) , p-&gt;line.get(mid))) swap(p-&gt;line , line);
    if(comp(line.get(l) , p-&gt;line.get(l))){
      p-&gt;lhs = insert(p-&gt;lhs , l , mid , line);
    }
    else{
      p-&gt;rhs = insert(p-&gt;rhs , mid, r , line);
    }
    return p;
  }
 
  void add_line(T a,T b){
    Line l(a , b);
    root = insert(root,MI,MA,l);
  }
 
  T get(Node * p,T l,T r,T t){
    if(!p) return ide;
    T mid = (l + r) / 2;
    if(t &lt;= mid) return comp_get(p-&gt;line.get(t) , get(p-&gt;lhs , l, mid,t));
    else return comp_get(p-&gt;line.get(t),get(p-&gt;rhs,mid ,r , t));
  }
 
  T get(T x){
    return get(root,MI,MA,x);
  }
};
</code></pre>
<h1><a class="header" href="#heap" id="heap">Heap</a></h1>
<h1><a class="header" href="#pairing-heap" id="pairing-heap">Pairing Heap</a></h1>
<p>マージ可能で高速なHeap</p>
<h3><a class="header" href="#spec-5" id="spec-5">Spec</a></h3>
<ul>
<li>
<p><code>top()</code></p>
<ul>
<li>最小値を返す</li>
<li>\( O(1) \)</li>
</ul>
</li>
<li>
<p><code>pop()</code></p>
<ul>
<li>最小値の要素を削除する</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
<li>
<p><code>push(const T&amp; x)</code></p>
<ul>
<li>要素<code>x</code>を追加する</li>
<li>\( O(1) \)</li>
</ul>
</li>
<li>
<p><code>meld(h)</code></p>
<ul>
<li>ヒープ<code>h</code>とマージする</li>
<li>\( O(1) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-5" id="code-5">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;list&gt;
using namespace std;

template&lt;class T, class Compare&gt;
struct pairing_heap {
  struct node {
    T val;
    node* head;
    node* next;
    node(const T&amp; v) : val(v), head(nullptr), next(nullptr) {  }
  };
  size_t sz;
  node* root;
  Compare comp;
  pairing_heap() : sz(0), root(nullptr) {  }
  node* merge(node* x, node* y) {
    if(!y) return x;
    if(!x) return y;
    if(!comp(x-&gt;val, y-&gt;val)) swap(x,y);
    y-&gt;next = x-&gt;head;
    x-&gt;head = y;
    return x;
  }
  node* mergeList(node * x) {
    node* nn = nullptr;
    while(x) {
      node* a = x;
      node* b = nullptr;
      x = x-&gt;next;
      a-&gt;next = nullptr;
      if(x) {
        b = x;
        x = x-&gt;next;
        b-&gt;next = nullptr;
      }
      a = merge(a, b);
      a-&gt;next = nn;
      nn = a;
    }
    while(nn) {
      node* j = nn;
      nn = nn-&gt;next;
      x = merge(j,x);
    }
    return x;
  }
  
  /* return compest element */
  T top() {
    return root-&gt;val;
  }

  /* pop compest element */
  void pop() {
    --sz;
    node* te = root;
    root = mergeList(root-&gt;head);
    delete te, te = nullptr;
  }
  
  /* add element */
  void push(const T&amp; x) {
    ++sz;
    root = merge(new node(x), root);
  }
  
  /* size */
  size_t size() {
    return sz;
  }
  
  /* merge heap */
  void meld(pairing_heap&lt;T,Compare&gt;&amp; h) {
    root = merge(root, h.root);
    h.root = nullptr;
    h.sz = 0;
  }
};
</code></pre>
<h1><a class="header" href="#trees" id="trees">Trees</a></h1>
<p>木を処理するやつ</p>
<ul>
<li><a href="data_structures/trees/./euler_tour_subtree.html">EulerTour Subtree</a></li>
<li><a href="data_structures/trees/./euler_tour_path.html">EulerTour Path</a></li>
<li><a href="data_structures/trees/./heavy_light_decomposition.html">Heavy Light Decomposition</a></li>
<li><a href="data_structures/trees/./link_cut_tree.html">Link Cut Tree</a></li>
<li><a href="data_structures/trees/./toptree.html">Top Tree</a></li>
</ul>
<h1><a class="header" href="#eulertour-subtree" id="eulertour-subtree">EulerTour Subtree</a></h1>
<p>EulerTourの部分木を処理するバージョン<br />
木を列に落とし込んだときの部分木の範囲がわかるので, <a href="data_structures/trees/../segment_tree/segment_tree.html">Segment Tree</a>と合わせて使うといい.</p>
<p>LCAをET Subtree + RMQで求める場合はコメントアウトしてある部分を使う.</p>
<h3><a class="header" href="#spec-6" id="spec-6">Spec</a></h3>
<ul>
<li>
<p><code>eulertour_subtree(i64 n)</code></p>
<ul>
<li><code>n</code>頂点の木を構築する準備</li>
</ul>
</li>
<li>
<p><code>add_edge(i64 u, i64 v)</code></p>
<ul>
<li>頂点<code>u</code>と<code>v</code>を結ぶ辺を追加する</li>
</ul>
</li>
<li>
<p><code>start_tour(i64 r)</code></p>
<ul>
<li><code>r</code>を根としてEulerTourを行う</li>
<li>\( O(n) \)</li>
</ul>
</li>
<li>
<p><code>subtree_range(i64 v)</code></p>
<ul>
<li>頂点<code>v</code>の部分木に対応する範囲を返す</li>
<li>\( O(1) \)</li>
</ul>
</li>
<li>
<p><code>vertex(i64 v)</code></p>
<ul>
<li>頂点<code>v</code>に対応するindexを返す.</li>
<li>\( O(1) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-6" id="code-6">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct eulertour_subtree {
  vector&lt;vector&lt;i64&gt;&gt; G;
  vector&lt;i64&gt; tour;
  vector&lt;i64&gt; L, R;
  vector&lt;i64&gt; depth;
  eulertour_subtree(i64 n): G(n), L(n), R(n), depth(n) {}
  void add_edge(i64 u, i64 v) {
    G[u].push_back(v);
    G[v].push_back(u);
  }

  void dfs(i64 v, i64 f, i64 d) {
    tour.push_back(v);
    L[v] = tour.size() - 1;
    depth[v] = d;
    for(auto to: G[v]) {
      if(to == f) continue;
      dfs(to, v, d + 1);
      //tour.push_back(v);
    }
    R[v] = tour.size() - 1;
  }

  void start_tour(i64 r) {
    dfs(r, -1, 0);
  }

  //[L[v], R[v])
  pair&lt;i64, i64&gt; subtree_range(i64 v) {
    return pair&lt;i64, i64&gt;(L[v], R[v]);
  }

  i64 vertex(i64 v) {
    return L[v];
  }
};
</code></pre>
<h1><a class="header" href="#eulertour-path" id="eulertour-path">EulerTour Path</a></h1>
<p>EulerTourのパスを処理するバージョン<br />
パスとして求められるのは, 上から下に降りるようなパスだけなので, 任意のパスを扱うときはLCAをしないといけない.<br />
扱える要素には, 可逆性, 可換性(?)が必要.</p>
<h3><a class="header" href="#spec-7" id="spec-7">Spec</a></h3>
<ul>
<li>
<p><code>euler_tour_path(i64 n)</code></p>
<ul>
<li><code>n</code>頂点の木を構築する準備</li>
</ul>
</li>
<li>
<p><code>add_edge(i64 u, i64 v)</code></p>
<ul>
<li>頂点<code>u</code>と<code>v</code>を結ぶ辺を追加する</li>
</ul>
</li>
<li>
<p><code>start_tour(i64 r)</code></p>
<ul>
<li><code>r</code>を根としてEulerTourを行う</li>
<li>\( O(n) \)</li>
</ul>
</li>
<li>
<p><code>edge_in(i64 v)</code></p>
<ul>
<li>頂点<code>v</code>に入る辺のindexを返す</li>
<li>\( O(1) \)</li>
</ul>
</li>
<li>
<p><code>edge_out(i64 v)</code></p>
<ul>
<li>頂点<code>v</code>に出る辺のindexを返す</li>
<li>\( O(1) \)</li>
</ul>
</li>
<li>
<p><code>path_range(i64 u, i64 v)</code></p>
<ul>
<li>頂点<code>u</code>から降りて頂点<code>v</code>に辿るパスの範囲を返す.</li>
<li>\( O(1) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-7" id="code-7">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct eulartour_path {
  vector&lt;vector&lt;i64&gt;&gt; G;
  vector&lt;i64&gt; in, out;
  i64 cnt;
  eulartour_path(i64 n): G(n), in(n), out(n) {}
  void add_edge(i64 u, i64 v) {
    G[u].push_back(v);
    G[v].push_back(u);
  }

  void dfs(i64 v, i64 f) {
    for(auto to: G[v]) {
      if(to == f) continue;
      in[to] = cnt;
      cnt++;
      dfs(to, v);
      out[to] = cnt;
      cnt++;
    }
  }

  void start_tour(i64 r) {
    in[r] = cnt;
    cnt++;
    dfs(r, -1);
  }

  i64 edge_in(i64 v) { return in[v]; }
  i64 edge_out(i64 v) { return out[v]; }
  pair&lt;i64, i64&gt; path_range(i64 u, i64 v) {
    return { in[u] + 1, in[v] + 1 };
  }
};


</code></pre>
<h1><a class="header" href="#heavy-light-decomposition" id="heavy-light-decomposition">Heavy Light Decomposition</a></h1>
<p>静的木</p>
<p>木のパスや部分木のクエリを処理できる.</p>
<h3><a class="header" href="#spec-8" id="spec-8">Spec</a></h3>
<ul>
<li>
<p><code>HeavyLightDecomposition(i64 n)</code></p>
<ul>
<li>頂点数<code>n</code>で初期化</li>
</ul>
</li>
<li>
<p><code>add_edge(i64 u, i64 v)</code></p>
<ul>
<li>頂点<code>u</code>と<code>v</code>をつなぐ</li>
</ul>
</li>
<li>
<p><code>build(i64 r)</code></p>
<ul>
<li><code>r</code>を根としてHLDecompを行う</li>
</ul>
</li>
<li>
<p><code>sequence()</code></p>
<ul>
<li>HLDecompしたときのオイラーツアーの配列.</li>
</ul>
</li>
<li>
<p><code>path(i64 a, i64 b, bool edge)</code></p>
<ul>
<li>パスの列を返す.</li>
<li><code>edge = true</code>で辺に対するパスを返す.</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
<li>
<p><code>subtree(i64 v, bool edge)</code></p>
<ul>
<li>部分木の列を返す.</li>
<li><code>edge = true</code>で辺に対するパスを返す.</li>
<li>\( O(1) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-8" id="code-8">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct HeavyLightDecomposition {
  vector&lt;vector&lt;i64&gt;&gt; G;
  vector&lt;i64&gt; in, out;
  vector&lt;i64&gt; sz;
  vector&lt;i64&gt; seq;
  vector&lt;i64&gt; next;
  vector&lt;i64&gt; par;


  HeavyLightDecomposition(i64 n)
    : G(n), in(n), out(n), sz(n), next(n, -1), par(n, -1) {}

  void add_edge(i64 u, i64 v) {
    G[u].push_back(v);
    G[v].push_back(u);
  }

  void dfs_sz(i64 v, i64 f) {
    sz[v] = 1;
    for(i64 i = 0;i &lt; G[v].size();i++) {
      i64 x = G[v][i];
      if(x == f) continue;
      dfs_sz(x, v);
      par[x] = v;
      sz[v] += sz[x];
      if(sz[G[v][0]] &lt; sz[G[v][i]]) { swap(G[v][0], G[v][i]); }
    }
  }

  i64 dfs_eul(i64 v, i64 f, i64 t) {
    in[v] = t++;
    seq.push_back(v);
    for(i64 i = 0;i &lt; G[v].size();i++) {
      i64 x = G[v][i];
      if(x == f) continue;
      next[x] = (i == 0) ? next[v] : x;
      t = dfs_eul(x, v, t);
    }
    return out[v] = t;
  }

  void build(i64 r) {
    dfs_sz(r, -1);
    dfs_eul(r, -1, 0);
  }

  const vector&lt;i64&gt;&amp; sequence() const { return seq; }
  i64 lca(i64 a, i64 b) const {
    while(true) {
      if(in[b] &gt; in[a]) swap(a, b);
      if(next[b] == next[a]) return b;
      a = par[next[a]];
    }
  }

  pair&lt;vector&lt;pair&lt;i64, i64&gt;&gt;, vector&lt;pair&lt;i64, i64&gt;&gt;&gt; path(i64 a, i64 b, bool edge) const {
    vector&lt;pair&lt;i64, i64&gt;&gt; l, r;
    while(true) {
      if(in[b] &gt; in[a]) { swap(a, b); swap(l, r); }
      if(next[b] == next[a]) {
        l.push_back({ in[b] + !!edge, in[a] + 1 });
        break;
      }
      l.push_back({ in[next[a]], in[a] + 1 });
      a = par[next[a]];
    }
    return { std::move(l), std::move(r) };
  }

  pair&lt;i64, i64&gt; subtree(i64 v, bool edge) { return { in[v] + !!edge, out[v] }; }
};
</code></pre>
<h1><a class="header" href="#link-cut-tree" id="link-cut-tree">Link Cut Tree</a></h1>
<p>動的木</p>
<p>パスのsumを計算したり, パスに対する作用を遅延伝搬できる.</p>
<h3><a class="header" href="#spec-9" id="spec-9">Spec</a></h3>
<ul>
<li>
<p><code>struct node</code></p>
<ul>
<li>link cut treeで扱うノードの構造体</li>
<li>この中に載せたいデータを載せる</li>
</ul>
</li>
<li>
<p><code>fix(node * n)</code></p>
<ul>
<li>ノードの情報の再計算をする</li>
</ul>
</li>
<li>
<p><code>reverse(node * n)</code></p>
<ul>
<li>平衡二分木の反転</li>
<li>モノイドの演算順序が反転するのでその処理を書く</li>
<li>モノイドが可換であれば問題ない</li>
</ul>
</li>
<li>
<p><code>lazy(node * n, i64 l)</code></p>
<ul>
<li>遅延伝搬するときの演算</li>
<li><code>expose(n); lazy(n, x)</code>をすると, <code>[root, n]</code>のパスに<code>x</code>を作用させることになる</li>
</ul>
</li>
<li>
<p><code>push(node* n)</code></p>
<ul>
<li>遅延伝搬</li>
<li>lazyを変えている場合はここも変更</li>
</ul>
</li>
<li>
<p><code>expose(node* n)</code></p>
<ul>
<li><code>n</code>をLink Cut Treeの根として, その木が<code>[root, n]</code>のパスをあらわすようになる</li>
</ul>
</li>
<li>
<p><code>link(node* p, node* c)</code></p>
<ul>
<li><code>p</code>を親, <code>c</code>を子として繋げる</li>
</ul>
</li>
<li>
<p><code>cut(node* c)</code></p>
<ul>
<li><code>c</code>の親とつながっている辺を切る</li>
</ul>
</li>
<li>
<p><code>evert(node* t)</code></p>
</li>
<li>
<p><code>t</code>を親にする</p>
</li>
</ul>
<h3><a class="header" href="#code-9" id="code-9">Code</a></h3>
<p>パス加算, パスsumを処理している</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

namespace link_cut_tree {
  struct node {
    node* ch[2];
    node* par;
    bool rev;

    i64 sz;
    i64 val;
    i64 fold;

    i64 lazy;
    node(i64 v) {
      ch[0] = nullptr;
      ch[1] = nullptr;
      par = nullptr;
      rev = false;

      sz = 1;
      val = v;
      fold = v;

      lazy = 0;
    }
  };

  i64 size(node* n) {
    if(n) return n-&gt;sz;
    return 0;
  }

  i64 fold(node* n) {
    if(n) return n-&gt;fold;
    return 0;
  }
  

  void fix(node * n) {
    if(n) {
      /* fix operation here */
      n-&gt;sz = 1 + size(n-&gt;ch[0]) + size(n-&gt;ch[1]);
      n-&gt;fold = n-&gt;val + fold(n-&gt;ch[0]) + fold(n-&gt;ch[1]);
    }
  }

  void reverse(node* n) {
    if(n) {
      n-&gt;rev ^= true;
      swap(n-&gt;ch[0], n-&gt;ch[1]);
      /* reverse operation here */
    }
  }

  void lazy(node* n, i64 l) {
    if(n) {
      n-&gt;lazy += l;
      n-&gt;val += l;
      n-&gt;fold += l * size(n);
    }
  }

  void push(node* n) {
    if(n) {
      if(n-&gt;rev) {
        reverse(n-&gt;ch[0]);
        reverse(n-&gt;ch[1]);
      }
      lazy(n-&gt;ch[0], n-&gt;lazy);
      lazy(n-&gt;ch[1], n-&gt;lazy);
      n-&gt;lazy = 0;
    }
  }

  i64 pdir(node* n) {
    if(n-&gt;par) {
      if(n-&gt;par-&gt;ch[0] == n) return 0;
      if(n-&gt;par-&gt;ch[1] == n) return 1;
    }
    return -1;
  }

  void rot(node* n, i64 dir) {
    node* x = n-&gt;par;
    node* y = n-&gt;par-&gt;par;
    i64 pd = pdir(x);
    x-&gt;ch[dir ^ 1] = n-&gt;ch[dir];
    if(n-&gt;ch[dir]) n-&gt;ch[dir]-&gt;par = x;
    n-&gt;ch[dir] = x;
    x-&gt;par = n;
    fix(x);
    fix(n);
    n-&gt;par = y;
    if(pd &gt;= 0) {
      y-&gt;ch[pd] = n;
      fix(y);
    }
  }

  void splay(node* t) {
    while(pdir(t) &gt;= 0) {
      node* q = t-&gt;par;
      if(pdir(q) == -1) {
        push(q);
        push(t);
        rot(t, pdir(t) ^ 1);
      }
      else {
        node* r = q-&gt;par;
        push(r);
        push(q);
        push(t);
        i64 rq = pdir(q) ^ 1;
        i64 qt = pdir(t) ^ 1;
        if(rq == qt) {
          rot(q, rq);
          rot(t, qt);
        }
        else {
          rot(t, qt);
          rot(t, rq);
        }
      }
    }
  }

  /* 一番上のsplay treeが[root, t]を表すようになる */
  void expose(node* t) {
    node* rp = nullptr;
    for(node* cur = t; cur; cur = cur-&gt;par) {
      splay(cur);
      cur-&gt;ch[1] = rp;
      fix(cur);
      rp = cur;
    }
    splay(t);
  }

  void link(node* p, node* c) {
    expose(c);
    expose(p);
    p-&gt;ch[1] = c;
    c-&gt;par = p;
  }
  
  /* cut edge (c-&gt;par, c) */
  void cut(node* c) {
    expose(c);
    node* p = c-&gt;ch[0];
    c-&gt;ch[0] = nullptr;
    p-&gt;par = nullptr;
  }

  void evert(node* t) {
    expose(t);
    reverse(t);
    push(t);
  }
};

int main() {
  i64 n;
  cin &gt;&gt; n;
  
  namespace lct = link_cut_tree;

  vector&lt;lct::node*&gt; ns;
  for(int i = 0;i &lt; n;i++) {
    ns.push_back(new lct::node(0ll));
  }

  for(int i = 0;i &lt; n;i++) {
    i64 k;
    cin &gt;&gt; k;
    for(int j = 0;j &lt; k;j++) {
      i64 c;
      cin &gt;&gt; c;
      lct::link(ns[i], ns[c]);
    }
  }

  i64 Q;
  cin &gt;&gt; Q;
  for(int q = 0; q &lt; Q; q++) {
    i64 type = 0;
    cin &gt;&gt; type;
    if(type == 0) {
      i64 v, w;
      cin &gt;&gt; v &gt;&gt; w;
      lct::expose(ns[v]);
      lct::lazy(ns[v], w);
      push(ns[v]);
    }
    else {
      i64 u;
      cin &gt;&gt; u;
      lct::expose(ns[u]);
      i64 val = ns[u]-&gt;fold;
      lct::expose(ns[0]);
      val -= ns[0]-&gt;val;
      cout &lt;&lt; val &lt;&lt; endl;
    }
  }
}
</code></pre>
<h1><a class="header" href="#top-tree" id="top-tree">Top Tree</a></h1>
<p>なにこれ</p>
<h3><a class="header" href="#spec-10" id="spec-10">Spec</a></h3>
<p>え</p>
<h3><a class="header" href="#code-10" id="code-10">Code</a></h3>
<pre><code class="language-cpp">#include &lt;utility&gt;
#include &lt;array&gt;
#include &lt;cassert&gt;

using i64 = long long;

struct cluster {
  i64 inter_weight;
  i64 left_sum;
  i64 right_sum;
  i64 ans;
  i64 length;

  using V = std::size_t;
  cluster(i64 l): inter_weight(0), ans(0), left_sum(0), right_sum(0), length(l) {}
  cluster(i64 a, i64 b, i64 c, i64 d, i64 e): inter_weight(a), ans(b), left_sum(c), right_sum(d), length(e) {}
  static cluster identity() {
    return cluster(0);
  }
  static cluster compress(const cluster&amp; a, const cluster&amp; b, V av, V bv, V cv) {
    return cluster(
        a.inter_weight + b.inter_weight + cv,
        a.right_sum + b.left_sum + a.length * av + b.length * bv,
        a.left_sum + b.left_sum + a.length * (b.inter_weight + cv),
        b.right_sum + a.right_sum + b.length * (a.inter_weight + cv),
        a.length + b.length
        );
  }
  static cluster rake(const cluster&amp; a, const cluster&amp; b, V av, V bv, V cv) {
    return cluster(
        a.inter_weight + b.inter_weight + bv,
        0ll,
        a.left_sum + b.right_sum + a.length * b.inter_weight + (a.length + b.length) * bv,
        a.right_sum + b.right_sum + b.length * bv,
        a.length
        );
  }
  static cluster reverse(const cluster&amp; c) {
    cluster res = c;
    std::swap(res.left_sum, res.right_sum);
    return res;
  }
  static std::size_t select(const cluster&amp; a, const cluster&amp; b, V av, V bv, V cv) {
    if(a.inter_weight + av + cv &gt;= b.inter_weight + bv + cv) { return 0; }
    else { return 1; }
  }
};

class vertex;

class node;
int parent_dir(node*);
node* link(vertex, vertex, cluster);
void test_comp_set(node* n);

class vertex_raw {
  cluster::V val;
  node* hand;

public:

  vertex_raw(cluster::V val): val(val), hand(nullptr) {}

  node* handle() const { return this-&gt;hand; }
  void set_handle(node* hand) { this-&gt;hand = hand; }
  const cluster::V&amp; value() const { return this-&gt;val; }
  void set_value(cluster::V val) {
    this-&gt;val = val;
  }
};

class vertex {
  vertex_raw* ver;

private:


public:

  static vertex dangling() { return vertex(); } 

  vertex(): ver(nullptr) {}
  vertex(cluster::V val): ver( new vertex_raw(val)) {
    vertex dummy;
    dummy.ver = new vertex_raw(cluster::V());
    link(*this, dummy, cluster::identity());
  }

  bool operator==(const vertex&amp; other) { return this-&gt;ver == other.ver; }
  
  inline node* handle() const { return this-&gt;ver-&gt;handle(); }
  inline void set_handle(node* hand) { this-&gt;ver-&gt;set_handle(hand); }
  inline const cluster::V&amp; value() const { return this-&gt;ver-&gt;value(); }
  inline void set_value(cluster::V val) { this-&gt;ver-&gt;set_value(val); }
};

enum class Type { Compress, Rake, Edge, None };

static std::size_t ni = 0;
extern node ns[1010101];

class node {
  node* ch[2];
  node* par;
  node* ra;
  node* me;
  bool rev;
  cluster fo;
  vertex v[2];
  Type ty;



public:

  node(): par(nullptr), ra(nullptr), me(nullptr), rev(false),
    fo(cluster::identity()), ty(Type::None) {} 



  static node* new_edge(vertex v, vertex u, cluster val) {
    //node* n = new node();
    node* n = ns + (ni++);
    n-&gt;v[0] = v;
    n-&gt;v[1] = u;
    n-&gt;fo = val;
    n-&gt;me = n;
    n-&gt;ty = Type::Edge;

    n-&gt;fix();

    return n;
  }

  static node* new_compress(node* left, node* right) {
    //node* n = new node();
    node* n = ns + (ni++);
    n-&gt;ch[0] = left;
    n-&gt;ch[1] = right;
    n-&gt;me = n;
    n-&gt;ty = Type::Compress;
    n-&gt;fix();
    return n;
  }

  static node* new_rake(node* left, node* right) {
    //node * n = new node();
    node* n = ns + (ni++);
    n-&gt;ch[0] = left;
    n-&gt;ch[1] = right;
    n-&gt;me = n;
    n-&gt;ty = Type::Rake;
    n-&gt;fix();
    return n;
  }

  inline void fix() {
    if(this-&gt;ty == Type::Edge) {
      if(!this-&gt;parent()) {
        this-&gt;endpoint(0).set_handle(this-&gt;me);
        this-&gt;endpoint(1).set_handle(this-&gt;me);
      }
      else if(this-&gt;parent()-&gt;ty == Type::Compress) {
        if(parent_dir(this-&gt;me) == -1) {
          this-&gt;endpoint(0).set_handle(this-&gt;me);
        }
      }
      else if(this-&gt;parent()-&gt;ty == Type::Rake) {
        this-&gt;endpoint(0).set_handle(this-&gt;me);
      }
    }
    else if(this-&gt;ty == Type::Compress) {
      this-&gt;push();
      this-&gt;v[0] = this-&gt;child(0)-&gt;endpoint(0);
      this-&gt;v[1] = this-&gt;child(1)-&gt;endpoint(1);
      assert(this-&gt;child(0)-&gt;endpoint(1) == this-&gt;child(1)-&gt;endpoint(0));

      cluster left = this-&gt;child(0)-&gt;fold();
      node* l = this-&gt;child(0);
      if(this-&gt;rake()) {
        node* r = this-&gt;rake();
        left = cluster::rake(l-&gt;fold(), r-&gt;fold(), l-&gt;endpoint(0).value(), r-&gt;endpoint(0).value(), l-&gt;endpoint(1).value());
      }
      node* r = this-&gt;child(1);
      this-&gt;fo= cluster::compress(left, r-&gt;fold(),
          l-&gt;endpoint(0).value(), r-&gt;endpoint(1).value(), l-&gt;endpoint(1).value());
      
      this-&gt;child(0)-&gt;endpoint(1).set_handle(this-&gt;me);

      if(!this-&gt;parent()) {
        this-&gt;endpoint(0).set_handle(this-&gt;me);
        this-&gt;endpoint(1).set_handle(this-&gt;me);
      }
      else if(this-&gt;parent()-&gt;ty == Type::Compress) {
        if(parent_dir(this-&gt;me) == -1) {
          this-&gt;endpoint(0).set_handle(this-&gt;me);
        }
      }
      else if(this-&gt;parent()-&gt;ty == Type::Rake) {
        this-&gt;endpoint(0).set_handle(this-&gt;me);
      }

    }
    else if(this-&gt;ty == Type::Rake) {
      this-&gt;push();
      this-&gt;v[0] = this-&gt;child(0)-&gt;endpoint(0);
      this-&gt;v[1] = this-&gt;child(0)-&gt;endpoint(1);
      this-&gt;fo = cluster::rake(this-&gt;child(0)-&gt;fold(), this-&gt;child(1)-&gt;fold(),
          this-&gt;child(0)-&gt;endpoint(0).value(), this-&gt;child(1)-&gt;endpoint(0).value(), this-&gt;child(0)-&gt;endpoint(1).value());
    }
    else { assert(false); }
  }

  inline void push() {
    if(this-&gt;ty == Type::Compress) {
      if(this-&gt;rev) {
        std::swap(this-&gt;ch[0], this-&gt;ch[1]);
        this-&gt;child(0)-&gt;reverse();
        this-&gt;child(1)-&gt;reverse();
        this-&gt;rev = false;
      }
    }
  }

  inline void reverse() {
    if(this-&gt;ty == Type::Edge) {
      std::swap(this-&gt;v[0], this-&gt;v[1]);
      this-&gt;fo = cluster::reverse(this-&gt;fold());
    }
    else if(this-&gt;ty == Type::Compress) {
      std::swap(this-&gt;v[0], this-&gt;v[1]);
      this-&gt;fo = cluster::reverse(this-&gt;fold());
      this-&gt;rev ^= true;
    }
    else if(this-&gt;ty == Type::Rake) {
    }
    else { assert(false); }
  }

  inline node* parent() const { return this-&gt;par; }
  inline void set_parent(node* par) { this-&gt;par = par; }
  inline node* rake() const { return this-&gt;ra; }
  inline void set_rake(node* rake) { this-&gt;ra = rake; }
  inline node* child(std::size_t dir) const { return this-&gt;ch[dir]; }
  inline void set_child(node* ch, std::size_t dir) { this-&gt;ch[dir] = ch; }
  inline vertex endpoint(std::size_t dir) { return this-&gt;v[dir]; }
  inline Type type() const { return this-&gt;ty; }

  cluster fold() const { return this-&gt;fo; }

  bool guard;
};

int parent_dir(node* child) {
  node* par = child-&gt;parent();
  if(par) {
    if(par-&gt;guard) { return -1; }
    else if(par-&gt;child(0) == child) { return 0; }
    else if(par-&gt;child(1) == child) { return 1; }
    else { return -1; }
  }
  else { return -1; }
}

int parent_dir_guard(node* child) {
  node* par = child-&gt;parent();
  if(par) {
    if(par-&gt;child(0) == child) { return 0; }
    else if(par-&gt;child(1) == child) { return 1; }
    else { return -1; }
  }
  else { return -1; }
}

void rotate(node* t, node* x, std::size_t dir) {
  node* y = x-&gt;parent();
  int par = parent_dir_guard(x);
  t-&gt;child(dir)-&gt;push();
  x-&gt;set_child(t-&gt;child(dir), dir ^ 1);
  t-&gt;child(dir)-&gt;set_parent(x);
  t-&gt;set_child(x, dir);
  x-&gt;set_parent(t);
  t-&gt;set_parent(y);
  if(par != -1) {
    y-&gt;set_child(t, par);
  }
  else if(y &amp;&amp; y-&gt;type() == Type::Compress) {
    y-&gt;set_rake(t);
  }
  x-&gt;fix();
  t-&gt;fix();
  if(y &amp;&amp; !y-&gt;guard) { y-&gt;fix(); }
}

void splay(node* t) {
  assert(t-&gt;type() != Type::Edge);
  t-&gt;push();

  while(parent_dir(t) != -1) {
    node* q = t-&gt;parent();
    if(q-&gt;type() != t-&gt;type()) break;
    if(parent_dir(q) != -1 &amp;&amp; q-&gt;parent() &amp;&amp; q-&gt;parent()-&gt;type() == q-&gt;type()) {
      node* r = q-&gt;parent();
      if(r-&gt;parent()) r-&gt;parent()-&gt;push();
      r-&gt;push();
      q-&gt;push();
      t-&gt;push();
      int qt_dir = parent_dir(t);
      int rq_dir = parent_dir(q);
      if(rq_dir == qt_dir) {
        rotate(q, r, rq_dir ^ 1);
        rotate(t, q, qt_dir ^ 1);
      }
      else {
        rotate(t, q, qt_dir ^ 1);
        rotate(t, r, rq_dir ^ 1);
      }
    }
    else {
      if(q-&gt;parent()) q-&gt;parent()-&gt;push();
      q-&gt;push();
      t-&gt;push();
      int qt_dir = parent_dir(t);
      rotate(t, q, qt_dir ^ 1);
    }
  }
}

node* expose_raw(node* t) {
  while(true) {
    assert(t-&gt;type() != Type::Rake);
    if(t-&gt;type() == Type::Compress) {
      splay(t);
    }
    node* n = nullptr;
    {
      node* par = t-&gt;parent();
      if(!par) { break; }
      else if(par-&gt;type() == Type::Rake) {
        par-&gt;push();
        splay(par);
        n = par-&gt;parent();
      }
      else if(par-&gt;type() == Type::Compress) {
        par-&gt;push();
        if(par-&gt;guard &amp;&amp; parent_dir_guard(t) != -1) { break; }
        n = par;
      }
      else { assert(false); }
    }

    splay(n);

    
    int dir = parent_dir_guard(n);
    if(dir == -1 || n-&gt;parent()-&gt;type() == Type::Rake) dir = 0;
    if(dir == 1) {
      n-&gt;child(dir)-&gt;reverse();
      n-&gt;child(dir)-&gt;push();
      t-&gt;reverse();
      t-&gt;push();
    }
    int n_dir = parent_dir(t);
    if(n_dir != -1) {
      node* nch = n-&gt;child(dir);
      nch-&gt;push();
      node* rake = t-&gt;parent();
      rake-&gt;push();

      rake-&gt;set_child(nch, n_dir);
      nch-&gt;set_parent(rake);
      n-&gt;set_child(t, dir);
      t-&gt;set_parent(n);
      nch-&gt;fix();
      rake-&gt;fix();
      t-&gt;fix();
      n-&gt;fix();
      splay(rake);
    }
    else {
      node* nch = n-&gt;child(dir);
      nch-&gt;push();
      n-&gt;set_rake(nch);
      nch-&gt;set_parent(n);
      n-&gt;set_child(t, dir);
      t-&gt;set_parent(n);

      nch-&gt;fix();
      t-&gt;fix();
      n-&gt;fix();
    }
    if(t-&gt;type() == Type::Edge) {
      t = n;
    }
  }
  
  return t;
}

node* expose(vertex ver) {
  return expose_raw(ver.handle());
}

void soft_expose(vertex v, vertex u) {
  node* root = expose(v);
  if(v.handle() == u.handle()) {
    if(root-&gt;endpoint(1) == v || root-&gt;endpoint(0) == u) {
      root-&gt;reverse();
      root-&gt;push();
    }
    return;
  }
  root-&gt;guard = true;
  node* soot = expose(u);
  root-&gt;guard = false;
  root-&gt;fix();
  if(parent_dir(soot) == 0) {
    root-&gt;reverse();
    root-&gt;push();
  }
}

node* link(vertex v, vertex u, cluster weight) {
  if(!v.handle() &amp;&amp; !u.handle()) {
    return node::new_edge(v, u, weight);
  }
  else {
    node* nnu = u.handle();
    node* nnv = v.handle();
    node* e = node::new_edge(v, u, weight);
    node* left = nullptr;

    if(!nnu) { left = e; }
    else {
      node* uu = expose_raw(nnu);
      uu-&gt;push();
      if(uu-&gt;endpoint(1) == u) {
        uu-&gt;reverse();
        uu-&gt;push();
      }
      if(uu-&gt;endpoint(0) == u) {
        node* nu = node::new_compress(e, uu);
        e-&gt;set_parent(nu);
        e-&gt;fix();
        uu-&gt;set_parent(nu);
        uu-&gt;fix();
        nu-&gt;fix();

        left = nu;
      }
      else {
        node* nu = uu;
        node* left_ch = nu-&gt;child(0);
        left_ch-&gt;push();

        nu-&gt;set_child(e, 0);
        e-&gt;set_parent(nu);
        e-&gt;fix();
        
        node* beta = nu-&gt;rake();
        node* rake = nullptr;
        if(beta) {
          beta-&gt;push();
          rake = node::new_rake(beta, left_ch);
          beta-&gt;set_parent(rake);
          left_ch-&gt;set_parent(rake);
          beta-&gt;fix();
          left_ch-&gt;fix();
        }
        else {
          rake = left_ch;
        }
        nu-&gt;set_rake(rake);
        rake-&gt;set_parent(nu);
        rake-&gt;fix();
        nu-&gt;fix();

        left = nu;
      }
    }

    if(!nnv) {}
    else {
      node* vv =expose_raw(nnv);
      vv-&gt;push();
      if(vv-&gt;endpoint(0) == v) {
        vv-&gt;reverse();
        vv-&gt;push();
      }
      if(vv-&gt;endpoint(1) == v) {
        node* top = node::new_compress(vv, left);
        vv-&gt;set_parent(top);
        left-&gt;set_parent(top);
        vv-&gt;fix();
        left-&gt;fix();
        top-&gt;fix();
      }
      else {
        node* nv = vv;
        node* right_ch = nv-&gt;child(1);
        right_ch-&gt;reverse();
        right_ch-&gt;push();

        nv-&gt;set_child(left, 1);
        left-&gt;set_parent(nv);
        left-&gt;fix();

        node* alpha = nv-&gt;rake();
        node* rake = nullptr;
        if(alpha) {
          alpha-&gt;push();
          rake = node::new_rake(alpha, right_ch);
          alpha-&gt;set_parent(rake);
          alpha-&gt;fix();
          right_ch-&gt;set_parent(rake);
          right_ch-&gt;fix();
        }
        else {
          rake = right_ch;
        }
        nv-&gt;set_rake(rake);
        rake-&gt;set_parent(nv);
        rake-&gt;fix();
        nv-&gt;fix();
      }
    }

    return e;
  }
}

void bring(node* root) {
  node* rake = root-&gt;rake();

  if(!rake) {
    node* left = root-&gt;child(0);
    //delete root, root = nullptr;
    left-&gt;set_parent(nullptr);
    left-&gt;fix();
  }
  else if(rake-&gt;type() == Type::Compress || rake-&gt;type() == Type::Edge) {
    rake-&gt;push();
    node* new_right = rake;
    new_right-&gt;reverse();
    new_right-&gt;push();

    root-&gt;set_child(new_right, 1);
    new_right-&gt;set_parent(root);

    root-&gt;set_rake(nullptr);

    new_right-&gt;fix();
    root-&gt;fix();
  }
  else if(rake-&gt;type() == Type::Rake) {
    rake-&gt;push();
    while(rake-&gt;child(1)-&gt;type() == Type::Rake) {
      rake-&gt;child(1)-&gt;push();
      rake = rake-&gt;child(1);
    }
    root-&gt;guard = true;
    splay(rake);
    root-&gt;guard = false;

    node* new_rake = rake-&gt;child(0);
    node* new_right = rake-&gt;child(1);

    //delete rake, rake = nullptr;
    new_right-&gt;reverse();
    new_right-&gt;push();

    root-&gt;set_child(new_right, 1);
    new_right-&gt;set_parent(root);

    root-&gt;set_rake(new_rake);
    new_rake-&gt;set_parent(root);

    new_rake-&gt;fix();
    new_right-&gt;fix();
    root-&gt;fix();
  }
}

void cut(vertex v, vertex u) {
  soft_expose(v, u);
  node* root = v.handle();
  root-&gt;push();
  node* right = root-&gt;child(1);
  right-&gt;set_parent(nullptr);

  right-&gt;reverse();
  right-&gt;push();

  bring(right);
  bring(root);
}

cluster path_query(vertex v, vertex u) {
  soft_expose(v, u);
  node* root = v.handle();
  root-&gt;push();
  if(root-&gt;endpoint(0) == v &amp;&amp; root-&gt;endpoint(1) == u) {
    return root-&gt;fold();
  }
  else if(root-&gt;endpoint(0) == v) {
    return root-&gt;child(0)-&gt;fold();
  }
  else if(root-&gt;endpoint(1) == u) {
    return root-&gt;child(1)-&gt;fold();
  }
  else {
    root-&gt;child(1)-&gt;push();
    return root-&gt;child(1)-&gt;child(0)-&gt;fold();
  }
}

node* select_rake(node* rake, cluster&amp; right, cluster::V&amp; rv0, cluster::V&amp; rv1) {
  rake-&gt;push();
  while(rake-&gt;type() == Type::Rake) {
    node* l = rake-&gt;child(0);
    node* r = rake-&gt;child(1);
    l-&gt;push();
    r-&gt;push();

    cluster rf = cluster::rake(r-&gt;fold(), right, r-&gt;endpoint(0).value(), rv0, r-&gt;endpoint(1).value());
    cluster::V r0 = r-&gt;endpoint(0).value();

    std::size_t dir = cluster::select(l-&gt;fold(), rf, l-&gt;endpoint(0).value(), r0, l-&gt;endpoint(1).value());
    r = rake-&gt;child(1 - dir);
    rake = rake-&gt;child(dir);


    right = cluster::rake(r-&gt;fold(), right, r-&gt;endpoint(0).value(), rv0, r-&gt;endpoint(1).value());
    rv0 = r-&gt;endpoint(0).value();
    rv1 = r-&gt;endpoint(1).value();

    rake-&gt;push();
  }
  return rake;
}

std::pair&lt;vertex, vertex&gt; select(vertex v) {
  node* n = expose(v);
  cluster lf = cluster::identity();
  cluster::V l0, l1;
  bool luse = false;
  cluster rf = cluster::identity();
  cluster::V r0, r1;
  bool ruse = false;

  n-&gt;push();
  while(n-&gt;type() == Type::Compress) {
    node* a = n-&gt;child(0);
    node* b = n-&gt;child(1);
    node* r = n-&gt;rake();
    a-&gt;push();
    b-&gt;push();
    if(r) { r-&gt;push(); }

    cluster af = a-&gt;fold();
    cluster::V a0 = a-&gt;endpoint(0).value();
    cluster::V a1 = a-&gt;endpoint(1).value();
    if(luse) {
      af = cluster::compress(lf, af, l0, a1, l1);
      a0 = l0;
      a1 = a1;
    }
    cluster bf = b-&gt;fold();
    cluster::V b0 = b-&gt;endpoint(0).value();
    cluster::V b1 = b-&gt;endpoint(1).value();
    if(ruse) {
      bf = cluster::compress(bf, rf, b0, r1, b1);
      b0 = b0;
      b1 = r1;
    }
    cluster arf = af;
    if(r) {
      arf = cluster::rake(af, r-&gt;fold(), a0, r-&gt;endpoint(0).value(), a1);
    }

    std::size_t dir = cluster::select(arf, bf, a0, b1, a1);
    
    if(dir == 0) {
      if(r) {
        cluster rbf = cluster::reverse(bf);
        cluster::V rb0 = b1;

        cluster rrf = cluster::rake(r-&gt;fold(), rbf, r-&gt;endpoint(0).value(), rb0, r-&gt;endpoint(1).value());
        cluster::V rr0 = r-&gt;endpoint(0).value();
        cluster::V rr1 = r-&gt;endpoint(1).value();

        dir = cluster::select(af, rrf, a0, rr0, a1);
        if(dir == 0) {
          rf = cluster::reverse(rrf);
          r0 = rr1;
          r1 = rr0;
          ruse = true;
          n = n-&gt;child(0);
        }
        else {
          luse = false;
          rf = cluster::rake(af, rbf, a0, rb0, a1);
          r0 = a0;
          r1 = a1;
          ruse = true;
          n = select_rake(r, rf, r0, r1);
          rf = cluster::reverse(rf);
          std::swap(r0, r1);
        }
      }
      else {
        rf = bf;
        r0 = b0;
        r1 = b1;
        ruse = true;
        n = n-&gt;child(0);
      }
    }
    else {
      lf = arf;
      l0 = a0;
      l1 = a1;
      luse = true;
      n = n-&gt;child(1);
    }

    n-&gt;push();
  }
  return { n-&gt;endpoint(0), n-&gt;endpoint(1) };
}

node ns[1010101];

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;tuple&gt;

using namespace std;


int main() {
}
</code></pre>
<h1><a class="header" href="#union-find" id="union-find">Union Find</a></h1>
<ul>
<li><a href="data_structures/union_find/./data_structures/union_find/union_find.html">Union Find</a></li>
<li><a href="data_structures/union_find/./data_structures/union_find/persistent_union_find.html">Persistent Union Find</a></li>
</ul>
<h1><a class="header" href="#union-find-1" id="union-find-1">Union Find</a></h1>
<h2><a class="header" href="#spec-11" id="spec-11">Spec</a></h2>
<ul>
<li>
<p><code>(constructor)</code></p>
<ul>
<li><code>n</code>要素のUnion Findを構築する.</li>
</ul>
</li>
<li>
<p><code>root</code></p>
<ul>
<li>要素の根を返す.</li>
</ul>
</li>
<li>
<p><code>unite</code></p>
<ul>
<li>2要素を結ぶ.</li>
<li>戻り値は親となった根</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#code-11" id="code-11">Code</a></h2>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;set&gt;
using namespace std;

struct union_find {
  vector&lt;int&gt; par;
  vector&lt;int&gt; rank;
  union_find(int n) : par(n) , rank(n) {
    for(int i = 0;i &lt; n;i++) par[i] = i;
  }
  int root(int i) {
    return par[i] == i ? i : par[i] = root(par[i]);
  }
  /* unite x, y return parent */
  int unite(int x,int y) {
    x = root(x);
    y = root(y);
    if(x == y) return -1;
    if(rank[x] &lt; rank[y]) {
      par[x] = y;
      return y;
    }
    else {
      par[y] = x;
      if(rank[x] == rank[y]) rank[x]++;
      return x;
    }
  }
};
</code></pre>
<h1><a class="header" href="#partially-persistent-union-find" id="partially-persistent-union-find">Partially Persistent Union Find</a></h1>
<h2><a class="header" href="#spec-12" id="spec-12">Spec</a></h2>
<ul>
<li>
<p>時刻<code>t</code>は単調増加である必要がある.</p>
</li>
<li>
<p><code>(constructor)</code></p>
<ul>
<li><code>n</code>要素のPartially Persistent Union Findを構築する.</li>
</ul>
</li>
<li>
<p><code>unite(i64 t, i64 x, i64 y)</code></p>
<ul>
<li>2要素を時刻<code>t</code>で結ぶ.</li>
<li>戻り値は親となった根</li>
</ul>
</li>
<li>
<p><code>find(i64 t, i64 x)</code></p>
<ul>
<li>時刻<code>t</code>のときの要素<code>x</code>の根を返す.</li>
</ul>
</li>
<li>
<p><code>size(i64 t, i64 x)</code></p>
<ul>
<li>時刻<code>t</code>のときの要素<code>x</code>の属する集合の大きさを返す.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#code-12" id="code-12">Code</a></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct partially_persistent_union_find {
  vector&lt;i64&gt; data;
  vector&lt;i64&gt; last;
  vector&lt;vector&lt;pair&lt;i64, i64&gt;&gt;&gt; add;

  partially_persistent_union_find(int sz) : data(sz, -1), last(sz, 1e9), add(sz) {
    for(auto &amp; vs: add) vs.push_back({ -1, -1 });
  }

  i64 unite(i64 t, i64 x, i64 y) {
    x = find(t, x);
    y = find(t, y);
    if(x == y) return -1;
    if(data[x] &gt; data[y]) swap(x, y);
    data[x] += data[y];
    add[x].push_back({t, data[x]});
    data[y] = x;
    last[y] = t;
    return x;
  }

  i64 find(i64 t, i64 x) {
    if(t &lt; last[x]) return x;
    return find(t, data[x]);
  }

  i64 size(i64 t, i64 x) {
    x = find(t, x);
    return -prev(lower_bound(begin(add[x]), end(add[x]), make_pair(t, 0ll)))-&gt;second;
  }
};
</code></pre>
<h1><a class="header" href="#self-balancing-binary-search-tree" id="self-balancing-binary-search-tree">self-Balancing Binary Search Tree</a></h1>
<ul>
<li><a href="data_structures/bbst/./splay_tree_array.html">Splay Tree Array</a></li>
<li><a href="data_structures/bbst/./splay_tree_map.html">Splay Tree Map</a></li>
<li><a href="data_structures/bbst/./avl_tree_array.html">AVL Tree Array</a></li>
<li><a href="data_structures/bbst/./persistent_avl_tree_array.html">Persistent AVL Tree Array</a></li>
</ul>
<h1><a class="header" href="#splay-tree-array" id="splay-tree-array">Splay Tree Array</a></h1>
<p>列を管理するSplay Tree</p>
<h3><a class="header" href="#spec-13" id="spec-13">Spec</a></h3>
<ul>
<li>
<p><code>struct node</code></p>
<ul>
<li>Splay Treeに載せるノードの型</li>
</ul>
</li>
<li>
<p><code>fold(node* x)</code></p>
<ul>
<li><code>fold</code>したいやつを変えたときはここを変える</li>
</ul>
</li>
<li>
<p><code>fix(node* n)</code></p>
<ul>
<li><code>fix</code>操作, foldの仕方をここで定義する</li>
</ul>
</li>
<li>
<p><code>reverse(node* n)</code></p>
<ul>
<li>反転操作, foldを反転する必要がある場合はここに.</li>
</ul>
</li>
<li>
<p><code>push(node* x)</code></p>
<ul>
<li>遅延伝搬させているときはここを変更</li>
</ul>
</li>
<li>
<p><code>split(i64 i)</code></p>
<ul>
<li><code>[0, i) / [i, ..)</code>に分ける</li>
</ul>
</li>
<li>
<p><code>merge(splay_array&amp;&amp; arr)</code></p>
<ul>
<li>mergeする</li>
</ul>
</li>
<li>
<p><code>reverse()</code></p>
<ul>
<li>列全体を反転させる</li>
</ul>
</li>
<li>
<p><code>update(i64 i, T t)</code></p>
<ul>
<li><code>i</code>番目の要素を<code>t</code>に変更する.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-13" id="code-13">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct splay_array {
  using T = i64;

  struct node {
    node* ch[2];
    node* par;
    T val;
    i64 sz;
    bool rev;

    /* option */
    T fold;
    
    node(T v): val(v), par(nullptr), sz(1), rev(false), fold(v) { ch[0] = nullptr; ch[1] = nullptr; }
  };

private:

  i64 subsize(node* x) {
    if(x) return x-&gt;sz;
    else return 0;
  }
  T fold(node* x) {
    if(x) return x-&gt;fold;
    else return 0;
  }
  node* fix(node* n) {
    if(!n) return nullptr;
    n-&gt;sz = subsize(n-&gt;ch[0]) + subsize(n-&gt;ch[1]) + 1;
    /* option */
    n-&gt;fold = fold(n-&gt;ch[0]) + n-&gt;val + fold(n-&gt;ch[1]);
    return n;
  }
  void reverse(node* n) {
    if(!n) return;
    n-&gt;rev ^= true;
    /* here reversing operation */
    /* example swap(fold, revfold) */
  }
  void push(node* x) {
    if(!x) return;
    if(x-&gt;rev) {
      swap(x-&gt;ch[0], x-&gt;ch[1]);
      reverse(x-&gt;ch[0]);
      reverse(x-&gt;ch[1]);
    }
  }
  int parent_dir(node* x) {
    node* p = x-&gt;par;
    if(!p) return -1;
    else if(p-&gt;ch[0] == x) return 0;
    else return 1;
  }
  void set(node* par, node* x, i64 dir) {
    if(par) par-&gt;ch[dir] = x;
    if(x) x-&gt;par = par;
    fix(par);
  }
  void rotate(node* x, i64 dir) {
    node* p = x-&gt;par;
    node* q = p-&gt;par;
    set(p, x-&gt;ch[dir], dir ^ 1);
    int p_dir = parent_dir(p);
    if(p_dir &gt;= 0) {
      set(q, x, p_dir);
    }
    else x-&gt;par = nullptr;
    set(x, p, dir);
  }
  node* splay(node * x) {
    if(!x) return nullptr;
    while(x-&gt;par) {
      push(x-&gt;par-&gt;par);
      push(x-&gt;par);
      push(x);
      int dir = parent_dir(x);
      int eir = parent_dir(x-&gt;par);
      if(eir == -1) {
        rotate(x, dir  ^ 1);
      }
      else if(dir == eir){
        rotate(x-&gt;par, eir ^ 1);
        rotate(x, dir ^ 1);
      }
      else {
        rotate(x, dir ^ 1);
        rotate(x, eir ^ 1);
      }
    }
    return x;
  }

  node* find(node* r, i64 i) {
    push(r);
    assert(0 &lt;= i);
    assert(i &lt; subsize(r));
    node* z = r;
    while(z) {
      push(z);
      if(subsize(z-&gt;ch[0]) == i) return splay(z);
      else if(subsize(z-&gt;ch[0]) &lt; i) {
        i -= subsize(z-&gt;ch[0]) + 1;
        z = z-&gt;ch[1];
      }
      else {
        z = z-&gt;ch[0];
      }
    }
    assert(false);
  }

  pair&lt;node*, node*&gt; split(node* r, size_t i) {
    push(r);
    assert(0 &lt;= i);
    assert(i &lt;= subsize(r));
    if(i == 0) return { nullptr, r };
    if(i == subsize(r)) return { r, nullptr };
    r = find(r, i - 1);
    node* y = r-&gt;ch[1];
    if(y) y-&gt;par = nullptr;
    r-&gt;ch[1] = nullptr;
    fix(r);
    push(y);
    return { r, y };
  }

  node* merge(node* r1, node* r2) {
    push(r1);
    push(r2);
    if(!r1) r1 = r2;
    else if(!r2) {}
    else {
      r1 = find(r1, subsize(r1) - 1);
      set(r1, r2, 1);
    }
    return r1;
  }

  node* root;

  splay_array(node* r): root(r) {}

public:

  using sarr = splay_array;

  splay_array(): root(nullptr) {}
  splay_array(T t): root(new node(t)) {}
  splay_array(splay_array&amp;&amp; arr): root(arr.root) { arr.root = nullptr; }
  splay_array&amp; operator=(splay_array&amp;&amp; arr) {
    root = arr.root;
    arr.root = nullptr;
    return *this;
  }
  /* [0 ... i - 1] +/+ [i ...] */
  pair&lt;splay_array, splay_array&gt; split(i64 i) {
    auto p = split(root, i);
    root = nullptr;
    return { splay_array(p.first), splay_array(p.second) };
  }
  /* [this] ++ [arr] */
  void merge(splay_array&amp;&amp; arr) {
    root = merge(root, arr.root);
    arr.root = nullptr;
  }
  /* reverse array */
  void reverse() { if(root) reverse(root); }
  i64 size() { return subsize(root); }

  /* option */
  T fold() { return fold(root); }
  void update(i64 i, T t) {
    root = find(root, i);
    root-&gt;val += t;
    fix(root);
  }
};
</code></pre>
<h1><a class="header" href="#splay-tree-map" id="splay-tree-map">Splay Tree Map</a></h1>
<p>map型のSplay Tree</p>
<h3><a class="header" href="#spec-14" id="spec-14">Spec</a></h3>
<ul>
<li>
<p><code>struct node</code></p>
<ul>
<li>Splay Treeに載せるノードの型</li>
</ul>
</li>
<li>
<p><code>fold(node* x)</code></p>
<ul>
<li><code>fold</code>したいやつを変えたときはここを変える</li>
</ul>
</li>
<li>
<p><code>fix(node* n)</code></p>
<ul>
<li><code>fix</code>操作, foldの仕方をここで定義する</li>
</ul>
</li>
<li>
<p><code>reverse(node* n)</code></p>
<ul>
<li>反転操作, foldを反転する必要がある場合はここに.</li>
</ul>
</li>
<li>
<p><code>push(node* x)</code></p>
<ul>
<li>遅延伝搬させているときはここを変更</li>
</ul>
</li>
<li>
<p><code>insert(Key key, T t)</code></p>
<ul>
<li><code>{key, t}</code>を入れる, すでに存在する場合はupdate</li>
</ul>
</li>
<li>
<p><code>erase(Key key)</code></p>
<ul>
<li>`{key, ..}のノードを削除する</li>
</ul>
</li>
<li>
<p><code>nth_node(i64 n)</code></p>
<ul>
<li><code>n</code>番目の要素の<code>Key</code>を返す</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-14" id="code-14">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct splay_map {
  using T = i64;
  using Key = i64;

  struct node {
    node* ch[2];
    node* par;
    T val;
    Key key;
    i64 sz;
    bool rev;

    /* option */
    //T fold;
    
    node(Key key, T v): key(key), val(v), par(nullptr), sz(1), rev(false)/*, fold(v)*/ { ch[0] = nullptr; ch[1] = nullptr; }
  };

private:

  i64 subsize(node* x) {
    if(x) return x-&gt;sz;
    else return 0;
  }
  /*
  T fold(node* x) {
    if(x) return x-&gt;fold;
    else return 0;
  }
  */
  node* fix(node* n) {
    if(!n) return nullptr;
    n-&gt;sz = subsize(n-&gt;ch[0]) + subsize(n-&gt;ch[1]) + 1;
    /* option */
    //n-&gt;fold = fold(n-&gt;ch[0]) + n-&gt;val + fold(n-&gt;ch[1]);
    return n;
  }
  void reverse(node* n) {
    if(!n) return;
    n-&gt;rev ^= true;
    /* here reversing operation */
    /* example swap(fold, revfold) */
  }
  void push(node* x) {
    if(!x) return;
    if(x-&gt;rev) {
      swap(x-&gt;ch[0], x-&gt;ch[1]);
      reverse(x-&gt;ch[0]);
      reverse(x-&gt;ch[1]);
    }
  }
  int parent_dir(node* x) {
    node* p = x-&gt;par;
    if(!p) return -1;
    else if(p-&gt;ch[0] == x) return 0;
    else return 1;
  }
  void set(node* par, node* x, i64 dir) {
    if(par) par-&gt;ch[dir] = x;
    if(x) x-&gt;par = par;
    fix(par);
  }
  void rotate(node* x, i64 dir) {
    node* p = x-&gt;par;
    node* q = p-&gt;par;
    set(p, x-&gt;ch[dir], dir ^ 1);
    int p_dir = parent_dir(p);
    if(p_dir &gt;= 0) {
      set(q, x, p_dir);
    }
    else x-&gt;par = nullptr;
    set(x, p, dir);
  }
  node* splay(node * x) {
    if(!x) return nullptr;
    while(x-&gt;par) {
      push(x-&gt;par-&gt;par);
      push(x-&gt;par);
      push(x);
      int dir = parent_dir(x);
      int eir = parent_dir(x-&gt;par);
      if(eir == -1) {
        rotate(x, dir  ^ 1);
      }
      else if(dir == eir){
        rotate(x-&gt;par, eir ^ 1);
        rotate(x, dir ^ 1);
      }
      else {
        rotate(x, dir ^ 1);
        rotate(x, eir ^ 1);
      }
    }
    return x;
  }

  node* root;

public:

  splay_map(): root(nullptr) {}

  node* lower_bound(Key key) {
    node* z = root;
    node* x = nullptr;
    while(z) {
      if(key &lt;= z-&gt;key) {
        x = z;
        z = z-&gt;ch[0];
      }
      else {
        z = z-&gt;ch[1];
      }
    }
    return x;
  }

  void insert(Key key, T t) {
    node* z = new node(key, t);
    node* x = lower_bound(key);
    if(!x) {
      set(z, root, 0);
      root = z;
    }
    else {
      root = splay(x);
      node* q = root-&gt;ch[0];
      set(z, q, 0);
      set(root, z, 0);
    }
  }

  void erase(Key key) {
    node* x = lower_bound(key);
    if(x-&gt;key == key) {
      root = splay(x);
      node* p = root-&gt;ch[0];
      node* q = root-&gt;ch[1];
      root-&gt;ch[0] = nullptr;
      root-&gt;ch[1] = nullptr;
      if(p) p-&gt;par = nullptr;
      if(q) q-&gt;par = nullptr;
      if(!p) {
        root = q;
      }
      else {
        while(p-&gt;ch[1]) p = p-&gt;ch[1];
        root = splay(p);
        set(root, q, 1);
      }
    }
  }

  i64 size() {
    return subsize(root);
  }
  Key nth_node(i64 n) {
    node* z = root;
    while(z) {
      if(subsize(z-&gt;ch[0]) == n) {
        return z-&gt;key;
      }
      if(subsize(z-&gt;ch[0]) &lt; n) {
        n -= subsize(z-&gt;ch[0]) + 1;
        z = z-&gt;ch[1];
      }
      else {
        z = z-&gt;ch[0];
      }
    }
    assert(false);
  }
  

  /* option */
  //T fold() { return fold(root); }
};
</code></pre>
<h1><a class="header" href="#avl-tree-array" id="avl-tree-array">AVL Tree Array</a></h1>
<p>列を管理するAVL Tree</p>
<h3><a class="header" href="#spec-15" id="spec-15">Spec</a></h3>
<ul>
<li>
<p><code>struct node</code></p>
<ul>
<li>AVL Treeに載せるノードの型</li>
<li><code>fix</code>に操作を書く</li>
</ul>
</li>
<li>
<p><code>split(size_type i)</code></p>
<ul>
<li><code>[0, i) / [i, ..)</code>に分けた木を返す</li>
</ul>
</li>
<li>
<p><code>merge(persistent_avl_array&amp;&amp; arr)</code></p>
<ul>
<li>mergeした木を返す.</li>
</ul>
</li>
<li>
<p><code>at(size_type i)</code></p>
<ul>
<li><code>i</code>番目の要素にアクセスする.</li>
</ul>
</li>
<li>
<p><code>set(size_type i, value_type val)</code></p>
<ul>
<li><code>i</code>番目の要素を<code>val</code>にする</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-15" id="code-15">Code</a></h3>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;array&gt;

template&lt;class T&gt;
class avl_tree_array {
  public:
    using value_type = T;
    using size_type = std::size_t;
    using height_type = long long int;
  protected:
    class node;
    using node_type = std::unique_ptr&lt;class node&gt;;

    static size_type size(const node_type&amp; node) {
      if(!node) return 0;
      else return node-&gt;size();
    }
    static height_type height(const node_type&amp; node) {
      if(!node) return 0;
      else return node-&gt;height();
    }

    class node {
      private:
        value_type val;
        size_type sz;
        height_type hei;
        std::array&lt;node_type, 2&gt; chi;
      public:

        node(value_type val): val(std::move(val)), sz(1), hei(1), chi() { fix(); }
        void fix() {
          sz = avl_tree_array::size(chi[0]) + avl_tree_array::size(chi[1]) + 1;
          hei = std::max(avl_tree_array::height(chi[0]), avl_tree_array::height(chi[1])) + 1;
        }
        void push() {}
        node_type cut(size_type dir) {
          push();
          node_type nn = std::move(chi[dir]);
          this-&gt;fix();
          return std::move(nn);
        }
        void set(node_type dir_node, size_type dir) {
          push();
          chi[dir] = std::move(dir_node);
          this-&gt;fix();
        }
        size_type size() { push(); return sz; }
        height_type height() { push(); return hei; }
        height_type diff() { push(); return avl_tree_array::height(chi[0]) - avl_tree_array::height(chi[1]); }
        value_type&amp; value() { push(); return val; }
        node_type&amp; child(size_type dir) { return chi[dir]; }
    };


    static node_type rotate(node_type x, size_type dir) {
      node_type y = x-&gt;cut(1 - dir);
      node_type b = y-&gt;cut(dir);
      x-&gt;set(std::move(b), 1 - dir);
      y-&gt;set(std::move(x), dir);
      return std::move(y);
    }

    static node_type balance(node_type node) {
      if(node-&gt;diff() == 2) {
        if(node-&gt;child(0)-&gt;diff() == -1) {
          auto ch = node-&gt;cut(0);
          node-&gt;set(rotate(std::move(ch), 0), 0);
        }
        return rotate(std::move(node), 1);
      }
      else if(node-&gt;diff() == -2) {
        if(node-&gt;child(1)-&gt;diff() == 1) {
          auto ch = node-&gt;cut(1);
          node-&gt;set(rotate(std::move(ch), 1), 1);
        }
        return rotate(std::move(node), 0);
      }
      else return std::move(node);
    }

    static std::pair&lt;node_type, node_type&gt; deepest_node(node_type node, size_type dir) {
      auto ch = node-&gt;cut(dir);
      if(ch) {
        auto pp = deepest_node(std::move(ch), dir);
        node_type deepest_node, dirn;
        deepest_node = std::move(pp.first);
        dirn = std::move(pp.second);
        node-&gt;set(std::move(dirn), dir);
        pp.first = std::move(deepest_node);
        pp.second = balance(std::move(node));
        return std::move(pp);
      }
      else {
        auto rn = node-&gt;cut(1 - dir);
        std::pair&lt;node_type, node_type&gt; pp;
        pp.first = std::move(node);
        pp.second = std::move(rn);
        return pp;
      }
    }

    static node_type merge_dir(node_type dst, node_type root, node_type src, size_type dir) {
      if(std::abs(height(dst) - height(src)) &lt;= 1) {
        root-&gt;set(std::move(src), dir);
        root-&gt;set(std::move(dst), 1 - dir);
        return std::move(root);
      }
      else {
        node_type ch = dst-&gt;cut(dir);
        if(ch) {
          ch = merge_dir(std::move(ch), std::move(root), std::move(src), dir);
          dst-&gt;set(std::move(ch), dir);
          return balance(std::move(dst));
        }
        else {
          root-&gt;set(std::move(src), dir);
          root = balance(std::move(root));
          dst-&gt;set(std::move(root), dir);
          return balance(std::move(dst));
        }
      }
    }

    static node_type merge(node_type left, node_type right) {
      if(!left) { return std::move(right); }
      else if(!right) { return std::move(left); }
      else if(height(left) &gt;= height(right)) {
        node_type deep_left, src;
        std::tie(deep_left, src) = deepest_node(std::move(right), 0);
        return merge_dir(std::move(left), std::move(deep_left), std::move(src), 1);
      }
      else {
        node_type deep_right, src;
        std::tie(deep_right, src) = deepest_node(std::move(left), 1);
        return merge_dir(std::move(right), std::move(deep_right), std::move(src), 0);
      }
    }

    static std::pair&lt;node_type, node_type&gt; split(node_type node, size_type i) {
      if(i == node-&gt;size()) { return std::pair&lt;node_type, node_type&gt;(std::move(node), node_type()); }
      auto left = node-&gt;cut(0);
      auto right = node-&gt;cut(1);
      if(i &lt; size(left)) {
        node_type sp_left, sp_right;
        std::tie(sp_left, sp_right) = split(std::move(left), i);
        node_type nright;
        if(right) {
          nright = merge_dir(std::move(right), std::move(node), std::move(sp_right), 0);
        }
        else {
          nright = merge(std::move(sp_right), std::move(node));
        }
        return std::pair&lt;node_type, node_type&gt;(std::move(sp_left), std::move(nright));
      }
      else if(i == size(left)) {
        return std::pair&lt;node_type, node_type&gt;(std::move(left), merge(std::move(node), std::move(right)));
      }
      else {
        node_type sp_left, sp_right;
        std::tie(sp_left, sp_right) = split(std::move(right), i - size(left) - 1);
        node_type nleft;
        if(left) {
          nleft = merge_dir(std::move(left), std::move(node), std::move(sp_left), 1);
        }
        else {
          nleft = merge(std::move(node), std::move(sp_left));
        }
        return std::pair&lt;node_type, node_type&gt;(std::move(nleft), std::move(sp_right));
      }
    }

    static node_type&amp; at(node_type&amp; node, size_type i) {
      if(size(node-&gt;child(0)) == i) return node;
      else if(size(node-&gt;child(0)) &lt; i) return at(node-&gt;child(1), i - size(node-&gt;child(0)) - 1);
      else return at(node-&gt;child(0), i);
    }

    static void set(node_type&amp; node, size_type i, value_type val) {
      if(size(node-&gt;child(0)) == i) {
        node-&gt;value() = std::move(val);
        node-&gt;fix();
      }
      else if(size(node-&gt;child(0)) &lt; i) {
        set(node-&gt;child(1), i - size(node-&gt;child(0)) - 1, std::move(val));
        node-&gt;fix();
      }
      else {
        set(node-&gt;child(0), i, std::move(val));
        node-&gt;fix();
      }
    }

    node_type root;
    avl_tree_array(node_type&amp;&amp; root): root(std::move(root)) {}
  public:
    avl_tree_array(): root() {}
    avl_tree_array(T val): root(node_type(new class node(std::move(val)))) {}
    avl_tree_array(avl_tree_array&amp;&amp; tree): root(std::move(tree.root)) {}
    avl_tree_array&amp; operator=(avl_tree_array&amp;&amp; tree) {
      root = std::move(tree.root);
      return *this;
    }
    template&lt;class A&gt;
      friend avl_tree_array&lt;A&gt; merge(avl_tree_array&lt;A&gt;&amp;&amp; t1, avl_tree_array&lt;A&gt;&amp;&amp; t2);
    template&lt;class A&gt;
      friend std::pair&lt;avl_tree_array&lt;A&gt;, avl_tree_array&lt;A&gt;&gt; split(avl_tree_array&lt;A&gt;&amp;&amp; t, std::size_t i);

    value_type&amp; at(size_type i) {
      return at(root, i)-&gt;value();
    }

    void set(size_type i, value_type val) {
      set(root, i, std::move(val));
    }

    size_type size() {
      if(!root) return 0;
      return root-&gt;size();
    }
};

template&lt;class T&gt;
avl_tree_array&lt;T&gt; merge(avl_tree_array&lt;T&gt;&amp;&amp; t1, avl_tree_array&lt;T&gt;&amp;&amp; t2) {
  return avl_tree_array&lt;T&gt;(avl_tree_array&lt;T&gt;::merge(std::move(t1.root), std::move(t2.root)));
}

template&lt;class T&gt;
std::pair&lt;avl_tree_array&lt;T&gt;, avl_tree_array&lt;T&gt;&gt; split(avl_tree_array&lt;T&gt;&amp;&amp; t, std::size_t i) {
  auto rp = avl_tree_array&lt;T&gt;::split(std::move(t.root), i);
  return std::make_pair(avl_tree_array&lt;T&gt;(std::move(rp.first)), avl_tree_array&lt;T&gt;(std::move(rp.second)));
}
</code></pre>
<h1><a class="header" href="#avl-tree-map" id="avl-tree-map">AVL Tree Map</a></h1>
<p>AVL TreeのMapバージョン</p>
<h3><a class="header" href="#spec-16" id="spec-16">Spec</a></h3>
<ul>
<li>
<p><code>struct node</code></p>
<ul>
<li>AVL Treeに載せるノードの型</li>
<li><code>fix</code>に操作を書く.</li>
</ul>
</li>
<li>
<p><code>at(key_value i)</code></p>
<ul>
<li><code>i</code>の要素にアクセスする.</li>
</ul>
</li>
<li>
<p><code>insert(key_value key, value_type val)</code></p>
<ul>
<li><code>key</code>の要素を<code>val</code>にする</li>
</ul>
</li>
<li>
<p><code>erase(key_value key)</code></p>
<ul>
<li><code>key</code>の要素を消す</li>
</ul>
</li>
<li>
<p><code>lower_bound(key_value key)</code></p>
<ul>
<li><code>lower_bound</code>をしたときの要素を返す.</li>
<li><code>.first</code>が<code>false</code>であるときは<code>lower_bound</code>はない.</li>
</ul>
</li>
<li>
<p><code>nth_node(size_type i)</code></p>
<ul>
<li><code>i</code>番目の要素を返す.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-16" id="code-16">Code</a></h3>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;array&gt;

template&lt;class T&gt;
class avl_tree_array {
  public:
    using value_type = T;
    using size_type = std::size_t;
    using height_type = long long int;
  protected:
    class node;
    using node_type = std::unique_ptr&lt;class node&gt;;

    static size_type size(const node_type&amp; node) {
      if(!node) return 0;
      else return node-&gt;size();
    }
    static height_type height(const node_type&amp; node) {
      if(!node) return 0;
      else return node-&gt;height();
    }

    class node {
      private:
        value_type val;
        size_type sz;
        height_type hei;
        std::array&lt;node_type, 2&gt; chi;
      public:

        node(value_type val): val(std::move(val)), sz(1), hei(1), chi() { fix(); }
        void fix() {
          sz = avl_tree_array::size(chi[0]) + avl_tree_array::size(chi[1]) + 1;
          hei = std::max(avl_tree_array::height(chi[0]), avl_tree_array::height(chi[1])) + 1;
        }
        void push() {}
        node_type cut(size_type dir) {
          push();
          node_type nn = std::move(chi[dir]);
          this-&gt;fix();
          return std::move(nn);
        }
        void set(node_type dir_node, size_type dir) {
          push();
          chi[dir] = std::move(dir_node);
          this-&gt;fix();
        }
        size_type size() { push(); return sz; }
        height_type height() { push(); return hei; }
        height_type diff() { push(); return avl_tree_array::height(chi[0]) - avl_tree_array::height(chi[1]); }
        value_type&amp; value() { push(); return val; }
        node_type&amp; child(size_type dir) { return chi[dir]; }
    };


    static node_type rotate(node_type x, size_type dir) {
      node_type y = x-&gt;cut(1 - dir);
      node_type b = y-&gt;cut(dir);
      x-&gt;set(std::move(b), 1 - dir);
      y-&gt;set(std::move(x), dir);
      return std::move(y);
    }

    static node_type balance(node_type node) {
      if(node-&gt;diff() == 2) {
        if(node-&gt;child(0)-&gt;diff() == -1) {
          auto ch = node-&gt;cut(0);
          node-&gt;set(rotate(std::move(ch), 0), 0);
        }
        return rotate(std::move(node), 1);
      }
      else if(node-&gt;diff() == -2) {
        if(node-&gt;child(1)-&gt;diff() == 1) {
          auto ch = node-&gt;cut(1);
          node-&gt;set(rotate(std::move(ch), 1), 1);
        }
        return rotate(std::move(node), 0);
      }
      else return std::move(node);
    }

    static std::pair&lt;node_type, node_type&gt; deepest_node(node_type node, size_type dir) {
      auto ch = node-&gt;cut(dir);
      if(ch) {
        auto pp = deepest_node(std::move(ch), dir);
        node_type deepest_node, dirn;
        deepest_node = std::move(pp.first);
        dirn = std::move(pp.second);
        node-&gt;set(std::move(dirn), dir);
        pp.first = std::move(deepest_node);
        pp.second = balance(std::move(node));
        return std::move(pp);
      }
      else {
        auto rn = node-&gt;cut(1 - dir);
        std::pair&lt;node_type, node_type&gt; pp;
        pp.first = std::move(node);
        pp.second = std::move(rn);
        return pp;
      }
    }

    static node_type merge_dir(node_type dst, node_type root, node_type src, size_type dir) {
      if(std::abs(height(dst) - height(src)) &lt;= 1) {
        root-&gt;set(std::move(src), dir);
        root-&gt;set(std::move(dst), 1 - dir);
        return std::move(root);
      }
      else {
        node_type ch = dst-&gt;cut(dir);
        if(ch) {
          ch = merge_dir(std::move(ch), std::move(root), std::move(src), dir);
          dst-&gt;set(std::move(ch), dir);
          return balance(std::move(dst));
        }
        else {
          root-&gt;set(std::move(src), dir);
          root = balance(std::move(root));
          dst-&gt;set(std::move(root), dir);
          return balance(std::move(dst));
        }
      }
    }

    static node_type merge(node_type left, node_type right) {
      if(!left) { return std::move(right); }
      else if(!right) { return std::move(left); }
      else if(height(left) &gt;= height(right)) {
        node_type deep_left, src;
        std::tie(deep_left, src) = deepest_node(std::move(right), 0);
        return merge_dir(std::move(left), std::move(deep_left), std::move(src), 1);
      }
      else {
        node_type deep_right, src;
        std::tie(deep_right, src) = deepest_node(std::move(left), 1);
        return merge_dir(std::move(right), std::move(deep_right), std::move(src), 0);
      }
    }

    static std::pair&lt;node_type, node_type&gt; split(node_type node, size_type i) {
      if(i == node-&gt;size()) { return std::pair&lt;node_type, node_type&gt;(std::move(node), node_type()); }
      auto left = node-&gt;cut(0);
      auto right = node-&gt;cut(1);
      if(i &lt; size(left)) {
        node_type sp_left, sp_right;
        std::tie(sp_left, sp_right) = split(std::move(left), i);
        node_type nright;
        if(right) {
          nright = merge_dir(std::move(right), std::move(node), std::move(sp_right), 0);
        }
        else {
          nright = merge(std::move(sp_right), std::move(node));
        }
        return std::pair&lt;node_type, node_type&gt;(std::move(sp_left), std::move(nright));
      }
      else if(i == size(left)) {
        return std::pair&lt;node_type, node_type&gt;(std::move(left), merge(std::move(node), std::move(right)));
      }
      else {
        node_type sp_left, sp_right;
        std::tie(sp_left, sp_right) = split(std::move(right), i - size(left) - 1);
        node_type nleft;
        if(left) {
          nleft = merge_dir(std::move(left), std::move(node), std::move(sp_left), 1);
        }
        else {
          nleft = merge(std::move(node), std::move(sp_left));
        }
        return std::pair&lt;node_type, node_type&gt;(std::move(nleft), std::move(sp_right));
      }
    }

    static node_type&amp; at(node_type&amp; node, size_type i) {
      if(size(node-&gt;child(0)) == i) return node;
      else if(size(node-&gt;child(0)) &lt; i) return at(node-&gt;child(1), i - size(node-&gt;child(0)) - 1);
      else return at(node-&gt;child(0), i);
    }

    static void set(node_type&amp; node, size_type i, value_type val) {
      if(size(node-&gt;child(0)) == i) {
        node-&gt;value() = std::move(val);
        node-&gt;fix();
      }
      else if(size(node-&gt;child(0)) &lt; i) {
        set(node-&gt;child(1), i - size(node-&gt;child(0)) - 1, std::move(val));
        node-&gt;fix();
      }
      else {
        set(node-&gt;child(0), i, std::move(val));
        node-&gt;fix();
      }
    }

    node_type root;
    avl_tree_array(node_type&amp;&amp; root): root(std::move(root)) {}
  public:
    avl_tree_array(): root() {}
    avl_tree_array(T val): root(node_type(new class node(std::move(val)))) {}
    avl_tree_array(avl_tree_array&amp;&amp; tree): root(std::move(tree.root)) {}
    avl_tree_array&amp; operator=(avl_tree_array&amp;&amp; tree) {
      root = std::move(tree.root);
      return *this;
    }
    template&lt;class A&gt;
      friend avl_tree_array&lt;A&gt; merge(avl_tree_array&lt;A&gt;&amp;&amp; t1, avl_tree_array&lt;A&gt;&amp;&amp; t2);
    template&lt;class A&gt;
      friend std::pair&lt;avl_tree_array&lt;A&gt;, avl_tree_array&lt;A&gt;&gt; split(avl_tree_array&lt;A&gt;&amp;&amp; t, std::size_t i);

    value_type&amp; at(size_type i) {
      return at(root, i)-&gt;value();
    }

    void set(size_type i, value_type val) {
      set(root, i, std::move(val));
    }

    size_type size() {
      if(!root) return 0;
      return root-&gt;size();
    }
};

template&lt;class T&gt;
avl_tree_array&lt;T&gt; merge(avl_tree_array&lt;T&gt;&amp;&amp; t1, avl_tree_array&lt;T&gt;&amp;&amp; t2) {
  return avl_tree_array&lt;T&gt;(avl_tree_array&lt;T&gt;::merge(std::move(t1.root), std::move(t2.root)));
}

template&lt;class T&gt;
std::pair&lt;avl_tree_array&lt;T&gt;, avl_tree_array&lt;T&gt;&gt; split(avl_tree_array&lt;T&gt;&amp;&amp; t, std::size_t i) {
  auto rp = avl_tree_array&lt;T&gt;::split(std::move(t.root), i);
  return std::make_pair(avl_tree_array&lt;T&gt;(std::move(rp.first)), avl_tree_array&lt;T&gt;(std::move(rp.second)));
}
</code></pre>
<h1><a class="header" href="#avl-tree-map-foldable" id="avl-tree-map-foldable">AVL Tree Map Foldable</a></h1>
<p>AVL TreeのMapバージョンでモノイドを処理できるようにした.</p>
<h3><a class="header" href="#spec-17" id="spec-17">Spec</a></h3>
<ul>
<li>
<p><code>operation()</code></p>
<ul>
<li>モノイドの演算を決める</li>
</ul>
</li>
<li>
<p><code>identity()</code></p>
<ul>
<li>モノイドの単位元を決める</li>
</ul>
</li>
<li>
<p><code>struct node</code></p>
<ul>
<li>AVL Treeに載せるノードの型</li>
<li><code>fix</code>に操作を書く.</li>
</ul>
</li>
<li>
<p><code>at(key_value i)</code></p>
<ul>
<li><code>i</code>の要素にアクセスする.</li>
</ul>
</li>
<li>
<p><code>insert(key_value key, value_type val)</code></p>
<ul>
<li><code>key</code>の要素を<code>val</code>にする</li>
</ul>
</li>
<li>
<p><code>erase(key_value key)</code></p>
<ul>
<li><code>key</code>の要素を消す</li>
</ul>
</li>
<li>
<p><code>lower_bound(key_value key)</code></p>
<ul>
<li><code>lower_bound</code>をしたときの要素を返す.</li>
<li><code>.first</code>が<code>false</code>であるときは<code>lower_bound</code>はない.</li>
</ul>
</li>
<li>
<p><code>nth_node(size_type i)</code></p>
<ul>
<li><code>i</code>番目の要素を返す.</li>
</ul>
</li>
<li>
<p><code>fold(key_value left, key_value right)</code></p>
<ul>
<li><code>[left, right)</code>に対してfoldをする.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-17" id="code-17">Code</a></h3>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;

template&lt;class Key, class Monoid&gt;
class avl_tree_map {
  public:
    using key_type = Key;
    using value_type = Monoid;
    using size_type = std::size_t;
    using height_type = long long int;
  protected:
    class node;
    using node_type = std::unique_ptr&lt;class node&gt;;

    static size_type size(const node_type&amp; node) {
      if(!node) return 0;
      else return node-&gt;size();
    }
    static height_type height(const node_type&amp; node) {
      if(!node) return 0;
      else return node-&gt;height();
    }

    static value_type identity() {
      return 0;
    }

    static value_type operation(const value_type&amp; a, const value_type&amp; b) {
      return a + b;
    }

    class node {
      private:
        key_type ky;
        value_type val;
        size_type sz;
        height_type hei;
        std::array&lt;node_type, 2&gt; chi;
      public:

        value_type fold;

        node(key_type key, value_type val): ky(std::move(key)), val(std::move(val)), fold(identity()), sz(1), hei(1), chi() { fix(); }
        void fix() {
          fold = val;
          if(chi[0]) fold = operation(chi[0]-&gt;fold, fold);
          if(chi[1]) fold = operation(fold, chi[1]-&gt;fold);
          sz = avl_tree_map::size(chi[0]) + avl_tree_map::size(chi[1]) + 1;
          hei = std::max(avl_tree_map::height(chi[0]), avl_tree_map::height(chi[1])) + 1;
        }
        void push() {}
        node_type cut(size_type dir) {
          push();
          node_type nn = std::move(chi[dir]);
          this-&gt;fix();
          return std::move(nn);
        }
        void set(node_type dir_node, size_type dir) {
          push();
          chi[dir] = std::move(dir_node);
          this-&gt;fix();
        }
        size_type size() { push(); return sz; }
        height_type height() { push(); return hei; }
        height_type diff() { push(); return avl_tree_map::height(chi[0]) - avl_tree_map::height(chi[1]); }
        value_type&amp; value() { push(); return val; }
        const key_type&amp; key() { push(); return ky; }
        node_type&amp; child(size_type dir) { return chi[dir]; }
    };


    static node_type rotate(node_type x, size_type dir) {
      node_type y = x-&gt;cut(1 - dir);
      node_type b = y-&gt;cut(dir);
      x-&gt;set(std::move(b), 1 - dir);
      y-&gt;set(std::move(x), dir);
      return std::move(y);
    }

    static node_type balance(node_type node) {
      if(node-&gt;diff() == 2) {
        if(node-&gt;child(0)-&gt;diff() == -1) {
          auto ch = node-&gt;cut(0);
          node-&gt;set(rotate(std::move(ch), 0), 0);
        }
        return rotate(std::move(node), 1);
      }
      else if(node-&gt;diff() == -2) {
        if(node-&gt;child(1)-&gt;diff() == 1) {
          auto ch = node-&gt;cut(1);
          node-&gt;set(rotate(std::move(ch), 1), 1);
        }
        return rotate(std::move(node), 0);
      }
      else return std::move(node);
    }

    static node_type insert(node_type node, key_type key, value_type val) {
      if(!node) {
        return node_type(new class node(std::move(key), std::move(val)));
      }
      else if(node-&gt;key() == key) {
        node-&gt;value() = val;
        node-&gt;fix();
        return std::move(node);
      }
      else if(node-&gt;key() &lt; key) {
        auto right = node-&gt;cut(1);
        node-&gt;set(insert(std::move(right), std::move(key), std::move(val)), 1);
        return balance(std::move(node));
      }
      else {
        auto left = node-&gt;cut(0);
        node-&gt;set(insert(std::move(left), std::move(key), std::move(val)), 0);
        return balance(std::move(node));
      }
    }

    static std::pair&lt;node_type, node_type&gt; deepest_node(node_type node, size_type dir) {
      auto ch = node-&gt;cut(dir);
      if(ch) {
        auto pp = deepest_node(std::move(ch), dir);
        node_type deepest_node, dirn;
        deepest_node = std::move(pp.first);
        dirn = std::move(pp.second);
        node-&gt;set(std::move(dirn), dir);
        pp.first = std::move(deepest_node);
        pp.second = balance(std::move(node));
        return std::move(pp);
      }
      else {
        auto rn = node-&gt;cut(1 - dir);
        std::pair&lt;node_type, node_type&gt; pp;
        pp.first = std::move(node);
        pp.second = std::move(rn);
        return pp;
      }
    }

    static node_type erase(node_type node, key_type key) {
      if(!node) { return std::move(node); }
      else if(node-&gt;key() == key) {
        node_type&amp; left = node-&gt;child(0);
        node_type&amp; right = node-&gt;child(1);
        if(!left) {
          return node-&gt;cut(1);
        }
        else {
          node_type deepest, ln;
          std::tie(deepest, ln) = deepest_node(std::move(left), 1);
          deepest-&gt;set(std::move(ln), 0);
          deepest-&gt;set(std::move(right), 1);
          return balance(std::move(deepest));
        }
      }
      else if(node-&gt;key() &lt; key) {
        auto right = node-&gt;cut(1);
        node-&gt;set(erase(std::move(right), std::move(key)), 1);
        return balance(std::move(node));
      }
      else {
        auto left = node-&gt;cut(0);
        node-&gt;set(erase(std::move(left), std::move(key)), 0);
        return balance(std::move(node));
      }
    }

    static node_type&amp; at(node_type&amp; node, key_type key) {
      if(!node) assert(false);
      else if(node-&gt;key() == key) return node;
      else if(node-&gt;key() &lt; key) return at(node-&gt;child(1), std::move(key));
      else return at(node-&gt;child(0), std::move(key));
    }

    static node_type&amp; lower_bound(node_type&amp; node, key_type key) {
      if(!node) return node;
      else if(key &lt; node-&gt;key()) {
        auto&amp; ans = lower_bound(node-&gt;child(0), std::move(key));
        if(ans) return ans;
        else return node;
      }
      else {
        return lower_bound(node-&gt;child(1), std::move(key));
      }
    }

    static node_type&amp; nth_node(node_type&amp; node, size_type i) {
      if(size(node-&gt;child(0)) == i) return node;
      else if(size(node-&gt;child(0)) &lt; i) return nth_node(node-&gt;child(1), i - size(node-&gt;child(0)) - 1);
      else return nth_node(node-&gt;child(0), i);
    }

    static value_type left_fold(node_type&amp; node, key_type left) {
      if(!node) { return identity(); }
      if(node-&gt;key() &lt; left) { return left_fold(node-&gt;child(1), std::move(left)); }
      else { 
        value_type R = identity();
        if(node-&gt;child(1)) R = node-&gt;child(1)-&gt;fold;
        return operation(left_fold(node-&gt;child(0), std::move(left)), operation(node-&gt;value(), R));
      }
    }

    static value_type right_fold(node_type&amp; node, key_type right) {
      if(!node) { return identity(); }
      if(!(node-&gt;key() &lt; right)) { return right_fold(node-&gt;child(0), std::move(right)); }
      else {
        value_type L = identity();
        if(node-&gt;child(0)) L = node-&gt;child(0)-&gt;fold;
        return operation(L, operation(node-&gt;value(), right_fold(node-&gt;child(1), std::move(right))));
      }
    }

    static value_type go_fold(node_type&amp; node, key_type left, key_type right) {
      if(!node) return identity();
      if(left &lt;= node-&gt;key() &amp;&amp; node-&gt;key() &lt; right) {
        return operation(left_fold(node-&gt;child(0), std::move(left)), operation(node-&gt;value(), right_fold(node-&gt;child(1), std::move(right))));
      }
      else if(node-&gt;key() &lt; left) {
        return go_fold(node-&gt;child(1), std::move(left), std::move(right));
      }
      else {
        return go_fold(node-&gt;child(0), std::move(left), std::move(right));
      }
    }

    node_type root;
    avl_tree_map(node_type&amp;&amp; root): root(std::move(root)) {}
  public:
    avl_tree_map(): root() {}
    avl_tree_map(avl_tree_map&amp;&amp; tree): root(std::move(tree.root)) {}
    avl_tree_map&amp; operator=(avl_tree_map&amp;&amp; tree) {
      root = std::move(tree.root);
      return *this;
    }

    value_type&amp; at(key_type key) {
      return at(root, std::move(key))-&gt;value();
    }

    void insert(key_type key, value_type val) {
      root = insert(std::move(root), std::move(key), std::move(val));
    }

    void erase(key_type key) {
      root = erase(std::move(root), std::move(key));
    }

    std::pair&lt;bool, std::pair&lt;key_type, value_type&gt;&gt; lower_bound(key_type key) {
      auto&amp; node = lower_bound(root, std::move(key));
      if(node) {
        return { true, { node-&gt;key(), node-&gt;value() } };
      }
      else {
        return { false, { key_type(), value_type() } };
      }
    }

    std::pair&lt;key_type, value_type&gt; nth_node(size_type i) {
      auto node = nth_node(root, i);
      return { node-&gt;key(), node-&gt;value() };
    }

    size_type size() {
      if(!root) return 0;
      return root-&gt;size();
    }

    value_type fold(key_type left, key_type right) {
      return go_fold(root, left, right);
    }
};
</code></pre>
<h1><a class="header" href="#persistent-avl-tree-array" id="persistent-avl-tree-array">Persistent AVL Tree Array</a></h1>
<p>列を永続的に管理するAVL Tree</p>
<h3><a class="header" href="#spec-18" id="spec-18">Spec</a></h3>
<ul>
<li>
<p><code>struct node</code></p>
<ul>
<li>
<p>Persistent AVL Treeに載せるノードの型</p>
</li>
<li>
<p><code>node(value_ref rootval, node_ref a, node_ref b)</code></p>
<ul>
<li>永続化ではノードを作るときだけ<code>fix</code>する</li>
<li>ここにfix操作を書く.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>split(size_type i)</code></p>
<ul>
<li><code>[0, i) / [i, ..)</code>に分けた木を返す</li>
</ul>
</li>
<li>
<p><code>merge(persistent_avl_array&amp;&amp; arr)</code></p>
<ul>
<li>mergeした木を返す.</li>
</ul>
</li>
<li>
<p><code>at(size_type i)</code></p>
<ul>
<li><code>i</code>番目の要素にアクセスする.</li>
</ul>
</li>
<li>
<p><code>push_back(val)</code></p>
<ul>
<li>列の一番うしろに要素を追加する.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-18" id="code-18">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#include &lt;cassert&gt;
using i64 = long long;

class persistent_avl_array {
  using T = char;

  struct node;

  using node_type = typename std::shared_ptr&lt;const node&gt;;
  using node_ref = const node_type&amp;;
  using value_type = T;
  using value_ref = const value_type&amp;;
  using size_type = i64;
  using split_node_type = std::pair&lt;node_type, node_type&gt;;

  static size_type size(node_ref n) {
    if(n) return n-&gt;sz;
    else return 0;
  }

  static size_type height(node_ref n) {
    if(n) return n-&gt;he;
    else return 0;
  }

  struct node {
    
    using node_type = std::shared_ptr&lt;const node&gt;;
    using node_ref = const node_type&amp;;
    using value_type = T;
    using value_ref = const value_type&amp;;
    using size_type = i64;

    value_type val;
    node_type ch[2];
    size_type sz;
    size_type he;

    node(value_ref val, node_ref left, node_ref right)
      : val(val) {
        sz = 1 + size(left) + size(right);
        he = 1 + std::max(height(left), height(right));
        assert(std::abs(height(left)-height(right))&lt;=1);
        ch[0] = left;
        ch[1] = right;
      }
  };

  static node_type balance(value_ref rootval, node_ref a, node_ref b) {
    if(height(a) - height(b) == 2) {
      if(height(a-&gt;ch[0]) - height(a-&gt;ch[1]) == -1)
        return std::make_shared&lt;const node&gt;(
            a-&gt;ch[1]-&gt;val,
            std::make_shared&lt;const node&gt; (a-&gt;val, a-&gt;ch[0], a-&gt;ch[1]-&gt;ch[0]),
            std::make_shared&lt;const node&gt; (rootval, a-&gt;ch[1]-&gt;ch[1], b)
            );
      else
        return std::make_shared&lt;const node&gt;(
            a-&gt;val, 
            a-&gt;ch[0],
            std::make_shared&lt;const node&gt; (rootval, a-&gt;ch[1], b)
            );
    }
    else if(height(a) - height(b) == -2) {
      if(height(b-&gt;ch[0]) - height(b-&gt;ch[1]) == 1)
        return std::make_shared&lt;const node&gt; (
            b-&gt;ch[0]-&gt;val,
            std::make_shared&lt;const node&gt; (rootval, a, b-&gt;ch[0]-&gt;ch[0]),
            std::make_shared&lt;const node&gt; (b-&gt;val, b-&gt;ch[0]-&gt;ch[1], b-&gt;ch[1])
            );
      else
        return std::make_shared&lt;const node&gt; (
            b-&gt;val,
            std::make_shared&lt;const node&gt;(rootval, a, b-&gt;ch[0]),
            b-&gt;ch[1]
            );
    }
    else
      return std::make_shared&lt;const node&gt;(rootval, a, b);
  }

  static node_ref back(node_ref node) {
    if(node-&gt;ch[1]) return back(node-&gt;ch[1]);
    else return node;
  }

  static node_type push_back(node_ref node, value_ref val) {
    if(!node) return std::make_shared&lt;const struct node&gt;(val, nullptr, nullptr);
    else if(node-&gt;ch[1]) return merge(node-&gt;val, node-&gt;ch[0], push_back(node-&gt;ch[1], val));
    else return merge(node-&gt;val, node-&gt;ch[0], std::make_shared&lt;const struct node&gt;(val, nullptr, nullptr));
  }

  static node_type pop_back(node_ref node) {
    if(node-&gt;ch[1]) return merge(node-&gt;val, node-&gt;ch[0], pop_back(node-&gt;ch[1]));
    else return node-&gt;ch[0];
  }

  static node_type merge_1(value_ref rootval, node_ref dst, node_ref src) {
    if(height(dst) - height(src) &lt;= 1)
      return std::make_shared&lt;const node&gt;(rootval, dst, src);
    else
      return balance(dst-&gt;val, dst-&gt;ch[0], merge_1(rootval, dst-&gt;ch[1], src));
  }

  static node_type merge_0(value_ref rootval, node_ref dst, node_ref src) {
    if(height(dst) - height(src) &lt;= 1)
      return std::make_shared&lt;const node&gt;(rootval, src, dst);
    else
      return balance(dst-&gt;val, merge_0(rootval, dst-&gt;ch[0], src), dst-&gt;ch[1]);
  }

  static node_type merge(value_ref rootval, node_ref left, node_ref right) {
    if(height(left) &gt;= height(right)) 
      return merge_1(rootval, left, right);
    else
      return merge_0(rootval, right, left);
  }

  static split_node_type split(node_ref node, size_type i) {
    if(i == 0)
      return split_node_type(node_type(), node);
    else if(i &lt;= size(node-&gt;ch[0])) {
      auto sp = split(node-&gt;ch[0], i);
      return split_node_type(sp.first, merge(node-&gt;val, sp.second, node-&gt;ch[1]));
    }
    else {
      auto sp = split(node-&gt;ch[1], i - size(node-&gt;ch[0]) - 1);
      return split_node_type(merge(node-&gt;val, node-&gt;ch[0], sp.first), sp.second);
    }
  }

  static node_ref at(node_ref node, size_type i) {
    if(i == size(node-&gt;ch[0])) return node;
    else if(i &lt; size(node-&gt;ch[0])) return at(node-&gt;ch[0], i);
    else return at(node-&gt;ch[1], i - 1 - size(node-&gt;ch[0]));
  }

  node_type root;

public:
  
  using split_array_type = std::pair&lt;persistent_avl_array, persistent_avl_array&gt;;

  persistent_avl_array() {}
  persistent_avl_array(node_ref r) : root(r) {}

  persistent_avl_array merge(persistent_avl_array other) const {
    if(!root) return other;
    else return persistent_avl_array(merge(back(root)-&gt;val, pop_back(root), other.root));
  }

  split_array_type split(size_type i) const {
    auto p = split(root, i);
    return { persistent_avl_array(p.first), persistent_avl_array(p.second) };
  }

  persistent_avl_array push_back(value_ref val) const {
    return persistent_avl_array(push_back(root, val));
  }

  size_type len() const { return size(root); }

  value_ref at(size_type i) const { return at(root, i)-&gt;val; }
};

using namespace std;

void debug_cout(const persistent_avl_array&amp; arr) {
    for(int i = 0;i &lt; arr.len();i++){
      cout &lt;&lt; arr.at(i);
    }
    cout &lt;&lt; endl;
}

int main() {
  std::ios::sync_with_stdio(false);
  cin.tie(nullptr);
  i64 m;
  cin &gt;&gt; m;
  string s;
  cin &gt;&gt; s;
  i64 n;
  cin &gt;&gt; n;

  persistent_avl_array arr;

  for(char c: s) { arr = arr.push_back(c);}

  for(int i = 0;i &lt; n;i++) {
    i64 a, b, c;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    
    auto cpy = arr.split(b).first.split(a).second;
    auto spl = arr.split(c);
    

    arr = spl.first.merge(cpy).merge(spl.second);
    if(arr.len() &gt; m) arr = arr.split(m).first;
  }

  for(int i = 0;i &lt; arr.len();i++){
    cout &lt;&lt; arr.at(i);
  }
  cout &lt;&lt; endl;
}

</code></pre>
<h1><a class="header" href="#sparse-table" id="sparse-table">Sparse Table</a></h1>
<h2><a class="header" href="#spec-19" id="spec-19">Spec</a></h2>
<ul>
<li>
<p><code>ope</code></p>
<ul>
<li>束の演算を定義する.</li>
</ul>
</li>
<li>
<p><code>(constructor)</code></p>
<ul>
<li>Sparse Tableを構築する. \( O(N \log N) \)</li>
</ul>
</li>
<li>
<p><code>query(i64 s, i64 t)</code></p>
<ul>
<li><code>[s, t)</code>に対してクエリを処理する.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#code-19" id="code-19">Code</a></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct sparse_table {
  using Band = i64;
  Band ope(const Band&amp; a, const Band b) { return min(a, b); }

  i64 N;
  vector&lt;Band&gt; A;
  vector&lt;i64&gt; log_t;
  vector&lt;vector&lt;Band&gt;&gt; table;

  sparse_table(vector&lt;Band&gt; arr) : N(arr.size()), A(arr), log_t(arr.size() + 1) {
    for(int i = 2;i &lt; N + 1;i++) {
      log_t[i] = log_t[i &gt;&gt; 1] + 1;
    }
    table.resize(N, vector&lt;Band&gt;(log_t[N] + 1));

    for(int i = 0;i &lt; N;i++) {
      table[i][0] = arr[i];
    }

    for(int k = 1;(1 &lt;&lt; k) &lt;= N;k++) {
      for(int i = 0;i + (1 &lt;&lt; k) &lt;= N;i++) {
        table[i][k] = ope(table[i][k - 1], table[i + (1 &lt;&lt; (k - 1))][k - 1]);
      }
    }
  }
  /* [s, t) */
  Band query(i64 s, i64 t) {
    i64 k = log_t[t - s];
    return ope(table[s][k], table[t - (1 &lt;&lt; k)][k]);
  }
};
</code></pre>
<h1><a class="header" href="#sparse-table-1" id="sparse-table-1">Sparse Table</a></h1>
<h2><a class="header" href="#spec-20" id="spec-20">Spec</a></h2>
<ul>
<li>
<p><code>ope</code></p>
<ul>
<li>束の演算を定義する.</li>
</ul>
</li>
<li>
<p><code>(constructor)</code></p>
<ul>
<li>Sparse Tableを構築する. \( O(N \log N) \)</li>
</ul>
</li>
<li>
<p><code>query(i64 s, i64 t)</code></p>
<ul>
<li><code>[s, t)</code>に対してクエリを処理する.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#code-20" id="code-20">Code</a></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct sparse_table {
  using Band = i64;
  Band ope(const Band&amp; a, const Band b) { return min(a, b); }

  i64 N;
  vector&lt;Band&gt; A;
  vector&lt;i64&gt; log_t;
  vector&lt;vector&lt;Band&gt;&gt; table;

  sparse_table(vector&lt;Band&gt; arr) : N(arr.size()), A(arr), log_t(arr.size() + 1) {
    for(int i = 2;i &lt; N + 1;i++) {
      log_t[i] = log_t[i &gt;&gt; 1] + 1;
    }
    table.resize(N, vector&lt;Band&gt;(log_t[N] + 1));

    for(int i = 0;i &lt; N;i++) {
      table[i][0] = arr[i];
    }

    for(int k = 1;(1 &lt;&lt; k) &lt;= N;k++) {
      for(int i = 0;i + (1 &lt;&lt; k) &lt;= N;i++) {
        table[i][k] = ope(table[i][k - 1], table[i + (1 &lt;&lt; (k - 1))][k - 1]);
      }
    }
  }
  /* [s, t) */
  Band query(i64 s, i64 t) {
    i64 k = log_t[t - s];
    return ope(table[s][k], table[t - (1 &lt;&lt; k)][k]);
  }
};
</code></pre>
<h1><a class="header" href="#wavelet-matrix" id="wavelet-matrix">Wavelet Matrix</a></h1>
<h1><a class="header" href="#wavelet-matrix-1" id="wavelet-matrix-1">Wavelet Matrix</a></h1>
<h2><a class="header" href="#spec-21" id="spec-21">Spec</a></h2>
<h2><a class="header" href="#code-21" id="code-21">Code</a></h2>
<pre><code class="language-cpp">#include &lt;cstdint&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

using i64 = long long;

class bitvector {
  using bit_type = std::uint_least64_t;
  using size_type = std::size_t;
  static constexpr size_type wordsize = 64;
  
  std::vector&lt;bit_type&gt; bit;
  std::vector&lt;size_type&gt; sum;
  
public:

  bitvector() : bit(), sum() {} 
  bitvector(const size_type size)
    : bit(size / wordsize + 1, 0), sum(size / wordsize + 1, 0) {}

  void set(const size_type i) {
    bit[i / wordsize] |= static_cast&lt;bit_type&gt;(1) &lt;&lt; (i % wordsize);
  }
  void build() {
    for (size_type i = 1; i &lt; bit.size(); i++) {
      sum[i] = sum[i - 1] + __builtin_popcountll(bit[i - 1]);
    }
  }

  size_type at(const size_type i) const {
    return bit[i / wordsize] &gt;&gt; (i % wordsize);
  }

  // count of ones in [0, i)
  size_type rank(const size_type i) const {
    return sum[i / wordsize]
      + __builtin_popcountll(bit[i / wordsize] &amp; (static_cast&lt;bit_type&gt;(1) &lt;&lt; (i % wordsize)) - 1);
  }

  // count of ones in [0, i)
  size_type rank(const size_type i, const size_type b) const {
    size_type ans = sum[i / wordsize]
      + __builtin_popcountll(bit[i / wordsize] &amp; (static_cast&lt;bit_type&gt;(1) &lt;&lt; (i % wordsize)) - 1);
    if(b) return ans;
    else return i - ans;
  }
};

class wavelet_matrix {
  using Integer = i64;
  using integer_type = Integer;
  using size_type = std::size_t;


  const size_type depth;
  const size_type len;
  std::vector&lt;bitvector&gt; mat;
  std::vector&lt;size_type&gt; spl;

public:

  wavelet_matrix(const std::vector&lt;integer_type&gt;&amp; arr, size_type de)
    : depth(de),
      len(arr.size()),
      mat(std::vector&lt;bitvector&gt;(depth, bitvector(arr.size()))),
      spl(std::vector&lt;size_type&gt;(depth, 0)) {
        std::vector&lt;size_type&gt; idx(len);
        std::vector&lt;size_type&gt; left(len), right(len);
        for(size_type i = 0;i &lt; len;i++) idx[i] = i;
        for(size_type d = depth; d-- &gt; 0;) {
          size_type l = 0, r = 0;
          
          for(size_type i = 0; i &lt; len; i++) {
            size_type k = (arr[idx[i]] &gt;&gt; d) &amp; 1;
            if(k) right[r++] = idx[i], mat[d].set(i);
            else left[l++] = idx[i];
          }
          mat[d].build();
          spl[d] = l;
          swap(idx, left);
          for(size_type i = 0; i &lt; r; i++) idx[i + l] = right[i];
        }
      }

  integer_type at(size_type i) const {
    integer_type x = static_cast&lt;integer_type&gt;(0);
    for(size_type d = depth; d-- &gt; 0;) {
      size_type k = mat[d].at(i);
      x |= (static_cast&lt;integer_type&gt;(k) &lt;&lt; d);
      i = mat[d].rank(i, k) + spl[d] * k;
    }
    return x;
  }

  // counting elements that equal to x in range [left, right)
  size_type rank_x(size_type left, size_type right, integer_type x) const {
    for(size_type d = depth; d-- &gt; 0;) {
      size_type k = ((x &gt;&gt; d) &amp; 1);
      left = mat[d].rank(left, k) + spl[d] * k;
      right = mat[d].rank(right, k) + spl[d] * k;
    }
    return right - left;
  }

  // sorted(arr[left..right])[i]
  integer_type quantile(size_type left, size_type right, size_type i) const {
    integer_type x = static_cast&lt;integer_type&gt;(0);
    for(size_type d = depth; d-- &gt; 0;) {
      size_type cnt = mat[d].rank(right, 0) - mat[d].rank(left, 0);
      size_type k = (i &lt; cnt) ? 0 : 1;
      x |= (k &lt;&lt; d);
      left = mat[d].rank(left, k) + spl[d] * k;
      right = mat[d].rank(right, k) + spl[d] * k;
    }
    return x;
  }

  struct rank_result {
    size_type le;
    size_type eq;
    size_type mo;
  };

  // couting elements that less than x, equal to x, and more than x in range [left, right)
  rank_result rank_less_eq_more(size_type left, size_type right, integer_type x) const {
    size_type le = 0, mo = 0;
    for(size_type d = depth; d --&gt; 0;) {
      size_type k = (x &gt;&gt; d) &amp; 1;
      size_type l = mat[d].rank(left, 1);
      size_type r = mat[d].rank(right, 1);
      if(k == 0) {
        mo += r - l;
        left -= l;
        right -= r;
      }
      else {
        le += (right - left) - (r - l);
        left = l + spl[d];
        right = r + spl[d];
      }
    }
    return rank_result { le, right - left, mo };
  }

  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y, integer_type l, size_type d) const {
    integer_type r = l + (1 &lt;&lt; d);
    if(x &lt;= l &amp;&amp; r &lt;= y) {
      return right - left;
    }
    else if(y &lt;= l || r &lt;= x) {
      return 0;
    }
    else {
      d--;
      size_type lr = mat[d].rank(left, 1);
      size_type rr = mat[d].rank(right, 1);
      return
        rangefreq(left - lr, right - rr, x, y, l, d) +
        rangefreq(lr + spl[d], rr + spl[d], x, y, l + (1 &lt;&lt; d), d);
    }
  }

  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y) const {
    return rangefreq(left, right, x, y, 0, depth);
  }
};
</code></pre>
<h1><a class="header" href="#dynamic-wavelet-matrix" id="dynamic-wavelet-matrix">Dynamic Wavelet Matrix</a></h1>
<h2><a class="header" href="#spec-22" id="spec-22">Spec</a></h2>
<h2><a class="header" href="#code-22" id="code-22">Code</a></h2>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;array&gt;
#include &lt;set&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;cstdint&gt;
#include &lt;cassert&gt;
#include &lt;bitset&gt;

struct dynamic_bitvector {


  struct node;
  using size_type = std::size_t;
  using height_type = long long;
  using node_type = std::unique_ptr&lt;struct node&gt;;
  using node_reference = const node_type&amp;;
  using bits_type = std::uint64_t;
  using children_type = std::array&lt;node_type, 2&gt;;


  const static size_type bit_limit = 32;

  struct bitvector_builder {
    const static size_type bit_size = bit_limit * 2;
    const size_type len;
    std::vector&lt;bits_type&gt; bits;
    bitvector_builder(size_type len): len(len), bits(len / bit_size + !!(len &amp; (bit_size - 1))) {}
    void set(size_type i) { bits[i / bit_size] |= (bits_type(1) &lt;&lt; (i &amp; (bit_size - 1))); }
    dynamic_bitvector build() const {
      return dynamic_bitvector(bits, len);
    }
  };

  static size_type bits_popcount(bits_type bits) {
    return __builtin_popcountll(bits);
  }

  struct section_t {
    height_type he;
    children_type ch;
  };

  struct leaf_t {
    bits_type bits;
  };

  union info_t {
    section_t section;
    leaf_t leaf;
    info_t(section_t sec): section(std::move(sec)) {}
    info_t(leaf_t leaf): leaf(leaf) {}
    ~info_t() {}
  };

  struct node {
    const bool is_leaf;
    size_type sz;
    size_type popcnt;
    info_t info;

    static node_type new_section(node_type left, node_type right) {
      node* n = new node(section_t { 0, children_type { std::move(left), std::move(right) } });
      n-&gt;fix();
      return node_type(n);
    }

    static node_type new_leaf(bits_type bits, size_type sz, size_type popcnt) {
      node* n = new node(leaf_t { bits });
      n-&gt;sz = sz;
      n-&gt;popcnt = popcnt;
      return node_type(n);
    }

    node(section_t sec): is_leaf(false), info(std::move(sec)) {}
    node(leaf_t leaf): is_leaf(true), info(leaf) {}

    height_type height() const {
      if(is_leaf) return 0;
      else return info.section.he;
    }
    size_type size() const {
      return sz;
    }

    size_type popcount() const {
      return popcnt;
    }

    // operation for only section node

    node_type take(size_type dir) {
      assert(!is_leaf);
      return std::move(info.section.ch[dir]);
    }

    node_type swap(size_type dir, node_type new_node) {
      assert(!is_leaf);
      node_type old_node = take(dir);
      info.section.ch[dir] = std::move(new_node);
      return old_node;
    }

    const node_type&amp; child(size_type dir) const {
      assert(!is_leaf);
      return info.section.ch[dir];
    }

    height_type diff() const {
      assert(!is_leaf);
      return child(0)-&gt;height() - child(1)-&gt;height();
    }

    void fix() {
      assert(!is_leaf);
      sz = child(0)-&gt;size() + child(1)-&gt;size();
      popcnt = child(0)-&gt;popcount() + child(1)-&gt;popcount();
      info.section.he = std::max(child(0)-&gt;height(), child(1)-&gt;height()) + 1;
    }

    // operation for only leaf node

    bits_type bits() const {
      assert(is_leaf);
      return info.leaf.bits;
    }

    bool at_bits(size_type pos) const {
      assert(is_leaf);
      return (bits() &gt;&gt; pos) &amp; 1;
    }

    size_type rank(size_type pos) const {
      assert(pos &lt;= size());
      return bits_popcount(bits() &amp; ((bits_type(1) &lt;&lt; pos) - 1));
    }

    void set_bits(bits_type bits, size_type sz_, size_type popcnt_) {
      assert(is_leaf);
      sz = sz_;
      popcnt = popcnt_;
      info.leaf.bits = bits;
    }

    // [0, pos) and [pos, sz)
    std::pair&lt;bits_type, bits_type&gt; split_bits(size_type pos) const {
      assert(is_leaf);
      assert(pos &lt;= size());
      return std::make_pair(bits() &amp; ((bits_type(1) &lt;&lt; pos) - 1), bits() &gt;&gt; pos);
    }

    void insert_bit(size_type pos, bool bit) {
      assert(is_leaf);
      assert(sz &lt; bit_limit * 2);
      bits_type l, r;
      std::tie(l, r) = split_bits(pos);
     // std::cout &lt;&lt; &quot;insert &quot; &lt;&lt; bit  &lt;&lt; &quot; to &quot; &lt;&lt; pos &lt;&lt; std::endl;
     // std::cout &lt;&lt; &quot;insert &quot; &lt;&lt; std::bitset&lt;bit_limit * 2&gt;(l) &lt;&lt; &quot; &quot; &lt;&lt; std::bitset&lt;bit_limit * 2&gt;(r) &lt;&lt; std::endl;
     // std::cout &lt;&lt; &quot;insert &quot; &lt;&lt; std::bitset&lt;bit_limit * 2&gt;(bits()) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; std::bitset&lt;bit_limit * 2&gt;(l | ((bits_type(bit) &lt;&lt; pos)) | (r &lt;&lt; (pos + 1))) &lt;&lt; std::endl;
      set_bits(l | ((bits_type(bit) &lt;&lt; pos)) | (r &lt;&lt; (pos + 1)), sz + 1, popcount() + bit);
    } 

    void erase_bit(size_type pos) {
      assert(is_leaf);
      assert(0 &lt; sz);
      bits_type l, r;
      std::tie(l, r) = split_bits(pos);
      size_type pos_bit = r &amp; 1;
      r &gt;&gt;= 1;
      set_bits(l | (r &lt;&lt; pos), sz - 1, popcount() - pos_bit);
    }
  };


  static node_type rotate(node_type x, size_type dir) {
    node_type y = x-&gt;take(1 - dir);
    node_type b = y-&gt;take(dir);
    x-&gt;swap(1 - dir, std::move(b));
    x-&gt;fix();
    y-&gt;swap(dir, std::move(x));
    y-&gt;fix();
    return std::move(y);
  }

  static node_type balance(node_type node) {
    node-&gt;fix();
    if(node-&gt;diff() == 2) {
      if(node-&gt;child(0)-&gt;diff() == -1) {
        auto ch = node-&gt;take(0);
        node-&gt;swap(0, rotate(std::move(ch), 0));
      }
      return rotate(std::move(node), 1);
    }
    else if(node-&gt;diff() == -2) {
      if(node-&gt;child(1)-&gt;diff() == 1) {
        auto ch = node-&gt;take(1);
        node-&gt;swap(1, rotate(std::move(ch), 1));
      }
      return rotate(std::move(node), 0);
    }
    else return std::move(node);
  }

  static node_type split_node(node_type node) {
    assert(node-&gt;is_leaf);
    bits_type l, r;
    std::tie(l, r) = node-&gt;split_bits(bit_limit);
    return node::new_section(
        node::new_leaf(l, bit_limit, bits_popcount(l)), node::new_leaf(r, node-&gt;size() - bit_limit, bits_popcount(r))
        );
  }

  static node_type insert(node_type node, size_type pos, bool bit) {
    if(node-&gt;is_leaf) {
      if(node-&gt;size() == 2 * bit_limit) {
        return insert(split_node(std::move(node)), pos, bit);
      }
      else {
        node-&gt;insert_bit(pos, bit);
        return node;
      }
    }
    else if(pos &lt; node-&gt;child(0)-&gt;size()) {
      node-&gt;swap(0, insert(node-&gt;take(0), pos, bit));
      return balance(std::move(node));
    }
    else {
      node-&gt;swap(1, insert(node-&gt;take(1), pos - node-&gt;child(0)-&gt;size(), bit));
      return balance(std::move(node));
    }
  }

  template&lt;const size_type dir&gt;
  static std::tuple&lt;node_type, bits_type, size_type&gt; take_bit(node_type node, size_type len) {
    if(node-&gt;is_leaf) {
      if(node-&gt;size() &lt; bit_limit / 2 + len) {
        return std::tuple&lt;node_type, bits_type, size_type&gt;{ node_type(nullptr), node-&gt;bits(), node-&gt;size() };
      }
      else {
        auto p = node-&gt;split_bits(dir == 0 ? len : node-&gt;size() - len);
        bits_type node_bit = std::get&lt;1 - dir&gt;(p);
        bits_type take = std::get&lt;dir&gt;(p);
        node-&gt;set_bits(node_bit, node-&gt;size() - len, bits_popcount(node_bit));
        return std::tuple&lt;node_type, bits_type, size_type&gt; { std::move(node), take, len };
      }
    }
    else {
      node_type ch;
      bits_type bits;
      size_type take_len;
      std::tie(ch, bits, take_len) = take_bit&lt;dir&gt;(node-&gt;take(dir), len);
      if(ch) {
        node-&gt;swap(dir, std::move(ch));
        return std::tuple&lt;node_type, bits_type, size_type&gt;{ balance(std::move(node)), bits, take_len };
      }
      else {
        return std::tuple&lt;node_type, bits_type, size_type&gt; { node-&gt;take(1 - dir), bits, take_len };
      }
    }
  }

  static node_type erase(node_type node, size_type pos) {
    if(node-&gt;is_leaf) {
      node-&gt;erase_bit(pos);
      return node;
    }
    else if(pos &lt; node-&gt;child(0)-&gt;size()) {
      auto left = erase(node-&gt;take(0), pos);
      if(left-&gt;size() &lt; bit_limit / 2) {
        assert(left-&gt;is_leaf);
        node_type right;
        bits_type bits;
        size_type len;
        std::tie(right, bits, len) = take_bit&lt;0&gt;(node-&gt;take(1), bit_limit / 2 - left-&gt;size());

        left-&gt;set_bits(left-&gt;bits() | (bits &lt;&lt; left-&gt;size()), left-&gt;size() + len, left-&gt;popcount() + bits_popcount(bits));
        if(right) {
          node-&gt;swap(0, std::move(left));
          node-&gt;swap(1, std::move(right));
          return balance(std::move(node));
        }
        else {
          return left;
        }
      }
      else {
        node-&gt;swap(0, std::move(left));
        return balance(std::move(node));
      }
    }
    else {
      auto right = erase(node-&gt;take(1), pos - node-&gt;child(0)-&gt;size());
      if(right-&gt;size() &lt; bit_limit / 2) {
        assert(right-&gt;is_leaf);
        node_type left;
        bits_type bits;
        size_type len;
        std::tie(left, bits, len) = take_bit&lt;1&gt;(node-&gt;take(0), bit_limit / 2 - right-&gt;size());

        right-&gt;set_bits((right-&gt;bits() &lt;&lt; len) | bits, right-&gt;size() + len, right-&gt;popcount() + bits_popcount(bits));
        if(left) {
          node-&gt;swap(0, std::move(left));
          node-&gt;swap(1, std::move(right));
          return balance(std::move(node));
        }
        else {
          return right;
        }
      }
      else {
        node-&gt;swap(1, std::move(right));
        return balance(std::move(node));
      }
    }
  }

  static node_type merge_dir(node_type dst, node_type src, size_type dir) {
    if(std::abs(dst-&gt;height() - src-&gt;height()) &lt;= 1) {
      if(dir == 0)
        return node::new_section(std::move(src), std::move(dst));
      else
        return node::new_section(std::move(dst), std::move(src));
    }
    else {
      node_type ch = dst-&gt;take(dir);
      assert(ch);
      dst-&gt;swap(dir, merge_dir(std::move(ch), std::move(src), dir));
      return balance(std::move(dst));
    }
  }

  static node_type merge(node_type left, node_type right) {
    if(!left) { return std::move(right); }
    else if(!right) { return std::move(left); }
    else if(left-&gt;height() &gt;= right-&gt;height()) {
      return merge_dir(std::move(left), std::move(right), 1);
    }
    else {
      return merge_dir(std::move(right), std::move(left), 0);
    }
  }

  static node_type build(const std::vector&lt;bits_type&gt;&amp; bits, size_type l, size_type r, size_type len) {
    //std::cout &lt;&lt; &quot;build &quot; &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; len &lt;&lt; std::endl;
    if(l + 1 &gt;= r) {
      //std::cout &lt;&lt; &quot;create leaf&quot; &lt;&lt; std::endl;
      //std::cout &lt;&lt; &quot;-----------&quot; &lt;&lt; std::endl;
      return node::new_leaf(bits[l], len, bits_popcount(bits[l]));
    }
    else {
      size_type m = (l + r) &gt;&gt; 1;
      return merge(build(bits, l, m, (m - l) * 64), build(bits, m, r, len - (m - l) * 64));
    }
  }

  static size_type at(node_reference node, size_type pos) {
    if(node-&gt;is_leaf) {
      return node-&gt;at_bits(pos);
    }
    else if(pos &lt; node-&gt;child(0)-&gt;size()) {
      return at(node-&gt;child(0), pos);
    }
    else {
      return at(node-&gt;child(1), pos - node-&gt;child(0)-&gt;size());
    }
  }

  static size_type rank(node_reference node, size_type pos) {
    if(node-&gt;is_leaf) {
      return node-&gt;rank(pos);
    }
    else if(pos &lt; node-&gt;child(0)-&gt;size()) {
      return rank(node-&gt;child(0), pos);
    }
    else {
      return node-&gt;child(0)-&gt;popcount() + rank(node-&gt;child(1), pos - node-&gt;child(0)-&gt;size());
    }
  }


  node_type root;

  dynamic_bitvector(): root(node::new_leaf(0, 0, 0)) {}
  dynamic_bitvector(const std::vector&lt;bits_type&gt;&amp; bits, size_type len): root(build(bits, 0, bits.size(), len)) {}
  void insert(size_type pos, bool bit) {
    root = insert(std::move(root), pos, bit);
  }
  void erase(size_type pos) {
    root = erase(std::move(root), pos);
  }
  bool at(size_type pos) const {
    return at(root, pos);
  }
  size_type rank(size_type pos) const {
    return rank(root, pos);
  }
  size_type rank(size_type pos, bool bit) const {
    if(bit) {
      return rank(root, pos);
    }
    else {
      return pos - rank(root, pos);
    }
  }
  size_type size() const {
    return root-&gt;size();
  }

  void debug_tree(node_reference node, std::string d) const {
    if(node-&gt;is_leaf) {
      std::cout &lt;&lt; d &lt;&lt; &quot;leaf &quot; &lt;&lt; node-&gt;size() &lt;&lt; &quot; &quot; &lt;&lt; node-&gt;popcount() &lt;&lt; &quot; -----------&quot; &lt;&lt; std::endl;
      std::cout &lt;&lt; d &lt;&lt; std::bitset&lt;bit_limit * 2&gt;(node-&gt;bits()) &lt;&lt; std::endl;
      std::cout &lt;&lt; d &lt;&lt; &quot;-------------&quot; &lt;&lt; std::endl;
    }
    else {
      std::cout &lt;&lt; d &lt;&lt; &quot;node &quot; &lt;&lt; node-&gt;size() &lt;&lt; &quot; &quot; &lt;&lt; node-&gt;popcount() &lt;&lt; &quot; ----------&quot; &lt;&lt; std::endl;
      std::cout &lt;&lt; d &lt;&lt; &quot;left&quot; &lt;&lt; std::endl;
      debug_tree(node-&gt;child(0), d + &quot;   &quot;);
      std::cout &lt;&lt; d &lt;&lt; &quot;--------------&quot; &lt;&lt; std::endl;
      std::cout &lt;&lt; d &lt;&lt; &quot;right&quot; &lt;&lt; std::endl;
      debug_tree(node-&gt;child(1), d + &quot;   &quot;);
      std::cout &lt;&lt; d &lt;&lt; &quot;--------------&quot; &lt;&lt; std::endl;
    }
  }

  void debug_tree() const {
    debug_tree(root, &quot;&quot;);
  }
};

#include &lt;vector&gt;
struct dynamic_wavelet_matrix {
  using Integer = std::size_t;
  using integer_type = Integer;
  using size_type = std::size_t;


  const size_type depth;
  const size_type len;
  std::vector&lt;dynamic_bitvector&gt; mat;
  std::vector&lt;size_type&gt; spl;

public:

  dynamic_wavelet_matrix(const std::vector&lt;integer_type&gt;&amp; arr, size_type de)
    : depth(de),
      mat(de),
      len(arr.size()),
      spl(std::vector&lt;size_type&gt;(depth, 0)) {
        std::vector&lt;size_type&gt; idx(len);
        std::vector&lt;size_type&gt; left(len), right(len);

        for(size_type i = 0;i &lt; len;i++) idx[i] = i;

        for(size_type d = depth; d-- &gt; 0;) {
          size_type l = 0, r = 0;
          dynamic_bitvector::bitvector_builder builder(len);
          for(size_type i = 0; i &lt; len; i++) {
            size_type k = (arr[idx[i]] &gt;&gt; d) &amp; 1;
            if(k) right[r++] = idx[i], builder.set(i);
            else left[l++] = idx[i];
          }
          mat[d] = builder.build();
          spl[d] = l;
          swap(idx, left);
          for(size_type i = 0; i &lt; r; i++) idx[i + l] = right[i];
        }
      }

  void insert(size_type i, integer_type x) {
    for(size_type d = depth; d --&gt; 0;) {
      size_type k = ((x &gt;&gt; d) &amp; 1);
      mat[d].insert(i, k);
      i = mat[d].rank(i, k) + spl[d] * k;
      if(k == 0) spl[d]++;
    }
  }

  void erase(size_type i) {
    for(size_type d = depth; d--&gt; 0;) {
      size_type k = mat[d].at(i);
      mat[d].erase(i);
      i = mat[d].rank(i, k) + spl[d] * k;
      if(k == 0) spl[d]--;
    }
  }

  integer_type at(size_type i) const {
    integer_type x = static_cast&lt;integer_type&gt;(0);
    for(size_type d = depth; d-- &gt; 0;) {
      size_type k = mat[d].at(i);
      x |= (static_cast&lt;integer_type&gt;(k) &lt;&lt; d);
      i = mat[d].rank(i, k) + spl[d] * k;
    }
    return x;
  }

  // counting elements that equal to x in range [left, right)
  size_type rank_x(size_type left, size_type right, integer_type x) const {
    for(size_type d = depth; d-- &gt; 0;) {
      size_type k = ((x &gt;&gt; d) &amp; 1);
      left = mat[d].rank(left, k) + spl[d] * k;
      right = mat[d].rank(right, k) + spl[d] * k;
    }
    return right - left;
  }

  // sorted(arr[left..right])[i]
  integer_type quantile(size_type left, size_type right, size_type i) const {
    integer_type x = static_cast&lt;integer_type&gt;(0);
    for(size_type d = depth; d-- &gt; 0;) {
      size_type cnt = mat[d].rank(right, 0) - mat[d].rank(left, 0);
      size_type k = (i &lt; cnt) ? 0 : 1;
      x |= (k &lt;&lt; d);
      left = mat[d].rank(left, k) + spl[d] * k;
      right = mat[d].rank(right, k) + spl[d] * k;
    }
    return x;
  }

  struct rank_result {
    size_type le;
    size_type eq;
    size_type mo;
  };

  // couting elements that less than x, equal to x, and more than x in range [left, right)
  rank_result rank_less_eq_more(size_type left, size_type right, integer_type x) const {
    size_type le = 0, mo = 0;
    for(size_type d = depth; d --&gt; 0;) {
      size_type k = (x &gt;&gt; d) &amp; 1;
      size_type l = mat[d].rank(left, 1);
      size_type r = mat[d].rank(right, 1);
      if(k == 0) {
        mo += r - l;
        left -= l;
        right -= r;
      }
      else {
        le += (right - left) - (r - l);
        left = l + spl[d];
        right = r + spl[d];
      }
    }
    return rank_result { le, right - left, mo };
  }

  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y, integer_type l, size_type d) const {
    integer_type r = l + (1 &lt;&lt; d);
    if(x &lt;= l &amp;&amp; r &lt;= y) {
      return right - left;
    }
    else if(y &lt;= l || r &lt;= x) {
      return 0;
    }
    else {
      d--;
      size_type lr = mat[d].rank(left, 1);
      size_type rr = mat[d].rank(right, 1);
      return
        rangefreq(left - lr, right - rr, x, y, l, d) +
        rangefreq(lr + spl[d], rr + spl[d], x, y, l + (1 &lt;&lt; d), d);
    }
  }

  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y) const {
    return rangefreq(left, right, x, y, 0, depth);
  }

  size_type rangefreq_count(size_type left, size_type right, integer_type x, integer_type y) const {
    auto p = rank_less_eq_more(left, right, x);
    auto q = rank_less_eq_more(left, right, y);
    return p.eq + p.mo - q.eq - q.mo;
  }
};
</code></pre>
<h1><a class="header" href="#data-structures-other" id="data-structures-other">Data Structures Other</a></h1>
<p>うまく分類できなかったもの</p>
<h1><a class="header" href="#swag" id="swag">SWAG</a></h1>
<h3><a class="header" href="#spec-23" id="spec-23">Spec</a></h3>
<h3><a class="header" href="#code-23" id="code-23">Code</a></h3>
<pre><code class="language-cpp">#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;string&gt;

struct swag {

  using T = std::string;
  static T ide() {
    return &quot;&quot;;
  }
  static T ope(const T&amp; a, const T&amp; b) {
    return a + b;
  }

  std::stack&lt;T&gt; left_v, right_v, left_f, right_f;

  swag() {
    left_f.push(ide());
    right_f.push(ide());
  }

  void push(T val) {
    left_f.push(ope(left_f.top(), val));
    left_v.push(std::move(val));
  }

  T fold() {
    if(right_f.size() == 1) {
      while(left_f.size() &gt; 1) {
        right_f.push(ope(left_v.top(), right_f.top()));
        right_v.push(left_v.top());
        left_f.pop();
        left_v.pop();
      }
    }
    return ope(right_f.top(), left_f.top());
  }

  void pop() {
    right_f.pop();
    right_v.pop();
  }
};
</code></pre>
<h1><a class="header" href="#fenwick-tree" id="fenwick-tree">Fenwick Tree</a></h1>
<h3><a class="header" href="#spec-24" id="spec-24">Spec</a></h3>
<h3><a class="header" href="#code-24" id="code-24">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
using i64 = long long;

template&lt;class AbelianMonoid, class Ope, const AbelianMonoid&amp; Ide&gt;
struct fenwick_tree {
  using value_type = AbelianMonoid;

  i64 n;
  std::vector&lt;value_type&gt; node;
  Ope ope;

  fenwick_tree(i64 n_): n(n_), node(n + 1, Ide) {}
  fenwick_tree(const std::vector&lt;value_type&gt;&amp; init): n(init.size()), node(n + 1, Ide) {
    for(i64 i = 0;i &lt; init.size(); i++) node[i + 1] = init[i];
    for(i64 i = 1;i &lt; n;i++) node[i + (i &amp; -i)] = ope(node[i + (i &amp; -i)], node[i]);
  }
  void modify(i64 i, value_type x) {
    i++;
    while(i &lt;= n) {
      node[i] = ope(node[i], x);
      i += (i &amp; -i);
    }
  }
  // [0, i)
  value_type sum(i64 i) const {
    value_type ret = Ide;
    while(i &gt; 0) {
      ret = ope(ret, node[i]);
      i -= i &amp; (-i);
    }
    return ret;
  }
};
</code></pre>
<h1><a class="header" href="#math" id="math">Math</a></h1>
<p>数学系を</p>
<ul>
<li><a href="math/./modint.html">modint</a></li>
<li><a href="math/./matrix.html">Matrix</a> \</li>
<li><a href="math/./garner.html">Garner's Algorithm</a></li>
<li><a href="math/./polynomial.html">Polynomial</a> \</li>
<li><a href="math/./runtime_fp.html">Runtime fp</a> \</li>
</ul>
<h1><a class="header" href="#modint" id="modint">modint</a></h1>
<p>xxで割ったあまりを求めよで使える構造体</p>
<h3><a class="header" href="#spec-25" id="spec-25">Spec</a></h3>
<ul>
<li>
<p>template</p>
<ul>
<li><code>i64 M</code>
<ul>
<li>\( \mod M \)の剰余環</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>modint(const i64 x = 0)</code></p>
<ul>
<li>\( x \mod M \)で初期化</li>
</ul>
</li>
<li>
<p><code>value()</code></p>
<ul>
<li>\( x \mod M \)を返す</li>
</ul>
</li>
<li>
<p><code>pow(i64 r)</code></p>
<ul>
<li>\( x^r \mod M \)を返す</li>
</ul>
</li>
<li>
<p><code>+, -, *, /</code></p>
</li>
</ul>
<h3><a class="header" href="#code-25" id="code-25">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

template&lt;i64 M&gt;
struct modint {
  i64 a;
  constexpr modint(const i64 x = 0) noexcept: a((x % M + M) % M) {}
  constexpr i64 value() const noexcept { return a; }
  constexpr modint pow(i64 r) const noexcept {
    modint ans(1);
    modint aa = *this;
    while(r) {
      if(r &amp; 1) {
        ans *= aa;
      }
      aa *= aa;
      r &gt;&gt;= 1;
    }
    return ans;
  }
  constexpr modint&amp; operator+=(const modint r) noexcept {
    a += r.a;
    if(a &gt;= M) a -= M;
    return *this;
  }
  constexpr modint&amp; operator=(const i64 r) {
    a = (r % M + M) % M;
    return *this;
  }
  constexpr modint&amp; operator-=(const modint r) noexcept {
    a -= r.a;
    if(a &lt; 0) a += M;
    return *this;
  }
  constexpr modint&amp; operator*=(const modint r) noexcept {
    a = a * r.a % M;
    return *this;
  }
  constexpr modint&amp; operator/=(modint r) noexcept {
    i64 ex = M - 2;
    while(ex) {
      if(ex &amp; 1) {
        *this *= r;
      }
      r *= r;
      ex &gt;&gt;= 1;
    }
    return *this;
  }

  constexpr modint operator+(const modint r) const {
    return modint(*this) += r;
  }
  constexpr modint operator-(const modint r) const {
    return modint(*this) -= r;
  }
  constexpr modint operator*(const modint r) const {
    return modint(*this) *= r;
  }
  constexpr modint operator/(const modint r) const {
    return modint(*this) /= r;
  }
};

template&lt;const i64 M&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const modint&lt;M&gt;&amp; m) {
  os &lt;&lt; m.value();
  return os;
}
</code></pre>
<h1><a class="header" href="#matrix" id="matrix">Matrix</a></h1>
<p>行列演算</p>
<h3><a class="header" href="#code-26" id="code-26">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;
#define rep(i,s,e) for(i64 (i) = (s);(i) &lt; (e);(i)++)
#define rev(i,s,e) for(i64 (i) = (s);(i) --&gt; (e);)
#define all(x) x.begin(),x.end()
 
template&lt;class T, const i64 N, const i64 M&gt;
struct matrix {
  vector&lt;vector&lt;T&gt;&gt; mat;
  matrix(T init = T()): mat(N, vector&lt;T&gt;(M, init)) {}
  vector&lt;T&gt;&amp; operator[](i64 i) { return mat[i]; }
  const vector&lt;T&gt;&amp; operator[](i64 i) const { return mat[i]; }
  static matrix&lt;T, N, N&gt; E() {
    matrix&lt;T, N, N&gt; mat(0);
    rep(i,0,N) mat[i][i] = 1;
    return mat;
  }
};
template&lt;class T, const i64 L, const i64 M, const i64 N&gt;
matrix&lt;T, L, N&gt; operator*(const matrix&lt;T, L, M&gt;&amp; lm, const matrix&lt;T, M, N&gt;&amp; rm) {
  matrix&lt;T, L, N&gt; ret;
  rep(i, 0, L) rep(j, 0, M) rep(k, 0, N) (ret[i][k] += lm[i][j] * rm[j][k]);
  return ret;
}
 
template&lt;class T, const i64 N&gt;
matrix&lt;T, N, N&gt; matrix_pow(matrix&lt;T, N, N&gt; mat, i64 r) {
  matrix&lt;T, N, N&gt; ret = matrix&lt;T, N, N&gt;::E();
  while(r &gt; 0) {
    if(r &amp; 1) ret = ret * mat;
    mat = mat * mat;
    r &gt;&gt;= 1;
  }
  return ret;
}
</code></pre>
<h1><a class="header" href="#garners-algorithm" id="garners-algorithm">Garner's Algorithm</a></h1>
<p>FPSで使う</p>
<h3><a class="header" href="#spec-26" id="spec-26">Spec</a></h3>
<p>\(m_0, \cdots, m_{k-1} \)が互いに素とする.<br />
\( x &lt; \prod{m_i} \)を満たす\( x \)について, \( x \mod m_i \)がわかっている時,<br />
\( O(k^2 + k \log m) \)で \( x \mod M \) を求めることができる.</p>
<h3><a class="header" href="#code-27" id="code-27">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

i64 pow_mod(i64 x, i64 r, i64 mod) {
  i64 ans = 1;
  while(r) {
    if(r &amp; 1) ans = (ans * x) % mod;
    r &gt;&gt;= 1;
    x = x * x % mod;
  }
  return ans;
}

i64 inv_mod(i64 x, i64 mod) {
  return pow_mod(x, mod - 2, mod);
}

i64 garner(const vector&lt;i64&gt; &amp;x, vector&lt;i64&gt; mods, i64 mod) {
  mods.emplace_back(mod);
  vector&lt;i64&gt; coeffs(x.size() + 1, 1);
  vector&lt;i64&gt; constants(x.size() + 1, 0);
  for(i64 i = 0; i &lt; x.size(); i++) {
    i64 v = (x[i] - constants[i]) * inv_mod(coeffs[i], mods[i]) % mods[i];
    if(v &lt; 0) v += mods[i];
    for(i64 j = i + 1; j &lt; x.size() + 1; j++) {
      constants[j] = (constants[j] + coeffs[j] * v) % mods[j];
      coeffs[j] = (coeffs[j] * mods[i]) % mods[j];
    }
  }
  return constants.back();
}
</code></pre>
<h1><a class="header" href="#formal-power-series" id="formal-power-series">Formal Power Series</a></h1>
<h2><a class="header" href="#code-28" id="code-28">Code</a></h2>
<p>#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;</p>
<p>template<i64 M>
struct modint {
i64 a;
constexpr modint(const i64 x = 0) noexcept: a((x % M + M) % M) {}
constexpr i64 value() const noexcept { return a; }
constexpr modint pow(i64 r) const noexcept {
modint ans(1);
modint aa = *this;
while(r) {
if(r &amp; 1) {
ans *= aa;
}
aa *= aa;
r &gt;&gt;= 1;
}
return ans;
}
constexpr modint&amp; operator+=(const modint r) noexcept {
a += r.a;
if(a &gt;= M) a -= M;
return *this;
}
constexpr modint&amp; operator=(const i64 r) {
a = (r % M + M) % M;
return *this;
}
constexpr modint&amp; operator-=(const modint r) noexcept {
a -= r.a;
if(a &lt; 0) a += M;
return <em>this;
}
constexpr modint&amp; operator</em>=(const modint r) noexcept {
a = a * r.a % M;
return *this;
}
constexpr modint&amp; operator/=(modint r) noexcept {
i64 ex = M - 2;
while(ex) {
if(ex &amp; 1) {
*this *= r;
}
r *= r;
ex &gt;&gt;= 1;
}
return *this;
}</p>
<p>constexpr modint operator+(const modint r) const {
return modint(*this) += r;
}
constexpr modint operator-(const modint r) const {
return modint(<em>this) -= r;
}
constexpr modint operator</em>(const modint r) const {
return modint(*this) *= r;
}
constexpr modint operator/(const modint r) const {
return modint(*this) /= r;
}</p>
<p>constexpr bool operator!=(const modint r) const {
return this-&gt;value() != r.value();
}</p>
<p>};</p>
<p>constexpr i64 NTT_PRIMES[][2] = {
{1224736769, 3}, // 2^24 * 73 + 1,
{1053818881, 7}, // 2^20 * 3 * 5 * 67 + 1
{1051721729, 6}, // 2^20 * 17 * 59 + 1
{1045430273, 3}, // 2^20 * 997 + 1
{1012924417, 5}, // 2^21 * 3 * 7 * 23 + 1
{1007681537, 3}, // 2^20 * 31^2 + 1
{1004535809, 3}, // 2^21 * 479 + 1
{998244353, 3},  // 2^23 * 7 * 17 + 1
{985661441, 3},  // 2^22 * 5 * 47 + 1
{976224257, 3},  // 2^20 * 7^2 * 19 + 1
{975175681, 17}, // 2^21 * 3 * 5 * 31 + 1
{962592769, 7},  // 2^21 * 3^3 * 17 + 1
{950009857, 7},  // 2^21 * 4 * 151 + 1
{943718401, 7},  // 2^22 * 3^2 * 5^2 + 1
{935329793, 3},  // 2^22 * 223 + 1
{924844033, 5},  // 2^21 * 3^2 * 7^2 + 1
{469762049, 3},  // 2^26 * 7 + 1
{167772161, 3},  // 2^25 * 5 + 1
};</p>
<p>template&lt;const i64 mod, const i64 primitive&gt;
vector&lt;modint<mod>&gt; number_theoretic_transform(vector&lt;modint<mod>&gt; a) {
i64 n = a.size();
for(i64 s = n &gt;&gt; 1; s &gt;= 1; s &gt;&gt;= 1) {
modint<mod> zeta = modint<mod>(primitive).pow((mod - 1) / (s &lt;&lt; 1));
for(i64 i = 0; i &lt; n; i += (s &lt;&lt; 1)) {
modint<mod> zi = 1;
for(i64 j = 0;j &lt; s;j++) {
modint<mod> t = a[i + j] - a[s + i + j];
a[i + j] += a[s + i + j];
a[s + i + j] = t * zi;
zi = zi * zeta;
}
}
}
return a;
}</p>
<p>template&lt;const i64 mod, const i64 primitive&gt;
vector&lt;modint<mod>&gt; inverse_number_theoretic_transform(vector&lt;modint<mod>&gt; a) {
i64 n = a.size();
for(i64 s = 1; s &lt; n; s &lt;&lt;= 1) {
modint<mod> zeta = modint<mod>(primitive).pow((mod - 1) / (s &lt;&lt; 1)).pow(mod - 2);
for(i64 i = 0; i &lt; n; i += (s &lt;&lt; 1)) {
modint<mod> zi = 1;
for(i64 j = 0;j &lt; s;j++) {
modint<mod> t = a[s + i + j] * zi;
a[s + i + j] = a[i + j] - t;
a[i + j] = a[i + j] + t;
zi = zi * zeta;
}
}
}
auto inv_n = modint<mod>(n).pow(mod - 2);
for(int i = 0;i &lt; n;i++) a[i] *= inv_n;
return a;
}</p>
<p>template&lt;const i64 mod, const i64 primitive&gt;
struct fps_ntt_multiply {
using fps_type = modint<mod>;
using conv_type = modint<mod>;
static std::vector&lt;conv_type&gt; dft(std::vector&lt;fps_type&gt; arr) {
return number_theoretic_transform&lt;mod, primitive&gt;(std::move(arr));
}
static std::vector&lt;fps_type&gt; idft(std::vector&lt;conv_type&gt; arr) {
return inverse_number_theoretic_transform&lt;mod, primitive&gt;(std::move(arr));
}
static std::vector&lt;conv_type&gt; multiply(std::vector&lt;conv_type&gt; a, std::vector&lt;conv_type&gt; b) {
for(int i = 0;i &lt; a.size();i++) a[i] *= b[i];
return a;
}
};</p>
<p>struct FPS {
using T = modint&lt;998244353&gt;;
using fps_multiply = fps_ntt_multiply&lt;998244353, 3&gt;;
std::vector<T> coef;</p>
<p>FPS(const std::vector<T>&amp; arr): coef(arr) {
i64 n = 1;
i64 m = arr.size();
while(n &lt; m) n &lt;&lt;= 1;
coef.resize(n);
}
size_t size() const { return coef.size(); }
T operator[](int i) const {
if(i &lt; coef.size()) return coef[i];
else return T();
}
T &amp; operator[](int i) { return coef[i]; }
FPS pre(int n) const {
std::vector<T> nex(n);
for(int i = 0;i &lt; coef.size() &amp;&amp; i &lt; n; i++) nex[i] = coef[i];
return FPS(nex);
}</p>
<p>// F(0) must not be 0
FPS inv() const {
FPS g = FPS(std::vector<T>{ T(1) / (*this)[0] });
i64 n = this-&gt;size();
for(int i = 1;i &lt; n;i &lt;&lt;= 1) {
g = g.pre(i &lt;&lt; 1);
auto gdft = fps_multiply::dft(g.coef);
auto e = fps_multiply::idft(
fps_multiply::multiply(
fps_multiply::dft(this-&gt;pre(i &lt;&lt; 1).coef), gdft
)
);
for(int j = 0;j &lt; i;j++) {
e[j] = T(0);
e[j + i] = e[j + i] * T(-1);
}
auto f = fps_multiply::idft(
fps_multiply::multiply(
fps_multiply::dft(e), std::move(gdft)
)
);
for(int j = 0;j &lt; i;j++) {
f[j] = g[j];
}
g.coef = std::move(f);
}
return g.pre(n);
}</p>
<p>FPS diff() const {
FPS res(vector<T>(this-&gt;size() - 1, T(0)));
for(i64 i = 1;i &lt; this-&gt;size();i++) res[i - 1] = coef[i] * T(i);
return res;
}</p>
<p>FPS integral() const {
FPS res(vector<T>(this-&gt;size() + 1, T(0)));
for(i64 i = 0;i &lt; this-&gt;size();i++) res[i + 1] = coef[i] / T(i + 1);
return res;
}</p>
<p>// F(0) must be 0
FPS log() const {
return (this-&gt;diff() * this-&gt;inv()).integral().pre(this-&gt;size());
}</p>
<p>FPS exp() const {
FPS f(vector<T>{ T(1) });
FPS g = *this;
g[0] += T(1);
for(i64 i = 1;i &lt; size();i &lt;&lt;= 1 ) {
f = (f * (g.pre(i &lt;&lt; 1) - f.pre(i &lt;&lt; 1).log())).pre(i &lt;&lt; 1);
}
return f;
}</p>
<p>FPS operator+(const FPS&amp; rhs) {
i64 n = std::max(this-&gt;size(), rhs.size());
std::vector<T> ans(n);
for(int i = 0;i &lt; n;i++) ans[i] = (*this)[i] + rhs[i];
return FPS(ans);
}
FPS operator-(const FPS&amp; rhs) {
i64 n = std::max(this-&gt;size(), rhs.size());
std::vector<T> ans(n);
for(int i = 0;i &lt; n;i++) ans[i] = (<em>this)[i] - rhs[i];
return FPS(ans);
}
FPS operator</em>(const FPS&amp; rhs) {
i64 n = std::max(this-&gt;size(), rhs.size()) &lt;&lt; 1;
return fps_multiply::idft(
fps_multiply::multiply(
fps_multiply::dft(this-&gt;pre(n).coef), fps_multiply::dft(rhs.pre(n).coef)
)
);
}</p>
<p>};</p>
<h1><a class="header" href="#runtime-fp" id="runtime-fp">Runtime fp</a></h1>
<h1><a class="header" href="#convolution" id="convolution">Convolution</a></h1>
<p>畳み込み <a href="http://kazuma8128.hatenablog.com/entry/2018/07/29/231819">参考 - 約数集合でのゼータ変換・メビウス変換的なやつと畳み込み</a></p>
<h2><a class="header" href="#集合の畳み込みについて" id="集合の畳み込みについて">集合の畳み込みについて</a></h2>
<p>\(A \subseteq B\) のとき, \( B \)は\( A \)の上位集合という. また\( A \)は\( B \)の下位集合という.</p>
<p>上位集合について和を求める変換して互いをかけ合わせて逆変換をすると, 積集合(And)の個数が求められる.<br />
下位集合について和を求める変換して互いをかけ合わせて逆変換をすると, 和集合(Or)の個数が求められる.</p>
<p>例) <code>multiple_transform</code>(<code>i</code>について, <code>i</code>を約数に持つ<code>j</code>の<code>a[j]</code>の総和を求める --&gt; 上位集合)をして互いをかけ合わせて逆変換すると, 積集合(<code>gcd</code>についての畳み込み)がの個数が求められる.</p>
<h2><a class="header" href="#transforms" id="transforms">Transforms</a></h2>
<ul>
<li><a href="math/convolution/./multiple_transform.html">Multiple Transform</a></li>
<li><a href="math/convolution/./divisor_transform.html">Divisor Transform</a></li>
<li><a href="math/convolution/./fast_fourier_transform.html">Fast Fourier Transform</a></li>
<li><a href="math/convolution/./numeric_theoretic_transform.html">Number Theoretic Transform</a></li>
</ul>
<h1><a class="header" href="#multiple-transform" id="multiple-transform">Multiple Transform</a></h1>
<p>約数幇助と呼ばれる. <a href="http://noshi91.hatenablog.com/entry/2018/12/27/121649">参考 - 高速ゼータ変換の約数版</a></p>
<h3><a class="header" href="#spec-27" id="spec-27">Spec</a></h3>
<p><code>i</code>について, <code>i</code>を約数に持つ<code>j</code>(上位集合)の<code>a[j]</code>の総和を求める. \( O(N \log{\log N}) \).<br />
<code>inverse multiple transform</code>と共に使うと<code>gcd</code>に関する畳み込みができる. こんな感じ</p>
<p>\[ h(z) = \sum_{\gcd(x, y) = z} {f(x) * g(y)} \]</p>
<h3><a class="header" href="#code-29" id="code-29">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

template &lt;class T&gt;
void multiple_transform(vector&lt;T&gt; &amp;a) {
	int n = a.size();
	vector&lt;bool&gt; sieve(n, true);
	for (int p = 2; p &lt; n; ++p) {
		if (sieve[p]) {
			for (int k = (n - 1) / p; k != 0; --k) {
				sieve[k * p] = false;
				a[k] += a[k * p];
			}
		}
	}
	for (int i = 0; ++i != n;) {
		a[i] += a[0];
	}
}

template &lt;class T&gt;
void inverse_multiple_transform(vector&lt;T&gt; &amp;a) {
	int n = a.size();
	vector&lt;bool&gt; sieve(n, true);
	for (int i = 0; ++i != n;) {
		a[i] -= a[0];
	}
	for (int p = 2; p &lt; n; ++p) {
		if (sieve[p]) {
			for (int k = 1; k * p &lt; n; ++k) {
				sieve[k * p] = false;
				a[k] -= a[k * p];
			}
		}
	}
}
</code></pre>
<h1><a class="header" href="#divisor-transform" id="divisor-transform">Divisor Transform</a></h1>
<p>約数幇助と呼ばれる. <a href="http://noshi91.hatenablog.com/entry/2018/12/27/121649">参考 - 高速ゼータ変換の約数版</a></p>
<h3><a class="header" href="#spec-28" id="spec-28">Spec</a></h3>
<p><code>i</code>について, <code>i</code>の約数である<code>j</code>(下位集合)について<code>a[j]</code>の総和を求める. \( O(N \log{\log N}) \).<br />
<code>inverse divisor transform</code>と共に使うと<code>lcm</code>に関する畳み込みができる. こんな感じ</p>
<p>\[  h(z) = \sum_{ \operatorname{lcm} (x, y) = z } { f(x) * g(y) } \]</p>
<h3><a class="header" href="#code-30" id="code-30">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

template &lt;class T&gt;
void divisor_transform(vector&lt;T&gt; &amp;a) {
	int n = a.size();
	vector&lt;bool&gt; sieve(n, true);
	for (int p = 2; p &lt; n; ++p) {
		if (sieve[p]) {
			for (int k = 1; k * p &lt; n; ++k) {
				sieve[k * p] = false;
				a[k * p] += a[k];
			}
		}
	}
	for (int i = 0; ++i != n;) {
		a[i] += a[0];
	}
}

template &lt;class T&gt;
void inverse_divisor_transform(vector&lt;T&gt; &amp;a) {
	int n = a.size();
	vector&lt;bool&gt; sieve(n, true);
	for (int i = 0; ++i != n;) {
		a[i] -= a[0];
	}
	for (int p = 2; p &lt; n; ++p) {
		if (sieve[p]) {
			for (int k = (n - 1) / p; k != 0; --k) {
				sieve[k * p] = false;
				a[k * p] -= a[k];
			}
		}
	}
}

</code></pre>
<h1><a class="header" href="#fast-fourier-transform" id="fast-fourier-transform">Fast Fourier Transform</a></h1>
<h3><a class="header" href="#spec-29" id="spec-29">Spec</a></h3>
<p>離散フーリエ変換(discrete Fourier transformation)を\( O(n \log n) \)で行う.</p>
<p>誤差厳しい, 整数ならNTT使おう(誤差をなくすようにFFTするのもあるらしい)</p>
<h3><a class="header" href="#code-31" id="code-31">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;complex&gt;
using namespace std;
using i64 = long long;

const double pi = std::acos(-1);

vector&lt;complex&lt;double&gt;&gt; fast_fourier_transform(vector&lt;complex&lt;double&gt;&gt; a) {
  i64 n = a.size();
  for(i64 s = n &gt;&gt; 1; s &gt;= 1; s &gt;&gt;= 1) {
    complex&lt;double&gt; zeta = std::polar(1.0, 2 * pi / (double)(s &lt;&lt; 1));
    for(i64 i = 0;i &lt; n;i += (s &lt;&lt; 1)) {
      complex&lt;double&gt; zi = 1.0;
      for(i64 j = 0;j &lt; s;j++) {
        complex&lt;double&gt; t = a[i + j] - a[s + i + j];
        a[i + j] = a[i + j] + a[s + i + j];
        a[s + i + j] = t * zi;
        zi = zi * zeta;
      }
    }
  }
  return a;
}

vector&lt;complex&lt;double&gt;&gt; inverse_fast_fourier_transform(vector&lt;complex&lt;double&gt;&gt; a) {
  i64 n = a.size();
  for(i64 s = 1; s &lt; n; s &lt;&lt;= 1) {
    complex&lt;double&gt; zeta = std::polar(1.0, -1 * 2 * pi / (double)(s &lt;&lt; 1));
    for(i64 i = 0; i &lt; n; i += (s &lt;&lt; 1)) {
      complex&lt;double&gt; zi = 1;
      for(i64 j = 0;j &lt; s;j++) {
        complex&lt;double&gt; t = a[s + i + j] * zi;
        a[s + i + j] = a[i + j] - t;
        a[i + j] = a[i + j] + t;
        zi = zi * zeta;
      }
    }
  }
  i64 inv_n = 1 / (double)n;
  for(int i = 0;i &lt; n;i++) a[i] *= inv_n;
  return a;
}
</code></pre>
<h1><a class="header" href="#numeric-theoretic-transform" id="numeric-theoretic-transform">Numeric Theoretic Transform</a></h1>
<h3><a class="header" href="#spec-30" id="spec-30">Spec</a></h3>
<p>素数\( m = 2^k + 1, 2^k &gt;= n\)として\(F_m \)剰余環上での離散フーリエ変換(discrete Fourier transformation)を\( O(n \log n) \)で行う<br />
<code>NTT_PRIMES</code>は<a href="https://lumakernel.github.io/ecasdqina/math/FFT/NTT">るまライブラリ</a>からお借りしています</p>
<p>ほとんど単体でNTTを使うことはなさそう(FPSで使うね)</p>
<h3><a class="header" href="#code-32" id="code-32">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

template&lt;i64 M&gt;
struct modint {
  i64 a;
  constexpr modint(const i64 x = 0) noexcept: a((x % M + M) % M) {}
  constexpr i64 value() const noexcept { return a; }
  constexpr modint pow(i64 r) const noexcept {
    modint ans(1);
    modint aa = *this;
    while(r) {
      if(r &amp; 1) {
        ans *= aa;
      }
      aa *= aa;
      r &gt;&gt;= 1;
    }
    return ans;
  }
  constexpr modint&amp; operator+=(const modint r) noexcept {
    a += r.a;
    if(a &gt;= M) a -= M;
    return *this;
  }
  constexpr modint&amp; operator=(const i64 r) {
    a = (r % M + M) % M;
    return *this;
  }
  constexpr modint&amp; operator-=(const modint r) noexcept {
    a -= r.a;
    if(a &lt; 0) a += M;
    return *this;
  }
  constexpr modint&amp; operator*=(const modint r) noexcept {
    a = a * r.a % M;
    return *this;
  }
  constexpr modint&amp; operator/=(modint r) noexcept {
    i64 ex = M - 2;
    while(ex) {
      if(ex &amp; 1) {
        *this *= r;
      }
      r *= r;
      ex &gt;&gt;= 1;
    }
    return *this;
  }

  constexpr modint operator+(const modint r) const {
    return modint(*this) += r;
  }
  constexpr modint operator-(const modint r) const {
    return modint(*this) -= r;
  }
  constexpr modint operator*(const modint r) const {
    return modint(*this) *= r;
  }
  constexpr modint operator/(const modint r) const {
    return modint(*this) /= r;
  }
};

constexpr i64 NTT_PRIMES[][2] = {
    {1224736769, 3}, // 2^24 * 73 + 1,
    {1053818881, 7}, // 2^20 * 3 * 5 * 67 + 1
    {1051721729, 6}, // 2^20 * 17 * 59 + 1
    {1045430273, 3}, // 2^20 * 997 + 1
    {1012924417, 5}, // 2^21 * 3 * 7 * 23 + 1
    {1007681537, 3}, // 2^20 * 31^2 + 1
    {1004535809, 3}, // 2^21 * 479 + 1
    {998244353, 3},  // 2^23 * 7 * 17 + 1
    {985661441, 3},  // 2^22 * 5 * 47 + 1
    {976224257, 3},  // 2^20 * 7^2 * 19 + 1
    {975175681, 17}, // 2^21 * 3 * 5 * 31 + 1
    {962592769, 7},  // 2^21 * 3^3 * 17 + 1
    {950009857, 7},  // 2^21 * 4 * 151 + 1
    {943718401, 7},  // 2^22 * 3^2 * 5^2 + 1
    {935329793, 3},  // 2^22 * 223 + 1
    {924844033, 5},  // 2^21 * 3^2 * 7^2 + 1
    {469762049, 3},  // 2^26 * 7 + 1
    {167772161, 3},  // 2^25 * 5 + 1
};

template&lt;const i64 mod, const i64 primitive&gt;
vector&lt;modint&lt;mod&gt;&gt; number_theoretic_transform(vector&lt;modint&lt;mod&gt;&gt; a) {
  i64 n = a.size();
  for(i64 s = n &gt;&gt; 1; s &gt;= 1; s &gt;&gt;= 1) {
    modint&lt;mod&gt; zeta = modint&lt;mod&gt;(primitive).pow((mod - 1) / (s &lt;&lt; 1));
    for(i64 i = 0; i &lt; n; i += (s &lt;&lt; 1)) {
      modint&lt;mod&gt; zi = 1;
      for(i64 j = 0;j &lt; s;j++) {
        modint&lt;mod&gt; t = a[i + j] - a[s + i + j];
        a[i + j] += a[s + i + j];
        a[s + i + j] = t * zi;
        zi = zi * zeta;
      }
    }
  }
  return a;
}

template&lt;const i64 mod, const i64 primitive&gt;
vector&lt;modint&lt;mod&gt;&gt; inverse_number_theoretic_transform(vector&lt;modint&lt;mod&gt;&gt; a) {
  i64 n = a.size();
  for(i64 s = 1; s &lt; n; s &lt;&lt;= 1) {
    modint&lt;mod&gt; zeta = modint&lt;mod&gt;(primitive).pow((mod - 1) / (s &lt;&lt; 1)).pow(mod - 2);
    for(i64 i = 0; i &lt; n; i += (s &lt;&lt; 1)) {
      modint&lt;mod&gt; zi = 1;
      for(i64 j = 0;j &lt; s;j++) {
        modint&lt;mod&gt; t = a[s + i + j] * zi;
        a[s + i + j] = a[i + j] - t;
        a[i + j] = a[i + j] + t;
        zi = zi * zeta;
      }
    }
  }
  auto inv_n = modint&lt;mod&gt;(n).pow(mod - 2);
  for(int i = 0;i &lt; n;i++) a[i] *= inv_n;
  return a;
}
</code></pre>
<h1><a class="header" href="#string" id="string">String</a></h1>
<p><a href="https://snuke.hatenablog.com/entry/2014/12/01/235807">文字列の頭良い感じの線形アルゴリズムたち</a></p>
<ul>
<li><a href="string/./manacher.html">Manacher</a> \</li>
<li><a href="string/./mp.html">MP (Morris Pratt)</a></li>
<li><a href="string/./rolling_hash.html">Rolling Hash</a> \</li>
<li><a href="string/./suffix_array.html">Suffix Array</a> \</li>
<li><a href="string/./Z-algorithm.html">Z-algorithm</a> \</li>
</ul>
<h1><a class="header" href="#manacher" id="manacher">Manacher</a></h1>
<h2><a class="header" href="#code-33" id="code-33">Code</a></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

/*
 * 文字 i を中心とする最長の回文の半径 = (全長 + 1) / 2
 */

vector&lt;i64&gt; manacher(string S) {
  vector&lt;i64&gt; R(S.size());
  int i = 0, j = 0;
  while (i &lt; S.size()) {
    while (i-j &gt;= 0 &amp;&amp; i+j &lt; S.size() &amp;&amp; S[i-j] == S[i+j]) ++j;
    R[i] = j;
    int k = 1;
    while (i-k &gt;= 0 &amp;&amp; i+k &lt; S.size() &amp;&amp; k+R[i-k] &lt; j) R[i+k] = R[i-k], ++k;
    i += k; j -= k;
  }
  return R;
}
</code></pre>
<h1><a class="header" href="#mp-morris-pratt" id="mp-morris-pratt">MP (Morris Pratt)</a></h1>
<p><a href="https://snuke.hatenablog.com/entry/2014/12/01/235807">文字列の頭良い感じの線形アルゴリズムたち</a></p>
<h3><a class="header" href="#spec-31" id="spec-31">Spec</a></h3>
<p>文字列S[0, i-1]のprefixとsuffixが最大何文字一致しているかを \( O(|S|) \)で求める.</p>
<h4><a class="header" href="#example" id="example">Example</a></h4>
<pre><code>aabaabaaa
_010123452
</code></pre>
<h3><a class="header" href="#code-34" id="code-34">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

/*
 * 文字列S[0, i-1]のprefixとsuffixが最大何文字一致しているか
 */

vector&lt;i64&gt; mp(string S) {
  vector&lt;i64&gt; A(S.size() + 1);
  A[0] = -1;
  int j = -1;
  for (int i = 0; i &lt; S.size(); i++) {
    while (j &gt;= 0 &amp;&amp; S[i] != S[j]) j = A[j];
    j++;
    A[i+1] = j;
  }
  return A;
}

</code></pre>
<h1><a class="header" href="#rolling-hash" id="rolling-hash">Rolling Hash</a></h1>
<h2><a class="header" href="#code-35" id="code-35">Code</a></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

const i64 rhmod = 1e9 + 7;
const i64 BASE_C = 2;
const i64 base[] = {9973, 10007};

struct rolling_hash {
  i64 n;
  vector&lt;i64&gt; hs[BASE_C], pw[BASE_C];
  
  template&lt;class Array&gt;
  rolling_hash(const Array&amp; arr) {
    n = arr.size();
    for(int i = 0;i &lt; BASE_C;i++) {
      hs[i].assign(n + 1, 0);
      pw[i].assign(n + 1, 0);
      hs[i][0] = 0;
      pw[i][0] = 1;
      for(int j = 0;j &lt; n;j++) {
        pw[i][j + 1] = pw[i][j] * base[i] % rhmod;
        hs[i][j + 1] = (hs[i][j] * base[i] + arr[j]) % rhmod;
      }
    }
  }

  pair&lt;i64, i64&gt; hash(i64 l, i64 r) {
    return {
      ((hs[0][r + 1] - hs[0][l] * pw[0][r + 1 - l]) % rhmod + rhmod) % rhmod,
      ((hs[1][r + 1] - hs[1][l] * pw[1][r + 1 - l]) % rhmod + rhmod) % rhmod,
    };
  }
};
</code></pre>
<h1><a class="header" href="#suffix-array" id="suffix-array">Suffix Array</a></h1>
<h2><a class="header" href="#code-36" id="code-36">Code</a></h2>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;

template&lt;class T&gt;
const std::vector&lt;int&gt;&amp; sa_is(std::vector&lt;T&gt; s, int k) {
  int N = s.size();
  static std::vector&lt;int&gt; sa;
  static std::vector&lt;int&gt; cnt;
  sa.resize(N + 1);

  if(N == 0) return sa;

  for(auto&amp; c: s) c++;
  s.push_back(0);
  k++;

  std::vector&lt;bool&gt; iss(N + 1);
  std::vector&lt;int&gt; lms;
  std::vector&lt;int&gt; is_lms(N + 1, -1);
  std::vector&lt;int&gt; bin(k + 1);

  iss[N] = true;
  bin[1]++;
  for(int i = N; i --&gt; 0; ) {
    if(s[i] == s[i + 1])
      iss[i] = iss[i + 1];
    else
      iss[i] = s[i] &lt; s[i + 1];
    if(!iss[i] &amp;&amp; iss[i + 1]) {
      is_lms[i + 1] = lms.size();
      lms.push_back(i + 1);
    }
    bin[s[i] + 1]++;
  }

  for(int i = 1;i &lt;= k;i++)
    bin[i] += bin[i - 1];

  auto induce = [&amp;](const std::vector&lt;int&gt;&amp; lms) {
    sa.assign(N + 1, -1);
    cnt.assign(k, 0);

    for(int i = 0;i &lt; lms.size();i++) {
      int x = lms[i];
      sa[bin[s[x] + 1] - 1 - cnt[s[x]]] = x;
      cnt[s[x]]++;
    }

    cnt.assign(k, 0);
    for(int i = 0;i &lt;= N;i++) {
      int x = sa[i] - 1;
      if(x &gt;= 0 &amp;&amp; !iss[x]) {
        sa[bin[s[x]] + cnt[s[x]]] = x;
        cnt[s[x]]++;
      }
    }

    cnt.assign(k, 0);
    for(int i = N + 1;i --&gt; 0;) {
      int x = sa[i] - 1;
      if(x &gt;= 0 &amp;&amp; iss[x]) {
        sa[bin[s[x] + 1] - 1 - cnt[s[x]]] = x;
        cnt[s[x]]++;
      }
    }
  };

  induce(lms);


  if(lms.size() &gt;= 2) {
    int M = lms.size();
    int li = 0;
    std::vector&lt;int&gt; rec_lms(M);
    for(auto x: sa) {
      if(is_lms[x] != -1) rec_lms[li++] = x;
    }
    int rec_n = 1;
    std::vector&lt;int&gt; rec_s(M);
    rec_s[M - 1 - is_lms[rec_lms[1]]] = 1;
    for(int i = 2;i &lt; M;i++) {
      int xl = rec_lms[i];
      int yl = rec_lms[i - 1];
      int xr = lms[is_lms[xl] - 1];
      int yr = lms[is_lms[yl] - 1];
      if(xr - xl != yr - yl)
        rec_n++;
      else {
        while(xl &lt;= xr) {
          if(s[xl] != s[yl]) {
            rec_n++;
            break;
          }
          xl++;
          yl++;
        }
      }
      rec_s[M - 1 - is_lms[rec_lms[i]]] = rec_n;
    }


    sa_is(std::move(rec_s), rec_n + 1);
    li = M;
    for(int i = 1;i &lt; M + 1;i++) {
      rec_lms[--li] = lms[M - 1 - sa[i]];
    }
    induce(rec_lms);
  }

  return sa;
}
</code></pre>
<h1><a class="header" href="#z-algorithm" id="z-algorithm">Z-algorithm</a></h1>
<h2><a class="header" href="#code-37" id="code-37">Code</a></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

vector&lt;i64&gt; z_algorithm(string S) {
  vector&lt;i64&gt; A(S.size());
  A[0] = S.size();
  int i = 1, j = 0;
  while (i &lt; S.size()) {
    while (i+j &lt; S.size() &amp;&amp; S[j] == S[i+j]) ++j;
    A[i] = j;
    if (j == 0) { ++i; continue;}
    int k = 1;
    while (i+k &lt; S.size() &amp;&amp; k+A[k] &lt; j) A[i+k] = A[k], ++k;
    i += k; j -= k;
  }
  return A;
}
</code></pre>
<h1><a class="header" href="#burrows-wheeler" id="burrows-wheeler">Burrows Wheeler</a></h1>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;

template&lt;class T&gt;
const std::vector&lt;int&gt;&amp; sa_is(std::vector&lt;T&gt; s, int k) {
  int N = s.size();
  static std::vector&lt;int&gt; sa;
  static std::vector&lt;int&gt; cnt;
  sa.resize(N + 1);

  if(N == 0) return sa;

  for(auto&amp; c: s) c++;
  s.push_back(0);
  k++;

  std::vector&lt;bool&gt; iss(N + 1);
  std::vector&lt;int&gt; lms;
  std::vector&lt;int&gt; is_lms(N + 1, -1);
  std::vector&lt;int&gt; bin(k + 1);

  iss[N] = true;
  bin[1]++;
  for(int i = N; i --&gt; 0; ) {
    if(s[i] == s[i + 1])
      iss[i] = iss[i + 1];
    else
      iss[i] = s[i] &lt; s[i + 1];
    if(!iss[i] &amp;&amp; iss[i + 1]) {
      is_lms[i + 1] = lms.size();
      lms.push_back(i + 1);
    }
    bin[s[i] + 1]++;
  }

  for(int i = 1;i &lt;= k;i++)
    bin[i] += bin[i - 1];

  auto induce = [&amp;](const std::vector&lt;int&gt;&amp; lms) {
    sa.assign(N + 1, -1);
    cnt.assign(k, 0);

    for(int i = 0;i &lt; lms.size();i++) {
      int x = lms[i];
      sa[bin[s[x] + 1] - 1 - cnt[s[x]]] = x;
      cnt[s[x]]++;
    }

    cnt.assign(k, 0);
    for(int i = 0;i &lt;= N;i++) {
      int x = sa[i] - 1;
      if(x &gt;= 0 &amp;&amp; !iss[x]) {
        sa[bin[s[x]] + cnt[s[x]]] = x;
        cnt[s[x]]++;
      }
    }

    cnt.assign(k, 0);
    for(int i = N + 1;i --&gt; 0;) {
      int x = sa[i] - 1;
      if(x &gt;= 0 &amp;&amp; iss[x]) {
        sa[bin[s[x] + 1] - 1 - cnt[s[x]]] = x;
        cnt[s[x]]++;
      }
    }
  };

  induce(lms);


  if(lms.size() &gt;= 2) {
    int M = lms.size();
    int li = 0;
    std::vector&lt;int&gt; rec_lms(M);
    for(auto x: sa) {
      if(is_lms[x] != -1) rec_lms[li++] = x;
    }
    int rec_n = 1;
    std::vector&lt;int&gt; rec_s(M);
    rec_s[M - 1 - is_lms[rec_lms[1]]] = 1;
    for(int i = 2;i &lt; M;i++) {
      int xl = rec_lms[i];
      int yl = rec_lms[i - 1];
      int xr = lms[is_lms[xl] - 1];
      int yr = lms[is_lms[yl] - 1];
      if(xr - xl != yr - yl)
        rec_n++;
      else {
        while(xl &lt;= xr) {
          if(s[xl] != s[yl]) {
            rec_n++;
            break;
          }
          xl++;
          yl++;
        }
      }
      rec_s[M - 1 - is_lms[rec_lms[i]]] = rec_n;
    }


    sa_is(std::move(rec_s), rec_n + 1);
    li = M;
    for(int i = 1;i &lt; M + 1;i++) {
      rec_lms[--li] = lms[M - 1 - sa[i]];
    }
    induce(rec_lms);
  }

  return sa;
}

#include &lt;cstdint&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

using i64 = long long;

class bitvector {
  using bit_type = std::uint_least64_t;
  using size_type = std::size_t;
  static constexpr size_type wordsize = 64;
  
  std::vector&lt;bit_type&gt; bit;
  std::vector&lt;size_type&gt; sum;
  
public:

  bitvector() : bit(), sum() {} 
  bitvector(const size_type size)
    : bit(size / wordsize + 1, 0), sum(size / wordsize + 1, 0) {}

  void set(const size_type i) {
    bit[i / wordsize] |= static_cast&lt;bit_type&gt;(1) &lt;&lt; (i % wordsize);
  }
  void build() {
    for (size_type i = 1; i &lt; bit.size(); i++) {
      sum[i] = sum[i - 1] + __builtin_popcountll(bit[i - 1]);
    }
  }

  size_type at(const size_type i) const {
    return bit[i / wordsize] &gt;&gt; (i % wordsize);
  }

  // count of ones in [0, i)
  size_type rank(const size_type i) const {
    return sum[i / wordsize]
      + __builtin_popcountll(bit[i / wordsize] &amp; (static_cast&lt;bit_type&gt;(1) &lt;&lt; (i % wordsize)) - 1);
  }

  // count of ones in [0, i)
  size_type rank(const size_type i, const size_type b) const {
    size_type ans = sum[i / wordsize]
      + __builtin_popcountll(bit[i / wordsize] &amp; (static_cast&lt;bit_type&gt;(1) &lt;&lt; (i % wordsize)) - 1);
    if(b) return ans;
    else return i - ans;
  }
};

template&lt;class T&gt;
class wavelet_matrix {
  using Integer = T;
  using integer_type = Integer;
  using size_type = std::size_t;


  size_type depth;
  size_type len;
  std::vector&lt;bitvector&gt; mat;
  std::vector&lt;size_type&gt; spl;

public:

  wavelet_matrix(): depth(0), len(0) {}
  wavelet_matrix(const std::vector&lt;integer_type&gt;&amp; arr, size_type de)
    : depth(de),
      len(arr.size()),
      mat(std::vector&lt;bitvector&gt;(depth, bitvector(arr.size()))),
      spl(std::vector&lt;size_type&gt;(depth, 0)) {
        std::vector&lt;size_type&gt; idx(len);
        std::vector&lt;size_type&gt; left(len), right(len);
        for(size_type i = 0;i &lt; len;i++) idx[i] = i;
        for(size_type d = depth; d-- &gt; 0;) {
          size_type l = 0, r = 0;
          
          for(size_type i = 0; i &lt; len; i++) {
            size_type k = (arr[idx[i]] &gt;&gt; d) &amp; 1;
            if(k) right[r++] = idx[i], mat[d].set(i);
            else left[l++] = idx[i];
          }
          mat[d].build();
          spl[d] = l;
          swap(idx, left);
          for(size_type i = 0; i &lt; r; i++) idx[i + l] = right[i];
        }
      }

  integer_type at(size_type i) const {
    integer_type x = static_cast&lt;integer_type&gt;(0);
    for(size_type d = depth; d-- &gt; 0;) {
      size_type k = mat[d].at(i);
      x |= (static_cast&lt;integer_type&gt;(k) &lt;&lt; d);
      i = mat[d].rank(i, k) + spl[d] * k;
    }
    return x;
  }

  // counting elements that equal to x in range [left, right)
  size_type rank_x(size_type left, size_type right, integer_type x) const {
    for(size_type d = depth; d-- &gt; 0;) {
      size_type k = ((x &gt;&gt; d) &amp; 1);
      if(k) {
        left = mat[d].rank(left, k) + spl[d];
        right = mat[d].rank(right, k) + spl[d];
      }
      else {
        left = mat[d].rank(left, k);
        right = mat[d].rank(right, k);
      }
    }
    return right - left;
  }

  // sorted(arr[left..right])[i]
  integer_type quantile(size_type left, size_type right, size_type i) const {
    integer_type x = static_cast&lt;integer_type&gt;(0);
    for(size_type d = depth; d-- &gt; 0;) {
      size_type cnt = mat[d].rank(right, 0) - mat[d].rank(left, 0);
      size_type k = (i &lt; cnt) ? 0 : 1;
      x |= (k &lt;&lt; d);
      left = mat[d].rank(left, k) + spl[d] * k;
      right = mat[d].rank(right, k) + spl[d] * k;
    }
    return x;
  }

  struct rank_result {
    size_type le;
    size_type eq;
    size_type mo;
  };

  // couting elements that less than x, equal to x, and more than x in range [left, right)
  rank_result rank_less_eq_more(size_type left, size_type right, integer_type x) const {
    size_type le = 0, mo = 0;
    for(size_type d = depth; d --&gt; 0;) {
      size_type k = (x &gt;&gt; d) &amp; 1;
      size_type l = mat[d].rank(left, 1);
      size_type r = mat[d].rank(right, 1);
      if(k == 0) {
        mo += r - l;
        left -= l;
        right -= r;
      }
      else {
        le += (right - left) - (r - l);
        left = l + spl[d];
        right = r + spl[d];
      }
    }
    return rank_result { le, right - left, mo };
  }

  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y, integer_type l, size_type d) const {
    integer_type r = l + (1 &lt;&lt; d);
    if(x &lt;= l &amp;&amp; r &lt;= y) {
      return right - left;
    }
    else if(y &lt;= l || r &lt;= x) {
      return 0;
    }
    else {
      d--;
      size_type lr = mat[d].rank(left, 1);
      size_type rr = mat[d].rank(right, 1);
      return
        rangefreq(left - lr, right - rr, x, y, l, d) +
        rangefreq(lr + spl[d], rr + spl[d], x, y, l + (1 &lt;&lt; d), d);
    }
  }

  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y) const {
    return rangefreq(left, right, x, y, 0, depth);
  }
};

template&lt;class T&gt;
struct burrows_wheeler {
  std::vector&lt;int&gt; sa;
  std::vector&lt;T&gt; L;
  std::vector&lt;int&gt; C;
  wavelet_matrix&lt;T&gt; wm;
  burrows_wheeler(const std::vector&lt;T&gt;&amp; s, int k, int de): sa(sa_is(s, k)), L(s.size() + 1), C(k + 1) {
    for(int i = 0;i &lt; sa.size();i++) {
      if(sa[i] &gt; 0) L[i] = s[sa[i] - 1];
      else L[i] = 0;
    }
    for(int i = 0;i &lt; s.size();i++) {
      C[s[i] + 1]++;
    }
    C[0]++;
    for(int i = 0; i &lt; k; i++) {
      C[i + 1] += C[i];
    }
    wm = wavelet_matrix&lt;T&gt;(L, de);
  }
  int match(const std::string&amp; p) {
    int s = 0;
    int e = sa.size();
    for(int i = p.size();i --&gt; 0;) {
      s = wm.rank_x(0, s, p[i]) + C[p[i]];
      e = wm.rank_x(0, e, p[i]) + C[p[i]];
      if(s &gt;= e) break;
    }
    return e - s;
  }
};
</code></pre>
<h1><a class="header" href="#graph" id="graph">Graph</a></h1>
<ul>
<li><a href="graph/./low_link.html">Low Link</a> \</li>
<li><a href="graph/./strongly_connected_components.html">Strongly Connected Components</a> \</li>
<li><a href="graph/./two_edge_connected.html">Two Edge Connected</a> \</li>
<li><a href="graph/./two_vertex_connected.html">Two Vertex Connected</a> \</li>
</ul>
<h1><a class="header" href="#dinic" id="dinic">Dinic</a></h1>
<h2><a class="header" href="#code-38" id="code-38">Code</a></h2>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

struct edge_base {
  int from;
  int to;
};

template&lt;class E&gt;
struct graph_base {
  virtual void add_edge(E e) = 0;
  virtual const vector&lt;E&gt;&amp; operator[](int i) const = 0;
  virtual int N() const = 0;
};

template&lt;class E&gt;
struct graph : graph_base&lt;E&gt; {
  vector&lt;vector&lt;E&gt;&gt; G;
  graph(int n) : G(n) {}
  void add_edge(E e) {
    G[e.from].push_back(e);
  }
  const vector&lt;E&gt;&amp; operator[](int i) const { return G[i]; }
  vector&lt;E&gt;&amp; operator[](int i) { return G[i]; }
  int N() const { return G.size(); }
};

template&lt;class C&gt;
struct net_edge : edge_base {
  C cap;
  int rev;
  net_edge(int f,int t,C c,int r) {
    from = f;
    to = t;
    cap = c;
    rev = r;
  }
};

template&lt;class C&gt;
struct network : public graph&lt;net_edge&lt;C&gt;&gt; {
  const int s;
  const int t;
  template&lt;class E, class CF&gt;
  network(const graph&lt;E&gt;&amp; g,int s,int t, CF f) : graph&lt;net_edge&lt;C&gt;&gt;(g.N()), s(s) ,t(t) {
    for(int i = 0;i &lt; g.N();i++) {
      for(auto&amp; e : g[i]) {
        this-&gt;add_edge(net_edge&lt;C&gt;(e.from,e.to,f(e),this-&gt;G[e.to].size()));
        this-&gt;add_edge(net_edge&lt;C&gt;(e.to,e.from,C(),this-&gt;G[e.from].size() - 1));
      }
    }
  }
};

template&lt;class C&gt;
C dinic_dfs(int v, network&lt;C&gt;&amp; net, const vector&lt;int&gt;&amp; level, C f, vector&lt;int&gt; iter) {
  if(v == net.t) return f;
  else {
    C now = f;
    for(int&amp; i = iter[v]; i &lt; net[v].size(); i++) {
      auto&amp; e = net[v][i];
      if(e.cap &gt; C() &amp;&amp; level[e.to] &gt; level[e.from]) {
        C c = min(now , e.cap);
        C d = dinic_dfs(e.to,net,level,c);
        e.cap -= d;
        net[e.to][e.rev] += d;
        now -= d;
        if(now == 0) return f - now;
      }
    }
    return f - now;
  }
}

template&lt;class C&gt;
C dinic_Mflow(network&lt;C&gt;&amp; net){
  C ans = C();
  C inf = C();
  int s = net.s;
  int t = net.t;
  int n = net.N();
  for(auto&amp; e : net[s]) {
    inf += e.cap;
  }
  while(1) {
    queue&lt;int&gt; que;
    vector&lt;int&gt; level(n,-1);
    que.push(s);
    level[s] = 0;
    while(!que.empty()) {
      int v = que.front();
      que.pop();
      for(auto&amp; e : net[v]) {
        if(e.cap &gt; C() &amp;&amp; level[e.to] == -1) {
          level[e.to] = level[e.from] + 1;
          que.push(e.to);
        }
      }
    }
    if(level[t] &lt; 0) break;
    C f;
    while((f = dinic_dfs(s,net,level,inf)) &gt; C()) {
      ans += f;
    }
  }
  return ans;
}
</code></pre>
<h1><a class="header" href="#dinic-1" id="dinic-1">Dinic</a></h1>
<h2><a class="header" href="#code-39" id="code-39">Code</a></h2>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

struct edge_base {
  int from;
  int to;
};

template&lt;class E&gt;
struct graph_base {
  virtual void add_edge(E e) = 0;
  virtual const vector&lt;E&gt;&amp; operator[](int i) const = 0;
  virtual int N() const = 0;
};

template&lt;class E&gt;
struct graph : graph_base&lt;E&gt; {
  vector&lt;vector&lt;E&gt;&gt; G;
  graph(int n) : G(n) {}
  void add_edge(E e) {
    G[e.from].push_back(e);
  }
  const vector&lt;E&gt;&amp; operator[](int i) const { return G[i]; }
  vector&lt;E&gt;&amp; operator[](int i) { return G[i]; }
  int N() const { return G.size(); }
};

template&lt;class C&gt;
struct net_edge : edge_base {
  C cap;
  int rev;
  net_edge(int f,int t,C c,int r) {
    from = f;
    to = t;
    cap = c;
    rev = r;
  }
};

template&lt;class C&gt;
struct network : public graph&lt;net_edge&lt;C&gt;&gt; {
  const int s;
  const int t;
  template&lt;class E, class CF&gt;
  network(const graph&lt;E&gt;&amp; g,int s,int t, CF f) : graph&lt;net_edge&lt;C&gt;&gt;(g.N()), s(s) ,t(t) {
    for(int i = 0;i &lt; g.N();i++) {
      for(auto&amp; e : g[i]) {
        this-&gt;add_edge(net_edge&lt;C&gt;(e.from,e.to,f(e),this-&gt;G[e.to].size()));
        this-&gt;add_edge(net_edge&lt;C&gt;(e.to,e.from,C(),this-&gt;G[e.from].size() - 1));
      }
    }
  }
};

template&lt;class C&gt;
C dinic_dfs(int v, network&lt;C&gt;&amp; net, const vector&lt;int&gt;&amp; level, C f, vector&lt;int&gt; iter) {
  if(v == net.t) return f;
  else {
    C now = f;
    for(int&amp; i = iter[v]; i &lt; net[v].size(); i++) {
      auto&amp; e = net[v][i];
      if(e.cap &gt; C() &amp;&amp; level[e.to] &gt; level[e.from]) {
        C c = min(now , e.cap);
        C d = dinic_dfs(e.to,net,level,c);
        e.cap -= d;
        net[e.to][e.rev] += d;
        now -= d;
        if(now == 0) return f - now;
      }
    }
    return f - now;
  }
}

template&lt;class C&gt;
C dinic_Mflow(network&lt;C&gt;&amp; net){
  C ans = C();
  C inf = C();
  int s = net.s;
  int t = net.t;
  int n = net.N();
  for(auto&amp; e : net[s]) {
    inf += e.cap;
  }
  while(1) {
    queue&lt;int&gt; que;
    vector&lt;int&gt; level(n,-1);
    que.push(s);
    level[s] = 0;
    while(!que.empty()) {
      int v = que.front();
      que.pop();
      for(auto&amp; e : net[v]) {
        if(e.cap &gt; C() &amp;&amp; level[e.to] == -1) {
          level[e.to] = level[e.from] + 1;
          que.push(e.to);
        }
      }
    }
    if(level[t] &lt; 0) break;
    C f;
    while((f = dinic_dfs(s,net,level,inf)) &gt; C()) {
      ans += f;
    }
  }
  return ans;
}
</code></pre>
<h1><a class="header" href="#successive-shortest-path" id="successive-shortest-path">Successive Shortest Path</a></h1>
<h2><a class="header" href="#code-40" id="code-40">Code</a></h2>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
using namespace std;

struct edge_base { int from; int to;
}; template&lt;class E&gt;
struct graph_base {
  virtual void add_edge(E e) = 0;
  virtual const vector&lt;E&gt;&amp; operator[](int i) const = 0;
  virtual int N() const = 0;
};

template&lt;class E&gt;
struct graph : graph_base&lt;E&gt; {
  vector&lt;vector&lt;E&gt;&gt; G;
  graph(int n) : G(n) {}
  void add_edge(E e) {
    G[e.from].push_back(e);
  }
  const vector&lt;E&gt;&amp; operator[](int i) const { return G[i]; }
  vector&lt;E&gt;&amp; operator[](int i) { return G[i]; }
  int N() const { return G.size(); }
};

template&lt;class C&gt;
struct net_cost_edge : edge_base {
  C cap;
  C cost;
  int rev;
  net_cost_edge(int f,int t,C c,C w,int r) {
    from = f;
    to = t;
    cap = c;
    cost = w;
    rev = r;
  }
};

template&lt;class C&gt;
struct network_cost : public graph&lt;net_cost_edge&lt;C&gt;&gt; {
  const int s;
  const int t;
  template&lt;class E, class F, class CF&gt;
  network_cost(const graph&lt;E&gt;&amp; g,int s,int t, F f,CF cost) : graph&lt;net_cost_edge&lt;C&gt;&gt;(g.N()), s(s) ,t(t) {
    for(int i = 0;i &lt; g.N();i++) {
      for(auto&amp; e : g[i]) {
        this-&gt;add_edge(net_cost_edge&lt;C&gt;(e.from,e.to,f(e),cost(e),this-&gt;G[e.to].size()));
        this-&gt;add_edge(net_cost_edge&lt;C&gt;(e.to,e.from,C(),-cost(e),this-&gt;G[e.from].size() - 1));
      }
    }
  }
};

template&lt;class C&gt;
pair&lt;bool,C&gt; primal_dual_mcf(network_cost&lt;C&gt;&amp; g, C f) {
  int s = g.s;
  int t = g.t;
  int n = g.N();
  vector&lt;C&gt; po(n,C());
  C ans = C();
  auto sel = [&amp;](net_cost_edge&lt;C&gt; e) {
    return e.cost + po[e.from] - po[e.to];
  };
  while(f &gt; 0) {
    vector&lt;C&gt; dist(n,C());
    vector&lt;bool&gt; vis(n,false);
    vector&lt;int&gt; p(n,-1);
    vector&lt;int&gt; pe(n,-1);
    using P = pair&lt;C,int&gt;;
    priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt;&gt; que;
    que.push({dist[s] ,s});
    vis[s] = true;
    while(!que.empty()) {
      int v = que.top().second;
      C d = que.top().first;
      que.pop();
      if(dist[v] &lt; d) continue;
      for(int i = 0;i &lt; g[v].size();i++) {
        auto&amp; e = g[v][i];
        int u = e.to;
        if(e.cap == C()) continue;
        if(!vis[u] || dist[u] &gt; dist[v] + sel(e)) {
          vis[u] = true;
          dist[u] = dist[v] + sel(e);
          p[u] = v;
          pe[u] = i;
          que.push({dist[u] , u});
        }
      }
    }
    if(p[t] == -1) break;

    C ff = f;
    for(int u = t;u != s;u = p[u])
      ff = min(ff, g[p[u]][pe[u]].cap);
    for(int u = t;u != s;u = p[u]) {
      ans += ff * g[p[u]][pe[u]].cost;
      g[p[u]][pe[u]].cap -= ff;
      g[u][g[p[u]][pe[u]].rev].cap += ff;
    }
    f -= ff;
    for(int i = 0;i &lt; n;i++)
      po[i] += dist[i];
  }
  if(f != C()) return {false,C()};
  return {true ,ans };
}
</code></pre>
<h1><a class="header" href="#successive-shortest-path-1" id="successive-shortest-path-1">Successive Shortest Path</a></h1>
<h2><a class="header" href="#code-41" id="code-41">Code</a></h2>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
using namespace std;

struct edge_base { int from; int to;
}; template&lt;class E&gt;
struct graph_base {
  virtual void add_edge(E e) = 0;
  virtual const vector&lt;E&gt;&amp; operator[](int i) const = 0;
  virtual int N() const = 0;
};

template&lt;class E&gt;
struct graph : graph_base&lt;E&gt; {
  vector&lt;vector&lt;E&gt;&gt; G;
  graph(int n) : G(n) {}
  void add_edge(E e) {
    G[e.from].push_back(e);
  }
  const vector&lt;E&gt;&amp; operator[](int i) const { return G[i]; }
  vector&lt;E&gt;&amp; operator[](int i) { return G[i]; }
  int N() const { return G.size(); }
};

template&lt;class C&gt;
struct net_cost_edge : edge_base {
  C cap;
  C cost;
  int rev;
  net_cost_edge(int f,int t,C c,C w,int r) {
    from = f;
    to = t;
    cap = c;
    cost = w;
    rev = r;
  }
};

template&lt;class C&gt;
struct network_cost : public graph&lt;net_cost_edge&lt;C&gt;&gt; {
  const int s;
  const int t;
  template&lt;class E, class F, class CF&gt;
  network_cost(const graph&lt;E&gt;&amp; g,int s,int t, F f,CF cost) : graph&lt;net_cost_edge&lt;C&gt;&gt;(g.N()), s(s) ,t(t) {
    for(int i = 0;i &lt; g.N();i++) {
      for(auto&amp; e : g[i]) {
        this-&gt;add_edge(net_cost_edge&lt;C&gt;(e.from,e.to,f(e),cost(e),this-&gt;G[e.to].size()));
        this-&gt;add_edge(net_cost_edge&lt;C&gt;(e.to,e.from,C(),-cost(e),this-&gt;G[e.from].size() - 1));
      }
    }
  }
};

template&lt;class C&gt;
pair&lt;bool,C&gt; primal_dual_mcf(network_cost&lt;C&gt;&amp; g, C f) {
  int s = g.s;
  int t = g.t;
  int n = g.N();
  vector&lt;C&gt; po(n,C());
  C ans = C();
  auto sel = [&amp;](net_cost_edge&lt;C&gt; e) {
    return e.cost + po[e.from] - po[e.to];
  };
  while(f &gt; 0) {
    vector&lt;C&gt; dist(n,C());
    vector&lt;bool&gt; vis(n,false);
    vector&lt;int&gt; p(n,-1);
    vector&lt;int&gt; pe(n,-1);
    using P = pair&lt;C,int&gt;;
    priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt;&gt; que;
    que.push({dist[s] ,s});
    vis[s] = true;
    while(!que.empty()) {
      int v = que.top().second;
      C d = que.top().first;
      que.pop();
      if(dist[v] &lt; d) continue;
      for(int i = 0;i &lt; g[v].size();i++) {
        auto&amp; e = g[v][i];
        int u = e.to;
        if(e.cap == C()) continue;
        if(!vis[u] || dist[u] &gt; dist[v] + sel(e)) {
          vis[u] = true;
          dist[u] = dist[v] + sel(e);
          p[u] = v;
          pe[u] = i;
          que.push({dist[u] , u});
        }
      }
    }
    if(p[t] == -1) break;

    C ff = f;
    for(int u = t;u != s;u = p[u])
      ff = min(ff, g[p[u]][pe[u]].cap);
    for(int u = t;u != s;u = p[u]) {
      ans += ff * g[p[u]][pe[u]].cost;
      g[p[u]][pe[u]].cap -= ff;
      g[u][g[p[u]][pe[u]].rev].cap += ff;
    }
    f -= ff;
    for(int i = 0;i &lt; n;i++)
      po[i] += dist[i];
  }
  if(f != C()) return {false,C()};
  return {true ,ans };
}
</code></pre>
<h1><a class="header" href="#low-link" id="low-link">Low Link</a></h1>
<h2><a class="header" href="#code-42" id="code-42">Code</a></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

template&lt; typename G &gt;
struct LowLink {
  const G &amp;g;
  vector&lt; int &gt; used, ord, low;
  vector&lt; int &gt; articulation;
  vector&lt; pair&lt; int, int &gt; &gt; bridge;
 
  LowLink(const G &amp;g) : g(g) {}
 
  int dfs(int idx, int k, int par) {
    used[idx] = true;
    ord[idx] = k++;
    low[idx] = ord[idx];
    bool is_articulation = false;
    int cnt = 0;
    for(auto &amp;to : g[idx]) {
      if(!used[to]) {
        ++cnt;
        k = dfs(to, k, idx);
        low[idx] = min(low[idx], low[to]);
        is_articulation |= ~par &amp;&amp; low[to] &gt;= ord[idx];
        if(ord[idx] &lt; low[to]) bridge.emplace_back(minmax(idx, (int) to));
      } else if(to != par) {
        low[idx] = min(low[idx], ord[to]);
      }
    }
    is_articulation |= par == -1 &amp;&amp; cnt &gt; 1;
    if(is_articulation) articulation.push_back(idx);
    return k;
  }
 
  virtual void build() {
    used.assign(g.size(), 0);
    ord.assign(g.size(), 0);
    low.assign(g.size(), 0);
    int k = 0;
    for(int i = 0; i &lt; g.size(); i++) {
      if(!used[i]) k = dfs(i, k, -1);
    }
  }
};
</code></pre>
<h1><a class="header" href="#strongly-connected-components" id="strongly-connected-components">Strongly Connected Components</a></h1>
<h2><a class="header" href="#code-43" id="code-43">Code</a></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

vector&lt;i64&gt; strongly_connected_components(const vector&lt;vector&lt;i64&gt;&gt;&amp; g) {
  i64 n = g.size();
  vector&lt;vector&lt;i64&gt;&gt; rg(n);
  for(int i = 0;i &lt; n;i++) {
    for(auto j: g[i]) {
      rg[j].push_back(i);
    }
  }

  vector&lt;bool&gt; vis(n,false);
  vector&lt;i64&gt; vs;
  vector&lt;i64&gt; res(n,-1);
  function&lt;void(int)&gt; dfs = [&amp;](int v) {
    vis[v] = true;
    for(auto&amp; t : g[v]) {
      if(!vis[t]) dfs(t);
    }
    vs.push_back(v);
  };

  function&lt;void(int,int)&gt; rdfs = [&amp;](int v,int k) {
    vis[v] = true;
    res[v] = k;
    for(auto to : rg[v]) {
      if(!vis[to]) rdfs(to,k);
    }
  };

  for(int i = 0;i &lt; n;i++) {
    if(!vis[i]) dfs(i);
  }

  vis.assign(n,false);
  int k = 0;
  for(int i = n - 1;i &gt;= 0;i--) {
    if(!vis[vs[i]]) rdfs(vs[i] , k++);
  }
  return res;
}
</code></pre>
<h1><a class="header" href="#two-edge-connected" id="two-edge-connected">Two Edge Connected</a></h1>
<h2><a class="header" href="#code-44" id="code-44">Code</a></h2>
<pre><code class="language-cpp">/* 二重辺連結成分(2-edge connected component) とは, 
1
 個の辺を取り除いても連結である部分グラフ */

template&lt; typename G &gt;
struct TwoEdgeConnectedComponents : LowLink&lt; G &gt; {
  using LL = LowLink&lt; G &gt;;
  vector&lt; int &gt; comp;
 
  TwoEdgeConnectedComponents(const G &amp;g) : LL(g) {}
 
  int operator[](const int &amp;k) {
    return comp[k];
  }
 
  void dfs(int idx, int par, int &amp;k) {
    if(~par &amp;&amp; this-&gt;ord[par] &gt;= this-&gt;low[idx]) comp[idx] = comp[par];
    else comp[idx] = k++;
    for(auto &amp;to : this-&gt;g[idx]) {
      if(comp[to] == -1) dfs(to, idx, k);
    }
  }
 
  void build(UnWeightedGraph &amp;t) {
    LL::build();
    comp.assign(this-&gt;g.size(), -1);
    int k = 0;
    for(int i = 0; i &lt; comp.size(); i++) {
      if(comp[i] == -1) dfs(i, -1, k);
    }
    t.resize(k);
    for(auto &amp;e : this-&gt;bridge) {
      int x = comp[e.first], y = comp[e.second];
      t[x].push_back(y);
      t[y].push_back(x);
    }
  }
};
</code></pre>
<h1><a class="header" href="#two-vertex-connected" id="two-vertex-connected">Two Vertex Connected</a></h1>
<h2><a class="header" href="#code-45" id="code-45">Code</a></h2>
<pre><code class="language-cpp">/* 二重頂点連結成分とは、
1
 個の頂点を取り除いても連結である部分グラフ */

template&lt; typename G &gt;
struct BiConnectedComponents : LowLink&lt; G &gt; {
  using LL = LowLink&lt; G &gt;;
 
  vector&lt; int &gt; used;
  vector&lt; vector&lt; pair&lt; int, int &gt; &gt; &gt; bc;
  vector&lt; pair&lt; int, int &gt; &gt; tmp;
 
  BiConnectedComponents(const G &amp;g) : LL(g) {}
 
  void dfs(int idx, int par) {
    used[idx] = true;
    for(auto &amp;to : this-&gt;g[idx]) {
      if(to == par) continue;
      if(!used[to] || this-&gt;ord[to] &lt; this-&gt;ord[idx]) {
        tmp.emplace_back(minmax(idx, to));
      }
      if(!used[to]) {
        dfs(to, idx);
        if(this-&gt;low[to] &gt;= this-&gt;ord[idx]) {
          bc.emplace_back();
          for(;;) {
            auto e = tmp.back();
            bc.back().emplace_back(e);
            tmp.pop_back();
            if(e.first == min(idx, to) &amp;&amp; e.second == max(idx, to)) {
              break;
            }
          }
        }
      }
    }
  }
 
  void build() override {
    LL::build();
    used.assign(this-&gt;g.size(), 0);
    for(int i = 0; i &lt; used.size(); i++) {
      if(!used[i]) dfs(i, -1);
    }
  }
};
</code></pre>
<h1><a class="header" href="#geometry" id="geometry">Geometry</a></h1>
<p>昔作ったやつが残っていたのでとりあえず貼っておく 要整備</p>
<h3><a class="header" href="#spec-32" id="spec-32">Spec</a></h3>
<ul>
<li><code>Convex_Hull</code>
<ul>
<li>凸包</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-46" id="code-46">Code</a></h3>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;
using namespace std;

using ld = long double;

const ld EPS = 1e-8;
inline bool eq(ld a, ld b) { return abs(a - b) &lt; EPS; }
const ld PI = acos(-1);

namespace Geometory {
  struct Point {
    ld x, y;
    Point(ld x = 0, ld y = 0) : x(x), y(y) {}
    Point operator+(const Point&amp; b) const { return Point(x + b.x, y + b.y); }
    Point operator-(const Point&amp; b) const { return Point(x - b.x, y - b.y); }
    Point operator*(const ld b) const { return Point(x * b, y * b); }
    Point operator/(const ld b) const { return Point(x / b, y / b); }
    bool operator&lt;(const Point&amp; b) const {
      if (x != b.x)
        return x &lt; b.x;
      else
        return y &lt; b.y;
    }
    bool operator==(const Point&amp; b) const { return eq(x, b.x) &amp;&amp; eq(y, b.y); }
    ld norm() const { return x * x + y * y; }
    ld abs() const { return sqrt(norm()); }
    ld arg() const { return atan2(x, y); }
    Point rotate(const ld theta) const {
      ld co = cos(theta);
      ld si = sin(theta);
      return Point(co * x - si * y, si * x + y * co);
    }
    Point rotate90() const { return Point(-y, x); }
  };

  ld dot(const Point&amp; a, const Point&amp; b) { return a.x * b.x + a.y * b.y; }
  ld cross(const Point&amp; a, const Point b) { return a.x * b.y - a.y * b.x; }

  struct Line {
    Point from, to;
    Line(Point from = Point(), Point to = Point()) : from(from), to(to) {}
  };

  struct Segment {
    Point from, to;
    Segment(Point from = Point(), Point to = Point()) : from(from), to(to) {}
  };

  bool is_orthogonal(const Line&amp; la, const Line&amp; lb) {
    return eq(0.0, dot(la.from - la.to, lb.from - lb.from));
  }
  bool is_parallel(const Line&amp; la, const Line&amp; lb) {
    return eq(0.0, cross(la.from - la.to, lb.from - lb.from));
  }
  bool is_Point_on(const Line&amp; l, const Point&amp; p) {
    return eq(0.0, cross(l.to - l.from, p - l.from));
  }
  bool is_Point_on(const Segment&amp; s, const Point&amp; p) {
    return (s.from - p).abs() + (p - s.to).abs() &lt; (s.from - s.to).abs() + EPS;
  }
  ld distance(const Line&amp; l, const Point&amp; p) {
    return abs(cross(l.to - l.from, p - l.from)) / (l.to - l.from).abs();
  }
  ld distance(const Segment&amp; s, const Point&amp; p) {
    if (dot(s.to - s.from, p - s.from) &lt; EPS) return (p - s.from).abs();
    if (dot(s.from - s.to, p - s.to) &lt; EPS) return (p - s.to).abs();
    return abs(cross(s.to - s.from, p - s.from)) / (s.to - s.from).abs();
  }
  ld is_intersected(const Segment&amp; a, const Segment&amp; b) {
    return (cross(a.to - a.from, b.from - a.from) *
                cross(a.to - a.from, b.to - a.from) &lt;
            EPS) &amp;&amp;
           (cross(b.to - b.from, a.from - b.from) *
                cross(b.to - b.from, a.to - b.from) &lt;
            EPS);
  }

  ld is_intersected(const Segment&amp; s, const Line&amp; l) {
    // line -&gt; ax + by + c = 0
    ld a = l.to.y - l.from.y;
    ld b = l.from.x - l.to.x;
    ld c = -a * l.from.x - b * l.from.y;
    ld t1 = a * s.from.x + b * s.from.y + c;
    ld t2 = a * s.to.x + b * s.to.y + c;
    return t1 * t2 &lt;= 0;
  }

  Point intersection_point(const Segment&amp; a, const Segment&amp; b) {
    Point bp = b.to - b.from;
    ld d1 = abs(cross(bp, a.from - b.from));
    ld d2 = abs(cross(bp, a.to - b.from));
    ld t = d1 / (d1 + d2);
    return a.from + (a.to - a.from) * t;
  }

  Point intersection_point(const Line&amp; a, const Line&amp; b) {
    Point ap = a.to - a.from;
    Point bp = b.to - b.from;
    return a.from + ap * cross(bp, b.from - a.from) / cross(bp, ap);
  }
  // counterclockwise
  int ccw(const Point&amp; a, const Point&amp; b, const Point&amp; c) {
    Point ba = b - a;
    Point ca = c - a;
    if (cross(ba, ca) &gt; EPS) return 1;   // a - b --/ c
    if (cross(ba, ca) &lt; EPS) return -1;  // a - b --| c
    if (dot(ba, ca) &lt; 0) return 2;       // b - a - c
    if (b.norm() &lt; c.norm()) return -2;  // a - b - c
    return 0;                            // a -- c -- b
  }

  vector&lt;Point&gt; Convex_Hull(vector&lt;Point&gt;&amp; p) {
    int n = p.size();
    int k = 0;
    if (n &gt;= 3) {
      sort(p.begin(), p.end());
      vector&lt;Point&gt; ch(2 * n);
      for (int i = 0; i &lt; n; ch[k++] = p[i++]) {
        while (k &gt;= 2 &amp;&amp; cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) &lt; 0)
          k--;
      }
      for (int i = n - 2, t = k + 1; i &gt;= 0; ch[k++] = p[i--]) {
        while (k &gt;= t &amp;&amp; cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) &lt; 0)
          k--;
      }
      ch.resize(k - 1);
      return ch;
    } else {
      return p;
    }
  }
};
</code></pre>
<h1><a class="header" href="#tech" id="tech">Tech</a></h1>
<p>テクニック, 分類できなかったもの</p>
<h1><a class="header" href="#compression" id="compression">Compression</a></h1>
<p>座標圧縮をする.</p>
<h3><a class="header" href="#spec-33" id="spec-33">Spec</a></h3>
<ul>
<li>
<p><code>add(T x)</code></p>
<ul>
<li>要素<code>x</code>を追加する</li>
</ul>
</li>
<li>
<p><code>build()</code></p>
<ul>
<li>準備</li>
</ul>
</li>
<li>
<p><code>comp(T x)</code></p>
<ul>
<li>座圧した結果を返す</li>
</ul>
</li>
<li>
<p><code>comp(vector&lt;T&gt; x)</code></p>
<ul>
<li>まとめて座圧</li>
<li><code>x = comp(std::move(x))</code>すると楽です.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-47" id="code-47">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;

template&lt;class T&gt;
struct Compression {
  using size_type = std::size_t;

  std::vector&lt;T&gt; v;

  Compression(){}
  void add(const T&amp; t) { v.push_back(t); }
  void build() {
    sort(begin(v), end(v));
    v.erase(unique(begin(v), end(v)), end(v));
  }
  size_type comp(const T&amp; x) const {
    return lower_bound(begin(v), end(v), x) - begin(v);
  }
  size_type size() const { return v.size(); }
};
</code></pre>
<h1><a class="header" href="#grundy-number" id="grundy-number">Grundy Number</a></h1>
<h3><a class="header" href="#spec-34" id="spec-34">Spec</a></h3>
<ul>
<li><code>grn[(ゲームの状態)]</code>が<code>0</code> -&gt; その状態での手番の人が負ける</li>
<li><code>grn[(ゲームの状態)]</code>が<code>0</code>以外 -&gt; その状態での手番の人が勝つ</li>
</ul>
<h3><a class="header" href="#code-48" id="code-48">Code</a></h3>
<p>このコードでは, 取れる個数に制限がついているNimの勝敗を計算している.</p>
<pre><code class="language-cpp">/*
 N個の正整数からなる集合 A={a1,a2,…,aN}があります。 太郎君と次郎君が次のゲームで勝負します。

最初に、K個の石からなる山を用意します。 二人は次の操作を交互に行います。 先手は太郎君です。
Aの元 xをひとつ選び、山からちょうど x個の石を取り去る。
先に操作を行えなくなった人が負けです。 二人が最適に行動すると仮定したとき、どちらが勝つかを判定してください。
*/

#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

vector&lt;i64&gt; grn(101010, -1);

i64 N, K;
vector&lt;i64&gt; a;

int main() {
  cin &gt;&gt; N &gt;&gt; K;
  a.resize(N);
  for(int i = 0;i &lt; N;i++) cin &gt;&gt; a[i];
  for(i64 k = 0;k &lt;= K;k++) {
    set&lt;i64&gt; st;
    for(auto x: a) {
      if(k - x &gt;= 0) st.insert(grn[k - x]);
    }
    grn[k] = K + 1;
    for(int i = 0;i &lt;= K + 1;i++) {
      if(!st.count(i)) {
        grn[k] = i;
        break;
      }
    }
  }
  if(grn[K]) {
    cout &lt;&lt; &quot;First&quot; &lt;&lt; endl;
  }
  else {
    cout &lt;&lt; &quot;Second&quot; &lt;&lt; endl;
  }
}
</code></pre>
<h1><a class="header" href="#monge-dp" id="monge-dp">Monge DP</a></h1>
<h1><a class="header" href="#mos-algorithm" id="mos-algorithm">Mo's Algorithm</a></h1>
<p>もーもー</p>
<h3><a class="header" href="#code-49" id="code-49">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;
#define rep(i,s,e) for(i64 (i) = (s);(i) &lt; (e);(i)++)
#define rev(i,s,e) for(i64 (i) = (e); (i)-- &gt; (s);)
#define all(x) x.begin(),x.end()

struct Mo {
  vector&lt;i64&gt; left, right, order;
  vector&lt;bool&gt; v;
  

  const i64 width;
  i64 nl, nr, ptr;

  vector&lt;i64&gt; a;
  vector&lt;i64&gt; cnt;
  i64 ans;

  Mo(i64 n, vector&lt;i64&gt; a) : v(n), width((i64)sqrt(n)), nl(0), nr(0), ptr(0), a(a), cnt(1010101), ans(0) {}

  void add_query(i64 l, i64 r) {
    left.push_back(l);
    right.push_back(r);
  }

  void build() {
    order.resize(left.size());
    for(i64 i = 0;i &lt; left.size();i++) order[i] = i;
    sort(begin(order), end(order), [&amp;](i64 a, i64 b) {
        if(left[a] / width != left[b] / width) return left[a] &lt; left[b];
        else return right[a] &lt; right[b];
        });
  }


  void add(i64 idx) {
    if(cnt[a[idx]]++ == 0) ans++;
  }
  void del(i64 idx) {
    if(--cnt[a[idx]] == 0) ans--;
  }

  inline void distribute(i64 idx) {
    v[idx].flip();
    if(v[idx]) add(idx);
    else del(idx);
  }

  i64 process() {
    if(ptr == order.size()) return -1;
    const auto id = order[ptr];
    while(nl &gt; left[id]) distribute(--nl);
    while(nr &lt; right[id]) distribute(nr++);
    while(nl &lt; left[id]) distribute(nl++);
    while(nr &gt; right[id]) distribute(--nr);
    return order[ptr++];
  }
};
</code></pre>
<h1><a class="header" href="#slide-min" id="slide-min">Slide Min</a></h1>
<h1><a class="header" href="#fastio" id="fastio">FastIO</a></h1>
<h3><a class="header" href="#spec-35" id="spec-35">Spec</a></h3>
<h3><a class="header" href="#code-50" id="code-50">Code</a></h3>
<pre><code class="language-cpp">#include &lt;cstdio&gt;

namespace niu {
  char cur;
  struct FIN {
    static inline bool is_blank(char c) { return c &lt;= ' '; }
    inline char next() { return cur = getc_unlocked(stdin); }
    inline char peek() { return cur; }
    inline void skip() { while(is_blank(next())){} }
#define intin(inttype)  \
    FIN&amp; operator&gt;&gt;(inttype&amp; n) { \
      bool sign = 0; \
      n = 0; \
      skip(); \
      while(!is_blank(peek())) { \
        if(peek() == '-') sign = 1; \
        else n = (n &lt;&lt; 1) + (n &lt;&lt; 3) + (peek() &amp; 0b1111); \
        next(); \
      } \
      if(sign) n = -n; \
      return *this; \
    }
intin(int)
intin(long long)
  } fin;

  char tmp[128];
  struct FOUT {
    static inline bool is_blank(char c) { return c &lt;= ' '; }
    inline void push(char c) { putc_unlocked(c, stdout); }
    FOUT&amp; operator&lt;&lt;(char c) { push(c); return *this; }
    FOUT&amp; operator&lt;&lt;(const char* s) { while(*s) push(*s++); return *this; }
#define intout(inttype) \
    FOUT&amp; operator&lt;&lt;(inttype n) { \
      if(n) { \
        char* p = tmp + 127; bool neg = 0; \
        if(n &lt; 0) neg = 1, n = -n; \
        while(n) *--p = (n % 10) | 0b00110000, n /= 10; \
        if(neg) *--p = '-'; \
        return (*this) &lt;&lt; p; \
      } \
      else { \
        push('0'); \
        return *this; \
      } \
    }
intout(int)
intout(long long)
  } fout;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
