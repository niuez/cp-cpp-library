<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>cp-cpp-library Document</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/index.html"><strong aria-hidden="true">1.1.</strong> Data Structures</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/segment_tree/index.html"><strong aria-hidden="true">1.1.1.</strong> Segment Trees</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/segment_tree/segment_tree.html"><strong aria-hidden="true">1.1.1.1.</strong> Segment Tree</a></li><li class="expanded "><a href="data_structures/segment_tree/lazy_segment_tree.html"><strong aria-hidden="true">1.1.1.2.</strong> Lazy Segment Tree</a></li><li class="expanded "><a href="data_structures/segment_tree/persistent_segment_tree.html"><strong aria-hidden="true">1.1.1.3.</strong> Persistent Segment Tree</a></li><li class="expanded "><a href="data_structures/segment_tree/dynamic_segment_tree.html"><strong aria-hidden="true">1.1.1.4.</strong> Dynamic Segment Tree</a></li><li class="expanded "><a href="data_structures/segment_tree/li_chao.html"><strong aria-hidden="true">1.1.1.5.</strong> Li-Chao Line Add Tree</a></li><li class="expanded "><a href="data_structures/segment_tree/li_chao_segment.html"><strong aria-hidden="true">1.1.1.6.</strong> Li-Chao Segment Add Tree</a></li><li class="expanded "><a href="data_structures/segment_tree/beats_chmin_sum.html"><strong aria-hidden="true">1.1.1.7.</strong> Beats (chmin + sum)</a></li><li class="expanded "><a href="data_structures/segment_tree/beats_chminmax_sum.html"><strong aria-hidden="true">1.1.1.8.</strong> Beats (chmin + chmax + sum)</a></li><li class="expanded "><a href="data_structures/segment_tree/beats_chminmaxadd_sum.html"><strong aria-hidden="true">1.1.1.9.</strong> Beats (chmin + chmax + add + sum)</a></li></ol></li><li class="expanded "><a href="data_structures/heap/index.html"><strong aria-hidden="true">1.1.2.</strong> Heaps</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/heap/pairing_heap.html"><strong aria-hidden="true">1.1.2.1.</strong> Pairing Heap</a></li></ol></li><li class="expanded "><a href="data_structures/trees/index.html"><strong aria-hidden="true">1.1.3.</strong> Trees</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/trees/euler_tour_subtree.html"><strong aria-hidden="true">1.1.3.1.</strong> EulerTour Subtree</a></li><li class="expanded "><a href="data_structures/trees/euler_tour_path.html"><strong aria-hidden="true">1.1.3.2.</strong> EulerTour Path</a></li><li class="expanded "><a href="data_structures/trees/heavy_light_decomposition.html"><strong aria-hidden="true">1.1.3.3.</strong> Heavy Light Decomposition</a></li><li class="expanded "><a href="data_structures/trees/link_cut_tree.html"><strong aria-hidden="true">1.1.3.4.</strong> Link Cut Tree</a></li><li class="expanded "><a href="data_structures/trees/toptree.html"><strong aria-hidden="true">1.1.3.5.</strong> Top Tree</a></li></ol></li><li class="expanded "><a href="data_structures/union_find/index.html"><strong aria-hidden="true">1.1.4.</strong> Union Find</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/union_find/union_find.html"><strong aria-hidden="true">1.1.4.1.</strong> Union Find</a></li><li class="expanded "><a href="data_structures/union_find/persistent_union_find.html"><strong aria-hidden="true">1.1.4.2.</strong> Persistent Union Find</a></li></ol></li><li class="expanded "><a href="data_structures/bbst/index.html"><strong aria-hidden="true">1.1.5.</strong> self-Balancing Binary Search Trees</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/bbst/splay_tree_array.html"><strong aria-hidden="true">1.1.5.1.</strong> Splay Tree Array</a></li><li class="expanded "><a href="data_structures/bbst/splay_tree_map.html"><strong aria-hidden="true">1.1.5.2.</strong> Splay Tree Map</a></li><li class="expanded "><a href="data_structures/bbst/avl_tree_array.html"><strong aria-hidden="true">1.1.5.3.</strong> AVL Tree Array</a></li><li class="expanded "><a href="data_structures/bbst/avl_tree_array_tuned.html"><strong aria-hidden="true">1.1.5.4.</strong> AVL Tree Array Tuned</a></li><li class="expanded "><a href="data_structures/bbst/avl_tree_map.html"><strong aria-hidden="true">1.1.5.5.</strong> AVL Tree Map</a></li><li class="expanded "><a href="data_structures/bbst/avl_tree_map_foldable.html"><strong aria-hidden="true">1.1.5.6.</strong> AVL Tree Map Foldable</a></li><li class="expanded "><a href="data_structures/bbst/persistent_avl_tree_array.html"><strong aria-hidden="true">1.1.5.7.</strong> Persistent AVL Tree Array</a></li></ol></li><li class="expanded "><a href="data_structures/sparse_table/sparse_table.html"><strong aria-hidden="true">1.1.6.</strong> Sparse Table</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/sparse_table/sparse_table.html"><strong aria-hidden="true">1.1.6.1.</strong> Sparse Table</a></li></ol></li><li class="expanded "><a href="data_structures/wavelet_matrix/index.html"><strong aria-hidden="true">1.1.7.</strong> Wavelet Matrix</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/wavelet_matrix/wavelet_matrix.html"><strong aria-hidden="true">1.1.7.1.</strong> Wavelet Matrix</a></li><li class="expanded "><a href="data_structures/wavelet_matrix/dynamic_wavelet_matrix.html"><strong aria-hidden="true">1.1.7.2.</strong> Dynamic Wavelet Matrix</a></li></ol></li><li class="expanded "><a href="data_structures/container/fully_retroactive_stack.html"><strong aria-hidden="true">1.1.8.</strong> Container</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/container/fully_retroactive_stack.html"><strong aria-hidden="true">1.1.8.1.</strong> Fully Retroactive Stack</a></li><li class="expanded "><a href="data_structures/container/hash_map.html"><strong aria-hidden="true">1.1.8.2.</strong> Hash Map</a></li></ol></li><li class="expanded "><a href="data_structures/other/index.html"><strong aria-hidden="true">1.1.9.</strong> Other</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/other/swag.html"><strong aria-hidden="true">1.1.9.1.</strong> SWAG</a></li><li class="expanded "><a href="data_structures/other/fenwick_tree.html"><strong aria-hidden="true">1.1.9.2.</strong> Fenwick Tree</a></li><li class="expanded "><a href="data_structures/other/online_dicon.html"><strong aria-hidden="true">1.1.9.3.</strong> Online Dynamic Connectivity</a></li></ol></li></ol></li><li class="expanded "><a href="math/index.html"><strong aria-hidden="true">1.2.</strong> Math</a></li><li><ol class="section"><li class="expanded "><a href="math/modint.html"><strong aria-hidden="true">1.2.1.</strong> modint</a></li><li class="expanded "><a href="math/matrix.html"><strong aria-hidden="true">1.2.2.</strong> Matrix</a></li><li class="expanded "><a href="math/garner.html"><strong aria-hidden="true">1.2.3.</strong> Garner's Algorithm</a></li><li class="expanded "><a href="math/formal_power_series.html"><strong aria-hidden="true">1.2.4.</strong> Formal Power Series</a></li><li class="expanded "><a href="math/runtime_fp.html"><strong aria-hidden="true">1.2.5.</strong> Runtime fp</a></li><li class="expanded "><a href="math/binfps.html"><strong aria-hidden="true">1.2.6.</strong> F2FPS</a></li><li class="expanded "><a href="math/factorial.html"><strong aria-hidden="true">1.2.7.</strong> Factorial</a></li><li class="expanded "><a href="math/convolution/index.html"><strong aria-hidden="true">1.2.8.</strong> Convolution</a></li><li><ol class="section"><li class="expanded "><a href="math/convolution/multiple_transform.html"><strong aria-hidden="true">1.2.8.1.</strong> Multiple Transform</a></li><li class="expanded "><a href="math/convolution/divisor_transform.html"><strong aria-hidden="true">1.2.8.2.</strong> Divisor Transform</a></li><li class="expanded "><a href="math/convolution/fast_fourier_transform.html"><strong aria-hidden="true">1.2.8.3.</strong> Fast Fourier Transform</a></li><li class="expanded "><a href="math/convolution/numeric_theoretic_transform.html"><strong aria-hidden="true">1.2.8.4.</strong> Number Theoretic Transform</a></li></ol></li></ol></li><li class="expanded "><a href="string/index.html"><strong aria-hidden="true">1.3.</strong> String</a></li><li><ol class="section"><li class="expanded "><a href="string/2_31rolling_hash.html"><strong aria-hidden="true">1.3.1.</strong> 2^31 Rolling Hash</a></li><li class="expanded "><a href="string/manacher.html"><strong aria-hidden="true">1.3.2.</strong> Manacher</a></li><li class="expanded "><a href="string/mp.html"><strong aria-hidden="true">1.3.3.</strong> MP (Morris Pratt)</a></li><li class="expanded "><a href="string/suffix_array.html"><strong aria-hidden="true">1.3.4.</strong> Suffix Array</a></li><li class="expanded "><a href="string/Z-algorithm.html"><strong aria-hidden="true">1.3.5.</strong> Z-algorithm</a></li><li class="expanded "><a href="string/burrows_wheeler.html"><strong aria-hidden="true">1.3.6.</strong> Burrows Wheeler</a></li><li class="expanded "><a href="string/rolling_hash.html"><strong aria-hidden="true">1.3.7.</strong> Rolling Hash</a></li></ol></li><li class="expanded "><a href="graph/index.html"><strong aria-hidden="true">1.4.</strong> Graph</a></li><li><ol class="section"><li class="expanded "><a href="graph/sp/dijkstra.html"><strong aria-hidden="true">1.4.1.</strong> Shortest Path</a></li><li><ol class="section"><li class="expanded "><a href="graph/sp/dijkstra.html"><strong aria-hidden="true">1.4.1.1.</strong> Dijkstra</a></li><li class="expanded "><a href="graph/sp/bfs.html"><strong aria-hidden="true">1.4.1.2.</strong> BFS</a></li><li class="expanded "><a href="graph/sp/dial01.html"><strong aria-hidden="true">1.4.1.3.</strong> Dial 01</a></li></ol></li><li class="expanded "><a href="graph/max_flow/dinic.html"><strong aria-hidden="true">1.4.2.</strong> Max Flow</a></li><li><ol class="section"><li class="expanded "><a href="graph/max_flow/dinic.html"><strong aria-hidden="true">1.4.2.1.</strong> Dinic</a></li><li class="expanded "><a href="graph/max_flow/goldberg_tarjan_tuned.html"><strong aria-hidden="true">1.4.2.2.</strong> GoldBerg Tarjan's Preflow Relabel</a></li></ol></li><li class="expanded "><a href="graph/mcf/primal_dual.html"><strong aria-hidden="true">1.4.3.</strong> Minimum Cost Flow</a></li><li><ol class="section"><li class="expanded "><a href="graph/mcf/primal_dual.html"><strong aria-hidden="true">1.4.3.1.</strong> Successive Shortest Path</a></li></ol></li><li class="expanded "><a href="graph/strongly_connected_components.html"><strong aria-hidden="true">1.4.4.</strong> Strongly Connected Components</a></li><li class="expanded "><a href="graph/incremental_bridge_connectivity.html"><strong aria-hidden="true">1.4.5.</strong> Incremental Bridge Connectivity</a></li><li class="expanded "><a href="graph/lattice_graph.html"><strong aria-hidden="true">1.4.6.</strong> Lattice Graph</a></li></ol></li><li class="expanded "><a href="geometry/geometry.html"><strong aria-hidden="true">1.5.</strong> Geometry</a></li><li class="expanded "><a href="tech/index.html"><strong aria-hidden="true">1.6.</strong> Tech</a></li><li><ol class="section"><li class="expanded "><a href="tech/compression.html"><strong aria-hidden="true">1.6.1.</strong> Compression</a></li><li class="expanded "><a href="tech/grundy.html"><strong aria-hidden="true">1.6.2.</strong> Grundy Number</a></li><li class="expanded "><a href="tech/mongeDP.html"><strong aria-hidden="true">1.6.3.</strong> Monge DP</a></li><li class="expanded "><a href="tech/mo.html"><strong aria-hidden="true">1.6.4.</strong> Mo's Algorithm</a></li><li class="expanded "><a href="tech/slide_min.html"><strong aria-hidden="true">1.6.5.</strong> Slide Min</a></li><li class="expanded "><a href="tech/fastio.html"><strong aria-hidden="true">1.6.6.</strong> FastIO</a></li><li class="expanded "><a href="tech/rerooting.html"><strong aria-hidden="true">1.6.7.</strong> Non-recursive Rerooting</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">cp-cpp-library Document</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>ここに競技プログラミング用のC++のライブラリをおいていきたい</p>
<ul>
<li>Google Analyticsを使用しています</li>
</ul>
<h1><a class="header" href="#data-structures" id="data-structures">Data Structures</a></h1>
<p>いろいろ, あるよね</p>
<h1><a class="header" href="#segment-trees" id="segment-trees">Segment Trees</a></h1>
<ul>
<li>
<p><a href="data_structures/segment_tree/./segment_tree.html">Segment Tree</a></p>
</li>
<li>
<p><a href="data_structures/segment_tree/./lazy_segment_tree.html">Lazy Segment Tree</a></p>
</li>
<li>
<p><a href="data_structures/segment_tree/./persistent_segment_tree.html">Persistent Segment Tree</a></p>
</li>
<li>
<p><a href="data_structures/segment_tree/./dynamic_segment_tree.html">Dynamic Segment Tree</a></p>
</li>
<li>
<p><a href="data_structures/segment_tree/./li_chao.html">Li-Chao Segment Tree</a></p>
</li>
</ul>
<h1><a class="header" href="#segment-tree" id="segment-tree">Segment Tree</a></h1>
<h3><a class="header" href="#spec" id="spec">Spec</a></h3>
<ul>
<li>
<p><code>using T = ...</code></p>
<ul>
<li>Segment Treeに載せる型</li>
</ul>
</li>
<li>
<p><code>T ope(const T&amp; a, const T&amp; b)</code></p>
<ul>
<li>Tの演算を指定する</li>
</ul>
</li>
<li>
<p><code>T ide()</code></p>
<ul>
<li>Tの単位元を返す</li>
</ul>
</li>
<li>
<p><code>segment_tree(vector&lt;T&gt; init)</code></p>
<ul>
<li><code>init</code>からSegment Treeを構築する</li>
<li>\( O(n) \)</li>
</ul>
</li>
<li>
<p><code>update(i64 i, T x)</code></p>
<ul>
<li><code>i</code>番目の要素を<code>x</code>にする</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
<li>
<p><code>sum(i64 l, i64 r)</code></p>
<ul>
<li><code>[l, r)</code>の総和を求める</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code" id="code">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
using i64 = long long;

template&lt;class T, class Ope, const T&amp; Ide&gt;
struct segment_tree {
  Ope ope;
 
  i64 n;
  std::vector&lt;T&gt; node;
 
  segment_tree(const std::vector&lt;T&gt;&amp; init) {
    n = 1;
    while(n &lt; init.size()) n *= 2;
    node.resize(2 * n, Ide);
    for(int i = 0;i &lt; init.size();i++) node[i + n] = init[i];
    for(int i = n - 1; i &gt;= 1;i--) node[i] = ope(node[i * 2], node[i * 2 + 1]);
  }
 
  void modify(i64 i, T x) {
    i += n;
    node[i] = ope(node[i], x);
    while(i &gt; 1) {
      i = i / 2;
      node[i] = ope(node[i * 2], node[i * 2 + 1]);
    }
  }

  /* [l, r) */
  T sum(i64 l, i64 r) const {
    T lx = Ide;
    T rx = Ide;
    l += n;
    r += n;
    while(l &lt; r) {
      if(l &amp; 1) { lx = ope(lx, node[l++]); }
      if(r &amp; 1) { rx = ope(node[--r], rx); }
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
    }
    return ope(lx, rx);
  }
};
</code></pre>
<h1><a class="header" href="#lazy-segment-tree" id="lazy-segment-tree">Lazy Segment Tree</a></h1>
<h3><a class="header" href="#spec-1" id="spec-1">Spec</a></h3>
<ul>
<li>
<p><code>using T = ...</code></p>
<ul>
<li>Segment Treeに載せる型</li>
</ul>
</li>
<li>
<p><code>using L = ...</code></p>
<ul>
<li>遅延伝搬させる作用素</li>
</ul>
</li>
<li>
<p><code>T t_ide()</code></p>
<ul>
<li>Tの単位元を返す</li>
</ul>
</li>
<li>
<p><code>L l_ide()</code></p>
<ul>
<li>Lの単位元を返す</li>
</ul>
</li>
<li>
<p><code>T ope(const T&amp; a, const T&amp; b)</code></p>
<ul>
<li>Tの演算を指定する</li>
</ul>
</li>
<li>
<p><code>L lazy_ope(const L&amp; a, const L&amp; b)</code></p>
<ul>
<li>Tの演算を指定する</li>
</ul>
</li>
<li>
<p><code>T effect(const T&amp; t, const L&amp; l, const i64 len)</code></p>
<ul>
<li>長さ<code>len</code>の区間の総和<code>t</code>に作用<code>l</code>をする</li>
</ul>
</li>
<li>
<p><code>lazy_segment_tree(const vector&lt;T&gt;&amp; init)</code></p>
<ul>
<li><code>init</code>からLazy Segment Treeを構築する</li>
<li>\( O(n) \)</li>
</ul>
</li>
<li>
<p><code>update(i64 a, i64 b, L lx)</code></p>
<ul>
<li><code>[a, b)</code>番目の要素に作用<code>lx</code>をする</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
<li>
<p><code>sum(i64 a, i64 b)</code></p>
<ul>
<li><code>[a, b)</code>の総和を求める</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-1" id="code-1">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;iostream&gt;
using i64 = long long;

struct lazy_segment_tree {
  using T = i64;
  using L = i64;
  static inline T t_ide() { return (1LL &lt;&lt; 31) - 1; }
  static inline L l_ide() { return (1LL &lt;&lt; 31) - 1; }
  static inline T ope(const T&amp; a, const T&amp; b) { return std::min(a, b); }
  static inline L lazy_ope(const L&amp; a, const L&amp; b) { return b; }
  static inline T effect(const T&amp; t, const L&amp; l) { return l; }

  int n, h;
  std::vector&lt;T&gt; node;
  std::vector&lt;L&gt; lazy;
  std::vector&lt;bool&gt; flag;

  lazy_segment_tree(int N) {
    n = 1;
    h = 1;
    while(n &lt; N) n &lt;&lt;= 1, h++;
    node.resize(n &lt;&lt; 1, t_ide());
    lazy.resize(n &lt;&lt; 1, l_ide());
    flag.resize(n &lt;&lt; 1, false);
  }
  lazy_segment_tree(const std::vector&lt;T&gt;&amp; init) {
    n = 1;
    h = 1;
    while(n &lt; init.size()) n &lt;&lt;= 1, h++;
    node.resize(n &lt;&lt; 1, t_ide());
    lazy.resize(n &lt;&lt; 1, l_ide());
    flag.resize(n &lt;&lt; 1, false);
    for(int i = 0;i &lt; init.size();i++) node[i + n] = init[i];
    for(int i = n; i --&gt; 1;) node[i] = ope(node[(i &lt;&lt; 1)], node[(i &lt;&lt; 1) + 1]);
  }

  inline void eff(int k, L x) {
    if(k &lt; n &lt;&lt; 1) {
      lazy[k] = lazy_ope(lazy[k], x);
      flag[k] = true;
    }
  }
  inline T eval(int k) const { return flag[k] ? effect(node[k], lazy[k]) : node[k]; }

  inline void push(int k) {
    if(flag[k]) {
      node[k] = eval(k);
      eff(k &lt;&lt; 1, lazy[k]);
      eff((k &lt;&lt; 1) | 1, lazy[k]);
      lazy[k] = l_ide();
      flag[k] = false;
    }
  }

  inline void infuse(int k) {
    k = k &gt;&gt; __builtin_ctz(k);
    while((k &gt;&gt;= 1)) node[k] = ope(eval(k &lt;&lt; 1), eval((k &lt;&lt; 1) + 1));
  }

  inline void infiltrate(int k) {
    if(k == n &lt;&lt; 1) return;
    int kc = __builtin_ctz(k);
    for(int i = h; i --&gt; kc;) push(k &gt;&gt; i);
  }

  inline void infiltrate(int l, int r) {
    if(r == n &lt;&lt; 1) infiltrate(l);
    else {
      int hh = h;
      int x = l ^ r;
      for(; !(x &gt;&gt; --hh);) push(l &gt;&gt; hh);
      int lc = __builtin_ctz(l);
      for(int i = hh + 1; i --&gt; lc;) push(l &gt;&gt; i);
      int rc = __builtin_ctz(r);
      for(int i = hh + 1; i --&gt; rc;) push(r &gt;&gt; i);
    }
  }

  void update(int a, int b, L x) {
    int l = a + n;
    int r = b + n;
    infiltrate(l, r);
    while(l &lt; r) {
      if(l &amp; 1) eff(l++, x);
      if(r &amp; 1) eff(--r, x);
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
    }
    infuse(a + n);
    infuse(b + n);
  }

  T sum(int l, int r) {
    l += n;
    r += n;
    infiltrate(l, r);
    T lx = t_ide();
    T rx = t_ide();
    while(l &lt; r) {
      if(l &amp; 1) lx = ope(lx, eval(l++));
      if(r &amp; 1) rx = ope(eval(--r), rx);
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
    }
    return ope(lx, rx);
  }
};
</code></pre>
<h1><a class="header" href="#persistent-segment-tree" id="persistent-segment-tree">Persistent Segment Tree</a></h1>
<h3><a class="header" href="#spec-2" id="spec-2">Spec</a></h3>
<ul>
<li>
<p><code>using T = ...</code></p>
<ul>
<li>Segment Treeに載せる型</li>
</ul>
</li>
<li>
<p><code>T ope(const T&amp; a, const T&amp; b)</code></p>
<ul>
<li>Tの演算を指定する</li>
</ul>
</li>
<li>
<p><code>T ide()</code></p>
<ul>
<li>Tの単位元を返す</li>
</ul>
</li>
<li>
<p><code>persistent_segment_tree(vector&lt;T&gt; init)</code></p>
<ul>
<li><code>init</code>からPersistent Segment Treeを構築する</li>
<li>\( O(n) \)</li>
</ul>
</li>
<li>
<p><code>update(i64 i, T x)</code></p>
<ul>
<li><code>i</code>番目の要素を<code>x</code>にしたSegment Treeを返す.</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
<li>
<p><code>sum(i64 l, i64 r)</code></p>
<ul>
<li><code>[l, r)</code>の総和を求める</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-2" id="code-2">Code</a></h3>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
using namespace std;
using i64 = long long;

struct persistent_segment_tree {
  using T = pair&lt;i64, i64&gt;;
  struct node {
    using Ptr = node*;
    T data;
    Ptr left;
    Ptr right;
    
    node(T data): data(data), left(), right() {}
    node(T data, Ptr left, Ptr right)
      : data(data), left(left), right(right) {}
  };

  using Ptr = node*;

  static T ope(const T&amp; a, const T&amp; b) { return std::min(a, b); }
  static T ide() { return {(i64)(1e18), (i64)(1e18)}; }

  Ptr root;
  i64 N;

  static Ptr build(i64 l, i64 r, const vector&lt;T&gt;&amp; init) {
    if(l + 1 &gt;= r) return new node(init[l]);
    else {
      Ptr le = build(l , (l + r) / 2, init);
      Ptr ri = build((l + r) / 2, r, init);
      T da = ope(le-&gt;data, ri-&gt;data);
      return new node(da, le, ri);
    }
  }

  static Ptr update(Ptr node, i64 i, T val, i64 l, i64 r) {
    if(i == l &amp;&amp; i + 1 == r) return new struct node(val);
    Ptr left = nullptr;
    Ptr right = nullptr;
    if(l &lt;= i &amp;&amp; i &lt; ((l + r) &gt;&gt; 1)) {
      left = update(node-&gt;left, i, val, l, (l + r) &gt;&gt; 1);
      right = node-&gt;right;
    }
    else {
      left = node-&gt;left;
      right = update(node-&gt;right, i, val, (l + r) &gt;&gt; 1, r);
    }
    return new struct node(ope(left-&gt;data, right-&gt;data), left, right);
  }

  static T sum(Ptr node, i64 a, i64 b, i64 l, i64 r) {
    if(b &lt;= l || r &lt;= a) return ide();
    else if(a &lt;= l &amp;&amp; r &lt;= b) return node-&gt;data;
    else return ope(
        sum(node-&gt;left, a, b, l, (l + r) &gt;&gt; 1),
        sum(node-&gt;right, a, b, (l + r) &gt;&gt; 1, r)
        );
  }

  persistent_segment_tree(const vector&lt;T&gt;&amp; init)
    : root(build(0, init.size(), init)), N(init.size()) {}
  persistent_segment_tree(Ptr root, i64 N): root(root), N(N) {}
  persistent_segment_tree update(i64 i, T x) const {
    return persistent_segment_tree(update(root, i, x, 0, N), N);
  }
  T sum(i64 l, i64 r) { return sum(root, l, r, 0, N); }
};
</code></pre>
<h1><a class="header" href="#dynamic-segment-tree" id="dynamic-segment-tree">Dynamic Segment Tree</a></h1>
<h3><a class="header" href="#spec-3" id="spec-3">Spec</a></h3>
<ul>
<li>
<p><code>using T = ...</code></p>
<ul>
<li>Dynamic Segment Treeに載せる型</li>
</ul>
</li>
<li>
<p><code>T ope(const T&amp; a, const T&amp; b)</code></p>
<ul>
<li>Tの演算を指定する</li>
</ul>
</li>
<li>
<p><code>T ide()</code></p>
<ul>
<li>Tの単位元を返す</li>
</ul>
</li>
<li>
<p><code>dynamic_segment_tree(const i64 n)</code></p>
<ul>
<li><code>[ide; n]</code>の列を扱うDynamic Segment Treeを構築する</li>
<li>\( O(1) \)</li>
</ul>
</li>
<li>
<p><code>update(i64 i, T x)</code></p>
<ul>
<li><code>i</code>番目の要素を<code>x</code>にする</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
<li>
<p><code>sum(i64 l, i64 r)</code></p>
<ul>
<li><code>[l, r)</code>の総和を求める</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-3" id="code-3">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct dynamic_segment_tree {
  using T = i64;
  static T ide() { return 0ll; }
  static T ope(const T&amp; a, const T&amp; b) { return a + b; }

  struct node {
    node* left;
    node* right;
    T val;
    node(T v): val(v), left(nullptr), right(nullptr) {}
  };

  i64 n;
  node* root;
  dynamic_segment_tree(const i64 sz): root(new node(ide())) {
    n = 1;
    while(n &lt; sz) n *= 2;
  }
  T value(node* n) {
    if(n) return n-&gt;val;
    else return ide();
  }
  void update(node* n, i64 i, T x, i64 l, i64 r) {
    if(l + 1 == r) {
      n-&gt;val = x;
    }
    else {
      i64 m = (l + r) / 2;
      if(i &lt; m) {
        if(!n-&gt;left) {
          n-&gt;left = new node(ide());
        }
        update(n-&gt;left, i, x, l, m);
      }
      else {
        if(!n-&gt;right) {
          n-&gt;right = new node(ide());
        }
        update(n-&gt;right, i, x, m, r);
      }
      n-&gt;val = ope(value(n-&gt;left), value(n-&gt;right));
    }
  }

  T get(node* n, i64 a, i64 b, i64 l, i64 r) {
    if(!n) return ide();
    if(a &lt;= l &amp;&amp; r &lt;= b) return value(n);
    else if(r &lt;= a || b &lt;= l) return ide();
    else return ope(get(n-&gt;left, a, b, l, (l + r) / 2), get(n-&gt;right, a, b, (l + r) / 2, r));
  }

  void update(i64 i, T x) {
    update(root, i, x, 0, n);
  }

  T sum(i64 a, i64 b) {
    return get(root, a, b, 0, n);
  }
};
</code></pre>
<h1><a class="header" href="#li-chao-line-add-tree" id="li-chao-line-add-tree">Li-Chao Line Add Tree</a></h1>
<h3><a class="header" href="#spec-4" id="spec-4">Spec</a></h3>
<ul>
<li>
<p>template argments</p>
<ul>
<li><code>class T</code>
<ul>
<li>Li-Chao Segment Treeで扱う型</li>
<li><code>+, *, /</code>, 比較ができる必要がある</li>
</ul>
</li>
<li><code>const T ide</code>
<ul>
<li>Tの単位元(?)</li>
<li>例えば, 最大値を返すLiChaoなら小さい数を入れておく</li>
</ul>
</li>
<li><code>class Compare = greater&lt;T&gt;</code>
<ul>
<li>最大値or最小値</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>li_chao(T mi, T, ma)</code></p>
<ul>
<li><code>[mi, ma]</code>の間の範囲を管理するLiChaoを構築する.</li>
</ul>
</li>
<li>
<p><code>void add_line(T a, T b)</code></p>
<ul>
<li><code>a * x + b</code>の直線を追加する</li>
<li>\( O(\log L) \)</li>
</ul>
</li>
<li>
<p><code>T get(T x)</code></p>
<ul>
<li><code>max{a_i * x + b_i}</code>を返す(Compareで<code>min</code>に変えられる)</li>
<li>\( O(\log L) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-4" id="code-4">Code</a></h3>
<pre><code class="language-cpp">#include &lt;functional&gt;
using namespace std;

// doubleのときは, midを変える
template&lt;class T,const T ide,class Compare = greater&lt;T&gt;&gt;
struct li_chao{
  struct Line{
    T a,b;
    Line(T a = 0,T b = 0) : a(a) , b(b) {}
    T get(T x){return a * x + b;}
  };
 
  struct Node{
    Line line;
    Node *lhs,*rhs;
    Node(Line l) : line(l) , lhs(nullptr) , rhs(nullptr){}
  };
 
  const T MI,MA;
 
  Node * root;
 
  Compare comp;
 
  T comp_get(const T &amp; x,const T &amp; y){
    if(comp(x , y)) return x;
    else return y;
  }
 
  li_chao(T mi , T ma) : MI(mi), MA(ma) , root(nullptr){}
 
  Node * insert(Node * p,T l,T r,Line &amp; line){
    if(l &gt; r) {
      return p;
    }
    if(!p) return new Node(line);
    if(comp(p-&gt;line.get(l) , line.get(l)) &amp;&amp; comp(p-&gt;line.get(r) ,line.get(r))){
      return p;
    }
    if(!comp(p-&gt;line.get(l) , line.get(l)) &amp;&amp; !comp(p-&gt;line.get(r) ,line.get(r))){
      p-&gt;line = line;
      return p;
    }
    T mid = (l + r) / 2;
    if(comp(line.get(mid) , p-&gt;line.get(mid))) swap(p-&gt;line , line);
    if(comp(line.get(l) , p-&gt;line.get(l))){
      p-&gt;lhs = insert(p-&gt;lhs , l , mid , line);
    }
    else{
      p-&gt;rhs = insert(p-&gt;rhs , mid + 1, r , line);
    }
    return p;
  }
 
  void add_line(T a,T b){
    Line l(a , b);
    root = insert(root,MI,MA,l);
  }
 
  T get(Node * p,T l,T r,T t){
    if(!p) return ide;
    T mid = (l + r) / 2;
    if(t &lt;= mid) return comp_get(p-&gt;line.get(t) , get(p-&gt;lhs , l, mid,t));
    else return comp_get(p-&gt;line.get(t),get(p-&gt;rhs,mid + 1 ,r , t));
  }
 
  T get(T x){
    return get(root,MI,MA,x);
  }
};
</code></pre>
<h1><a class="header" href="#li-chao-segment-add-tree" id="li-chao-segment-add-tree">Li-Chao Segment Add Tree</a></h1>
<h3><a class="header" href="#code-5" id="code-5">Code</a></h3>
<pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;
using namespace std;

// doubleのときは, midを変える
template&lt;class T,const T ide,class Compare = greater&lt;T&gt;&gt;
struct li_chao{
  struct Line{
    T a,b;
    bool OK;
    Line(): a(0), b(0), OK(false) {}
    Line(T a,T b) : a(a) , b(b), OK(true) {}
    T get(T x){
      if(OK) {
        return a * x + b;
      }
      else {
        return ide;
      }
    }
  };
 
  struct Node{
    Line line;
    Node *lhs,*rhs;
    Node() : line(), lhs(nullptr), rhs(nullptr) {}
    Node(Line l) : line(l) , lhs(nullptr) , rhs(nullptr){}
  };
 
  const T MI,MA;
 
  Node * root;
 
  Compare comp;
 
  T comp_get(const T &amp; x,const T &amp; y){
    if(comp(x , y)) return x;
    else return y;
  }
 
  li_chao(T mi , T ma) : MI(mi), MA(ma) , root(nullptr){}
 
  Node * insert(Node * p,T l,T r,Line &amp; line){
    if(l &gt; r) {
      return p;
    }
    if(!p) return new Node(line);
    if(comp(p-&gt;line.get(l) , line.get(l)) &amp;&amp; comp(p-&gt;line.get(r) ,line.get(r))){
      return p;
    }
    if(!comp(p-&gt;line.get(l) , line.get(l)) &amp;&amp; !comp(p-&gt;line.get(r) ,line.get(r))){
      p-&gt;line = line;
      return p;
    }
    T mid = (l + r) / 2;
    if(r - l == 1) {
      mid = l;
    }
    if(comp(line.get(mid) , p-&gt;line.get(mid))) swap(p-&gt;line , line);
    if(comp(line.get(l) , p-&gt;line.get(l))){
      p-&gt;lhs = insert(p-&gt;lhs , l , mid , line);
    }
    else{
      p-&gt;rhs = insert(p-&gt;rhs , mid + 1, r , line);
    }
    return p;
  }

  Node* insert_rec(Node* p, T l, T r, Line line, T a, T b) {
    if(r &lt; a || b &lt; l) {
      return p;
    }
    if(a &lt;= l &amp;&amp; r &lt;= b) {
      return insert(p, l, r, line);
    }
    T mid = (l + r) / 2;
    if(r - l == 1) {
      mid = l;
    }
    if(!p) {
      p = new Node();
    }
    p-&gt;lhs = insert_rec(p-&gt;lhs, l, mid, line, a, b);
    p-&gt;rhs = insert_rec(p-&gt;rhs, mid + 1, r, line, a, b);
    return p;
  }
 
  void add_line(T a,T b){
    Line l(a , b);
    root = insert(root,MI,MA,l);
  }

  void add_line_range(T a, T b, T l, T r) {
    Line line(a, b);
    root = insert_rec(root, MI, MA, line, l, r);
  }
 
  T get(Node * p,T l,T r,T t){
    if(!p) return ide;
    T mid = (l + r) / 2;
    if(r - l == 1) {
      mid = l;
    }
    if(t &lt;= mid) return comp_get(p-&gt;line.get(t) , get(p-&gt;lhs , l, mid,t));
    else return comp_get(p-&gt;line.get(t),get(p-&gt;rhs,mid + 1 ,r , t));
  }

  T get_rec(Node* p, T l, T r, T t, T a, T b) {
    if(!p) return ide;
    if(r &lt;= a || b &lt;= l) {
      return ide;
    }
    if(a &lt;= l &amp;&amp; r &lt;= b) {
      return get(p, l, r, t);
    }
    T mid = (l + r) / 2;
    return comp_get(get_rec(p, l, mid, t, a, b), get_rec(p, mid + 1, r, t, a, b));
  }
 
  T get(T x){
    return get(root,MI,MA,x);
  }

  T get_range(T x, T l, T r) {
    return get_rec(root, MI, MA, l, r);
  }
};

#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;
#define rep(i,s,e) for(i64 (i) = (s);(i) &lt; (e);(i)++)
#define all(x) x.begin(),x.end()

template&lt;class T&gt;
static inline std::vector&lt;T&gt; ndvec(size_t&amp;&amp; n, T val) noexcept {
  return std::vector&lt;T&gt;(n, std::forward&lt;T&gt;(val));
}

template&lt;class... Tail&gt;
static inline auto ndvec(size_t&amp;&amp; n, Tail&amp;&amp;... tail) noexcept {
  return std::vector&lt;decltype(ndvec(std::forward&lt;Tail&gt;(tail)...))&gt;(n, ndvec(std::forward&lt;Tail&gt;(tail)...));
}

int main() {
  cin.tie(nullptr);
  std::ios::sync_with_stdio(false);
  i64 N, Q;
  cin &gt;&gt; N &gt;&gt; Q;
  li_chao&lt;i64, (i64)(LLONG_MAX), std::less&lt;i64&gt;&gt; seg(i64(-1e9 - 1), i64(1e9 + 1));
  while(N--) {
    i64 l, r, a, b;
    cin &gt;&gt; l &gt;&gt; r &gt;&gt; a &gt;&gt; b;
    seg.add_line_range(a, b, l, r - 1);
  }
  while(Q--) {
    i64 t;
    cin &gt;&gt; t;
    if(t == 0) {
      i64 l, r, a, b;
      cin &gt;&gt; l &gt;&gt; r &gt;&gt; a &gt;&gt; b;
      seg.add_line_range(a, b, l, r - 1);
    }
    else {
      i64 p;
      cin &gt;&gt; p;
      i64 ans = seg.get(p);
      if(ans == LLONG_MAX) {
        cout &lt;&lt; &quot;INFINITY&quot; &lt;&lt; &quot;\n&quot;;
      }
      else {
        cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
      }
    }
  }
}
</code></pre>
<h1><a class="header" href="#segment-tree-beats-chmin--sum" id="segment-tree-beats-chmin--sum">Segment Tree Beats (chmin + sum)</a></h1>
<h3><a class="header" href="#code-6" id="code-6">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
using i64 = long long;

struct segment_tree_chmin_rsq {
  using T = i64;

  const T ide = 0;
  const T m_ide = -1e18;


  std::vector&lt;T&gt; sum;
  std::vector&lt;T&gt; m1, m2;
  std::vector&lt;i64&gt; mcnt;
  i64 n;
  i64 h;

  void fix(int k) {
    sum[k] = sum[k * 2 + 0] + sum[k * 2 + 1];
    if(m1[k * 2 + 1] &lt; m1[k * 2 + 0]) {
      m1[k] = m1[k * 2 + 0];
      mcnt[k] = mcnt[k * 2 + 0];
      m2[k] = std::max(m2[k * 2 + 0], m1[k * 2 + 1]);
    }
    else if(m1[k * 2 + 0] &lt; m1[k * 2 + 1]) {
      m1[k] = m1[k * 2 + 1];
      mcnt[k] = mcnt[k * 2 + 1];
      m2[k] = std::max(m2[k * 2 + 1], m1[k * 2 + 0]);
    }
    else {
      m1[k] = m1[k * 2 + 0];
      mcnt[k] = mcnt[k * 2 + 0] + mcnt[k * 2 + 1];
      m2[k] = std::max(m2[k * 2 + 0], m2[k * 2 + 1]);
    }
  }

  segment_tree_chmin_rsq() {}
  segment_tree_chmin_rsq(const std::vector&lt;i64&gt;&amp; vec) {
    n = 1;
    h = 1;
    while(n &lt; vec.size()) n &lt;&lt;= 1, h++;
    sum.resize(2 * n);
    m1.resize(2 * n);
    m2.resize(2 * n, m_ide);
    mcnt.resize(2 * n, 0);
    for(i64 i = 0;i &lt; vec.size();i++) {
      sum[i + n] = vec[i];
      m1[i + n] = vec[i];
      mcnt[i + n] = 1;
    }
    for(i64 i = n; i --&gt; 1;) {
      fix(i);
    }
  }


  void eff(int k, T x) {
    sum[k] += (x - m1[k]) * mcnt[k];
    m1[k] = x;
  }

  void push(int k) {
    if(m1[k] &lt; m1[k * 2 + 0]) eff(k * 2 + 0, m1[k]);
    if(m1[k] &lt; m1[k * 2 + 1]) eff(k * 2 + 1, m1[k]);
  }

  void infuse(int k) {
    k = k &gt;&gt; __builtin_ctz(k);
    while(k &gt;&gt;= 1) fix(k);
  }

  void infiltrate(int k) {
    if(k == n &lt;&lt; 1) return;
    for(int i = h; i --&gt; 1;) push(k &gt;&gt; i);
  }

  void subtree_chmin(int k, T x) {
    if(m1[k] &lt;= x) return;
    if(m2[k] &lt; x) {
      eff(k, x);
      return;
    }
    push(k);
    subtree_chmin(k * 2 + 0, x);
    subtree_chmin(k * 2 + 1, x);
    fix(k);
  }

  void range_chmin(int a, int b, T x) {
    infiltrate(a + n);
    infiltrate(b + n);
    int l = a + n;
    int r = b + n;
    while(l &lt; r) {
      if(l &amp; 1) subtree_chmin(l++, x);
      if(r &amp; 1) subtree_chmin(--r, x);
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
    }
    infuse(a + n);
    infuse(b + n);
  }

  T range_sum(int l, int r) {
    l += n;
    r += n;
    infiltrate(l);
    infiltrate(r);
    T lx = ide;
    T rx = ide;
    while(l &lt; r) {
      if(l &amp; 1) lx = lx + sum[l++];
      if(r &amp; 1) rx = sum[--r] + rx;
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
    }
    return lx + rx;
  }
};

#include &lt;iostream&gt;
using std::cout;
using std::endl;

int main() {
  segment_tree_chmin_rsq seg(std::vector&lt;i64&gt;{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 });

  cout &lt;&lt; seg.range_sum(1, 5) &lt;&lt; endl;
  cout &lt;&lt; seg.range_sum(6, 10) &lt;&lt; endl;
  seg.range_chmin(0, 16, 5);
  cout &lt;&lt; seg.range_sum(5, 10) &lt;&lt; endl;
}
</code></pre>
<h1><a class="header" href="#segment-tree-beats-chmin--chmax--sum" id="segment-tree-beats-chmin--chmax--sum">Segment Tree Beats (chmin + chmax + sum)</a></h1>
<h3><a class="header" href="#code-7" id="code-7">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;limits&gt;
using i64 = long long;

struct segment_tree_chminmax_rsq {
  using T = i64;

  const T ide = 0;
  const T INF = std::numeric_limits&lt;T&gt;::max();
  const T NINF = std::numeric_limits&lt;T&gt;::min();


  std::vector&lt;T&gt; sum;
  std::vector&lt;T&gt; gst1, gst2;
  std::vector&lt;T&gt; lst1, lst2;
  std::vector&lt;i64&gt; mcnt;
  i64 n;
  i64 h;

  void fix(int k) {
    sum[k] = sum[k * 2 + 0] + sum[k * 2 + 1];

    if(gst1[k * 2 + 1] &lt; gst1[k * 2 + 0]) {
      gst1[k] = gst1[k * 2 + 0];
      mcnt[k] = mcnt[k * 2 + 0];
      gst2[k] = std::max(gst2[k * 2 + 0], gst1[k * 2 + 1]);
    }
    else if(gst1[k * 2 + 0] &lt; gst1[k * 2 + 1]) {
      gst1[k] = gst1[k * 2 + 1];
      mcnt[k] = mcnt[k * 2 + 1];
      gst2[k] = std::max(gst2[k * 2 + 1], gst1[k * 2 + 0]);
    }
    else {
      gst1[k] = gst1[k * 2 + 0];
      mcnt[k] = mcnt[k * 2 + 0] + mcnt[k * 2 + 1];
      gst2[k] = std::max(gst2[k * 2 + 0], gst2[k * 2 + 1]);
    }

    if(lst1[k * 2 + 0] &lt; lst1[k * 2 + 1]) {
      lst1[k] = lst1[k * 2 + 0];
      mcnt[k] = mcnt[k * 2 + 0];
      lst2[k] = std::min(lst2[k * 2 + 0], lst1[k * 2 + 1]);
    }
    else if(lst1[k * 2 + 1] &lt; lst1[k * 2 + 0]) {
      lst1[k] = lst1[k * 2 + 1];
      mcnt[k] = mcnt[k * 2 + 1];
      lst2[k] = std::min(lst2[k * 2 + 1], lst1[k * 2 + 0]);
    }
    else {
      lst1[k] = lst1[k * 2 + 0];
      mcnt[k] = mcnt[k * 2 + 0] + mcnt[k * 2 + 1];
      lst2[k] = std::min(lst2[k * 2 + 0], lst2[k * 2 + 1]);
    }
  }

  segment_tree_chmin_rsq() {}
  segment_tree_chmin_rsq(const std::vector&lt;i64&gt;&amp; vec) {
    n = 1;
    h = 1;
    while(n &lt; vec.size()) n &lt;&lt;= 1, h++;
    sum.resize(2 * n);
    gst1.resize(2 * n);
    gst2.resize(2 * n, NINF);
    lst1.resize(2 * n);
    lst2.resize(2 * n, INF);
    mcnt.resize(2 * n, 0);
    for(i64 i = 0;i &lt; vec.size();i++) {
      sum[i + n] = vec[i];
      gst1[i + n] = vec[i];
      lst1[i + n] = vec[i];
      mcnt[i + n] = 1;
    }
    for(i64 i = n; i --&gt; 1;) {
      fix(i);
    }
  }

  void eff_chmin(int k, T x) {
    sum[k] += (x - gst1[k]) * mcnt[k];
    if(gst1[k] == lst1[k]) {
      gst1[k] = lst1[k] = x;
    }
    else if(gst1[k] == lst2[k]) {
      gst1[k] = lst2[k] = x;
    }
    else {
      gst1[k] = x;
    }
  }

  void eff_chmax(int k, T x) {
    sum[k] += (x - lst1[k]) * mcnt[k];
    if(lst1[k] == gst1[k]) {
      lst1[k] = gst1[k] = x;
    }
    else if(lst1[k] == gst2[k]) {
      lst1[k] = gst2[k] = x;
    }
    else {
      lst1[k] = x;
    }
  }

  void push(int k) {
    if(gst1[k] &lt; gst1[k * 2 + 0]) eff_chmin(k * 2 + 0, gst1[k]);
    if(gst1[k] &lt; gst1[k * 2 + 1]) eff_chmin(k * 2 + 1, gst1[k]);

    if(lst1[k] &gt; lst1[k * 2 + 0]) eff_chmax(k * 2 + 0, gst1[k]);
    if(lst1[k] &gt; lst1[k * 2 + 1]) eff_chmax(k * 2 + 1, gst1[k]);
  }

  void infuse(int k) {
    k = k &gt;&gt; __builtin_ctz(k);
    while(k &gt;&gt;= 1) fix(k);
  }

  void infiltrate(int k) {
    if(k == n &lt;&lt; 1) return;
    for(int i = h; i --&gt; 1;) push(k &gt;&gt; i);
  }

  void subtree_chmin(int k, T x) {
    if(gst1[k] &lt;= x) return;
    if(gst2[k] &lt; x) {
      eff_chmin(k, x);
      return;
    }
    push(k);
    subtree_chmin(k * 2 + 0, x);
    subtree_chmin(k * 2 + 1, x);
    fix(k);
  }

  void subtree_chmax(int k, T x) {
    if(x &lt;= lst1[k]) return;
    if(x &lt; lst2[k]) {
      eff_chmax(k, x);
      return;
    }
    push(k);
    subtree_chmax(k * 2 + 0, x);
    subtree_chmax(k * 2 + 1, x);
    fix(k);
  }

  void range_chmin(int a, int b, T x) {
    infiltrate(a + n);
    infiltrate(b + n);
    int l = a + n;
    int r = b + n;
    while(l &lt; r) {
      if(l &amp; 1) subtree_chmin(l++, x);
      if(r &amp; 1) subtree_chmin(--r, x);
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
    }
    infuse(a + n);
    infuse(b + n);
  }

  void range_chmax(int a, int b, T x) {
    infiltrate(a + n);
    infiltrate(b + n);
    int l = a + n;
    int r = b + n;
    while(l &lt; r) {
      if(l &amp; 1) subtree_chmax(l++, x);
      if(r &amp; 1) subtree_chmax(--r, x);
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
    }
    infuse(a + n);
    infuse(b + n);
  }

  T range_sum(int l, int r) {
    l += n;
    r += n;
    infiltrate(l);
    infiltrate(r);
    T lx = ide;
    T rx = ide;
    while(l &lt; r) {
      if(l &amp; 1) lx = lx + sum[l++];
      if(r &amp; 1) rx = sum[--r] + rx;
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
    }
    return lx + rx;
  }
};

#include &lt;iostream&gt;
using std::cout;
using std::endl;

int main() {
  segment_tree_chmin_rsq seg(std::vector&lt;i64&gt;{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 });

  cout &lt;&lt; seg.range_sum(1, 5) &lt;&lt; endl;
  cout &lt;&lt; seg.range_sum(6, 10) &lt;&lt; endl;
  seg.range_chmax(0, 5, 2);
  seg.range_chmin(0, 5, 3);
  cout &lt;&lt; seg.range_sum(0, 5) &lt;&lt; endl;
}
</code></pre>
<h1><a class="header" href="#segment-tree-beats-chmin--chmax--add--sum" id="segment-tree-beats-chmin--chmax--add--sum">Segment Tree Beats (chmin + chmax + add + sum)</a></h1>
<h3><a class="header" href="#code-8" id="code-8">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;limits&gt;
using i64 = long long;

struct segment_tree_chminmaxadd_rsq {
  using T = i64;

  const T ide = 0;
  static const T INF = std::numeric_limits&lt;T&gt;::max();
  static const T NINF = std::numeric_limits&lt;T&gt;::min();

  struct node {
    T sum;
    T gst1, gst2, gcnt;
    T lst1, lst2, lcnt;
    i64 len;
    i64 add;
    node(): gst2(NINF), gcnt(1), lst2(INF), lcnt(1), len(1), add(0) {}
  };

  std::vector&lt;node&gt; v;

  i64 n;
  i64 h;

  void fix(int k) {
    node&amp; p = v[k];
    node&amp; l = v[k * 2 + 0];
    node&amp; r = v[k * 2 + 1];
    p.sum = l.sum + r.sum;

    if(r.gst1 &lt; l.gst1) {
      p.gst1 = l.gst1;
      p.gcnt = l.gcnt;
      p.gst2 = std::max(l.gst2, r.gst1);
    }
    else if(l.gst1 &lt; r.gst1) {
      p.gst1 = r.gst1;
      p.gcnt = r.gcnt;
      p.gst2 = std::max(l.gst1, r.gst2);
    }
    else {
      p.gst1 = l.gst1;
      p.gcnt = l.gcnt + r.gcnt;
      p.gst2 = std::max(l.gst2, r.gst2);
    }

    if(r.lst1 &gt; l.lst1) {
      p.lst1 = l.lst1;
      p.lcnt = l.lcnt;
      p.lst2 = std::min(l.lst2, r.lst1);
    }
    else if(l.lst1 &gt; r.lst1) {
      p.lst1 = r.lst1;
      p.lcnt = r.lcnt;
      p.lst2 = std::min(l.lst1, r.lst2);
    }
    else {
      p.lst1 = l.lst1;
      p.lcnt = l.lcnt + r.lcnt;
      p.lst2 = std::min(l.lst2, r.lst2);
    }

  }

  segment_tree_chminmaxadd_rsq() {}
  segment_tree_chminmaxadd_rsq(const std::vector&lt;i64&gt;&amp; vec) {
    n = 1;
    h = 1;
    while(n &lt; vec.size()) n &lt;&lt;= 1, h++;
    v.resize(2 * n);
    for(i64 i = 0;i &lt; vec.size();i++) {
      v[i + n].sum = vec[i];
      v[i + n].gst1 = vec[i];
      v[i + n].lst1 = vec[i];
    }
    for(i64 i = n; i --&gt; 1;) {
      fix(i);
      v[i].len = v[i * 2 + 0].len + v[i * 2 + 1].len;
    }
  }

  void eff_add(int k, T x) {
    auto&amp; p = v[k];
    p.sum  += x * p.len;
    p.gst1 += x;
    p.lst1 += x;
    p.add += x;
    if(p.gst2 != NINF) p.gst2 += x;
    if(p.lst2 !=  INF) p.lst2 += x;
  }

  void eff_chmin(int k, T x) {
    auto&amp; p = v[k];
    p.sum += (x - p.gst1) * p.gcnt;
    if(p.gst1 == p.lst1) {
      p.gst1 = p.lst1 = x;
    }
    else if(p.gst1 == p.lst2) {
      p.gst1 = p.lst2 = x;
    }
    else {
      p.gst1 = x;
    }
  }

  void eff_chmax(int k, T x) {
    auto&amp; p = v[k];
    p.sum += (x - p.lst1) * p.lcnt;
    if(p.lst1 == p.gst1) {
      p.lst1 = p.gst1 = x;
    }
    else if(p.lst1 == p.gst2) {
      p.lst1 = p.gst2 = x;
    }
    else {
      p.lst1 = x;
    }
  }

  void push(int k) {
    if(k &gt;= n) return;
    auto&amp; p = v[k];
    if(p.add != 0) {
      eff_add(k * 2 + 0, p.add);
      eff_add(k * 2 + 1, p.add);
      p.add = 0;
    }
    if(p.gst1 &lt; v[k * 2 + 0].gst1) eff_chmin(k * 2 + 0, p.gst1);
    if(p.gst1 &lt; v[k * 2 + 1].gst1) eff_chmin(k * 2 + 1, p.gst1);

    if(p.lst1 &gt; v[k * 2 + 0].lst1) eff_chmax(k * 2 + 0, p.lst1);
    if(p.lst1 &gt; v[k * 2 + 1].lst1) eff_chmax(k * 2 + 1, p.lst1);
  }

  void infuse(int k) {
    k = k &gt;&gt; __builtin_ctz(k);
    while(k &gt;&gt;= 1) fix(k);
  }

  inline void infiltrate(int k) {
    if(k == n &lt;&lt; 1) return;
    int kc = __builtin_ctz(k);
    for(int i = h; i --&gt; kc;) push(k &gt;&gt; i);
  }

  inline void infiltrate(int l, int r) {
    if(r == n &lt;&lt; 1) infiltrate(l);
    else {
      int hh = h;
      int x = l ^ r;
      for(; !(x &gt;&gt; --hh) &amp;&amp; hh;) push(l &gt;&gt; hh);
      int lc = __builtin_ctz(l);
      for(int i = hh + 1; i --&gt; lc;) push(l &gt;&gt; i);
      int rc = __builtin_ctz(r);
      for(int i = hh + 1; i --&gt; rc;) push(r &gt;&gt; i);
    }
  }

  void subtree_chmin(int k, T x) {
    if(v[k].gst1 &lt;= x) return;
    if(v[k].gst2 &lt; x) {
      eff_chmin(k, x);
      return;
    }
    push(k);
    subtree_chmin(k * 2 + 0, x);
    subtree_chmin(k * 2 + 1, x);
    fix(k);
  }

  void subtree_chmax(int k, T x) {
    if(x &lt;= v[k].lst1) return;
    if(x &lt; v[k].lst2) {
      eff_chmax(k, x);
      return;
    }
    push(k);
    subtree_chmax(k * 2 + 0, x);
    subtree_chmax(k * 2 + 1, x);
    fix(k);
  }

  void range_chmin(int a, int b, T x) {
    int l = a + n;
    int r = b + n;
    infiltrate(l, r);
    while(l &lt; r) {
      if(l &amp; 1) subtree_chmin(l++, x);
      if(r &amp; 1) subtree_chmin(--r, x);
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
    }
    infuse(a + n);
    infuse(b + n);
  }

  void range_chmax(int a, int b, T x) {
    int l = a + n;
    int r = b + n;
    infiltrate(l, r);
    while(l &lt; r) {
      if(l &amp; 1) subtree_chmax(l++, x);
      if(r &amp; 1) subtree_chmax(--r, x);
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
    }
    infuse(a + n);
    infuse(b + n);
  }

  void range_add(int a, int b, T x) {
    int l = a + n;
    int r = b + n;
    infiltrate(l, r);
    while(l &lt; r) {
      if(l &amp; 1) eff_add(l++, x);
      if(r &amp; 1) eff_add(--r, x);
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
    }
    infuse(a + n);
    infuse(b + n);
  }

  T range_sum(int l, int r) {
    l += n;
    r += n;
    infiltrate(l, r);
    T lx = ide;
    T rx = ide;
    while(l &lt; r) {
      if(l &amp; 1) lx = lx + v[l++].sum;
      if(r &amp; 1) rx = v[--r].sum + rx;
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
    }
    return lx + rx;
  }
};
</code></pre>
<h1><a class="header" href="#heap" id="heap">Heap</a></h1>
<h1><a class="header" href="#pairing-heap" id="pairing-heap">Pairing Heap</a></h1>
<p>マージ可能で高速なHeap</p>
<h3><a class="header" href="#spec-5" id="spec-5">Spec</a></h3>
<ul>
<li>
<p><code>top()</code></p>
<ul>
<li>最小値を返す</li>
<li>\( O(1) \)</li>
</ul>
</li>
<li>
<p><code>pop()</code></p>
<ul>
<li>最小値の要素を削除する</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
<li>
<p><code>push(const T&amp; x)</code></p>
<ul>
<li>要素<code>x</code>を追加する</li>
<li>\( O(1) \)</li>
</ul>
</li>
<li>
<p><code>meld(h)</code></p>
<ul>
<li>ヒープ<code>h</code>とマージする</li>
<li>\( O(1) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-9" id="code-9">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
using namespace std;

template&lt;class T, class Compare&gt;
struct pairing_heap {
  struct node {
    T val;
    node* head;
    node* next;
    node(const T&amp; v) : val(v), head(nullptr), next(nullptr) {  }
  };
  size_t sz;
  node* root;
  Compare comp;
  pairing_heap() : sz(0), root(nullptr) {  }
  node* merge(node* x, node* y) {
    if(!y) return x;
    if(!x) return y;
    if(!comp(x-&gt;val, y-&gt;val)) swap(x,y);
    y-&gt;next = x-&gt;head;
    x-&gt;head = y;
    return x;
  }
  node* mergeList(node * x) {
    node* nn = nullptr;
    while(x) {
      node* a = x;
      node* b = nullptr;
      x = x-&gt;next;
      a-&gt;next = nullptr;
      if(x) {
        b = x;
        x = x-&gt;next;
        b-&gt;next = nullptr;
      }
      a = merge(a, b);
      a-&gt;next = nn;
      nn = a;
    }
    while(nn) {
      node* j = nn;
      nn = nn-&gt;next;
      x = merge(j,x);
    }
    return x;
  }
  
  /* return compest element */
  T top() {
    return root-&gt;val;
  }

  /* pop compest element */
  void pop() {
    --sz;
    node* te = root;
    root = mergeList(root-&gt;head);
    delete te, te = nullptr;
  }
  
  /* add element */
  void push(const T&amp; x) {
    ++sz;
    root = merge(new node(x), root);
  }
  
  /* size */
  size_t size() {
    return sz;
  }
  
  /* merge heap */
  void meld(pairing_heap&lt;T,Compare&gt;&amp; h) {
    root = merge(root, h.root);
    h.root = nullptr;
    h.sz = 0;
  }
};
</code></pre>
<h1><a class="header" href="#trees" id="trees">Trees</a></h1>
<p>木を処理するやつ</p>
<ul>
<li><a href="data_structures/trees/./euler_tour_subtree.html">EulerTour Subtree</a></li>
<li><a href="data_structures/trees/./euler_tour_path.html">EulerTour Path</a></li>
<li><a href="data_structures/trees/./heavy_light_decomposition.html">Heavy Light Decomposition</a></li>
<li><a href="data_structures/trees/./link_cut_tree.html">Link Cut Tree</a></li>
<li><a href="data_structures/trees/./toptree.html">Top Tree</a></li>
</ul>
<h1><a class="header" href="#eulertour-subtree" id="eulertour-subtree">EulerTour Subtree</a></h1>
<p>EulerTourの部分木を処理するバージョン<br />
木を列に落とし込んだときの部分木の範囲がわかるので, <a href="data_structures/trees/../segment_tree/segment_tree.html">Segment Tree</a>と合わせて使うといい.</p>
<p>LCAをET Subtree + RMQで求める場合はコメントアウトしてある部分を使う.</p>
<h3><a class="header" href="#spec-6" id="spec-6">Spec</a></h3>
<ul>
<li>
<p><code>eulertour_subtree(i64 n)</code></p>
<ul>
<li><code>n</code>頂点の木を構築する準備</li>
</ul>
</li>
<li>
<p><code>add_edge(i64 u, i64 v)</code></p>
<ul>
<li>頂点<code>u</code>と<code>v</code>を結ぶ辺を追加する</li>
</ul>
</li>
<li>
<p><code>start_tour(i64 r)</code></p>
<ul>
<li><code>r</code>を根としてEulerTourを行う</li>
<li>\( O(n) \)</li>
</ul>
</li>
<li>
<p><code>subtree_range(i64 v)</code></p>
<ul>
<li>頂点<code>v</code>の部分木に対応する範囲を返す</li>
<li>\( O(1) \)</li>
</ul>
</li>
<li>
<p><code>vertex(i64 v)</code></p>
<ul>
<li>頂点<code>v</code>に対応するindexを返す.</li>
<li>\( O(1) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-10" id="code-10">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct eulertour_subtree {
  vector&lt;vector&lt;i64&gt;&gt; G;
  vector&lt;i64&gt; tour;
  vector&lt;i64&gt; L, R;
  vector&lt;i64&gt; depth;
  eulertour_subtree(i64 n): G(n), L(n), R(n), depth(n) {}
  void add_edge(i64 u, i64 v) {
    G[u].push_back(v);
    G[v].push_back(u);
  }

  void dfs(i64 v, i64 f, i64 d) {
    tour.push_back(v);
    L[v] = tour.size() - 1;
    depth[v] = d;
    for(auto to: G[v]) {
      if(to == f) continue;
      dfs(to, v, d + 1);
      //tour.push_back(v);
    }
    R[v] = tour.size() - 1;
  }

  void start_tour(i64 r) {
    dfs(r, -1, 0);
  }

  //[L[v], R[v])
  pair&lt;i64, i64&gt; subtree_range(i64 v) {
    return pair&lt;i64, i64&gt;(L[v], R[v]);
  }

  i64 vertex(i64 v) {
    return L[v];
  }
};
</code></pre>
<h1><a class="header" href="#eulertour-path" id="eulertour-path">EulerTour Path</a></h1>
<p>EulerTourのパスを処理するバージョン<br />
パスとして求められるのは, 上から下に降りるようなパスだけなので, 任意のパスを扱うときはLCAをしないといけない.<br />
扱える要素には, 可逆性, 可換性(?)が必要.</p>
<h3><a class="header" href="#spec-7" id="spec-7">Spec</a></h3>
<ul>
<li>
<p><code>euler_tour_path(i64 n)</code></p>
<ul>
<li><code>n</code>頂点の木を構築する準備</li>
</ul>
</li>
<li>
<p><code>add_edge(i64 u, i64 v)</code></p>
<ul>
<li>頂点<code>u</code>と<code>v</code>を結ぶ辺を追加する</li>
</ul>
</li>
<li>
<p><code>start_tour(i64 r)</code></p>
<ul>
<li><code>r</code>を根としてEulerTourを行う</li>
<li>\( O(n) \)</li>
</ul>
</li>
<li>
<p><code>edge_in(i64 v)</code></p>
<ul>
<li>頂点<code>v</code>に入る辺のindexを返す</li>
<li>\( O(1) \)</li>
</ul>
</li>
<li>
<p><code>edge_out(i64 v)</code></p>
<ul>
<li>頂点<code>v</code>に出る辺のindexを返す</li>
<li>\( O(1) \)</li>
</ul>
</li>
<li>
<p><code>path_range(i64 u, i64 v)</code></p>
<ul>
<li>頂点<code>u</code>から降りて頂点<code>v</code>に辿るパスの範囲を返す.</li>
<li>\( O(1) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-11" id="code-11">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct eulartour_path {
  vector&lt;vector&lt;i64&gt;&gt; G;
  vector&lt;i64&gt; in, out;
  i64 cnt;
  eulartour_path(i64 n): G(n), in(n), out(n) {}
  void add_edge(i64 u, i64 v) {
    G[u].push_back(v);
    G[v].push_back(u);
  }

  void dfs(i64 v, i64 f) {
    for(auto to: G[v]) {
      if(to == f) continue;
      in[to] = cnt;
      cnt++;
      dfs(to, v);
      out[to] = cnt;
      cnt++;
    }
  }

  void start_tour(i64 r) {
    in[r] = cnt;
    cnt++;
    dfs(r, -1);
  }

  i64 edge_in(i64 v) { return in[v]; }
  i64 edge_out(i64 v) { return out[v]; }
  pair&lt;i64, i64&gt; path_range(i64 u, i64 v) {
    return { in[u] + 1, in[v] + 1 };
  }
};


</code></pre>
<h1><a class="header" href="#heavy-light-decomposition" id="heavy-light-decomposition">Heavy Light Decomposition</a></h1>
<p>静的木</p>
<p>木のパスや部分木のクエリを処理できる.</p>
<h3><a class="header" href="#spec-8" id="spec-8">Spec</a></h3>
<ul>
<li>
<p><code>HeavyLightDecomposition(i64 n)</code></p>
<ul>
<li>頂点数<code>n</code>で初期化</li>
</ul>
</li>
<li>
<p><code>add_edge(i64 u, i64 v)</code></p>
<ul>
<li>頂点<code>u</code>と<code>v</code>をつなぐ</li>
</ul>
</li>
<li>
<p><code>build(i64 r)</code></p>
<ul>
<li><code>r</code>を根としてHLDecompを行う</li>
</ul>
</li>
<li>
<p><code>sequence()</code></p>
<ul>
<li>HLDecompしたときのオイラーツアーの配列.</li>
</ul>
</li>
<li>
<p><code>path(i64 a, i64 b, bool edge)</code></p>
<ul>
<li>パスの列を返す.</li>
<li><code>edge = true</code>で辺に対するパスを返す.</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
<li>
<p><code>subtree(i64 v, bool edge)</code></p>
<ul>
<li>部分木の列を返す.</li>
<li><code>edge = true</code>で辺に対するパスを返す.</li>
<li>\( O(1) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-12" id="code-12">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct HeavyLightDecomposition {
  vector&lt;vector&lt;i64&gt;&gt; G;
  vector&lt;i64&gt; in, out;
  vector&lt;i64&gt; sz;
  vector&lt;i64&gt; seq;
  vector&lt;i64&gt; next;
  vector&lt;i64&gt; par;


  HeavyLightDecomposition(i64 n)
    : G(n), in(n), out(n), sz(n), next(n, -1), par(n, -1) {}

  void add_edge(i64 u, i64 v) {
    G[u].push_back(v);
    G[v].push_back(u);
  }

  void dfs_sz(i64 v, i64 f) {
    sz[v] = 1;
    for(i64 i = 0;i &lt; G[v].size();i++) {
      i64 x = G[v][i];
      if(x == f) continue;
      dfs_sz(x, v);
      par[x] = v;
      sz[v] += sz[x];
      if(sz[G[v][0]] &lt; sz[G[v][i]]) { swap(G[v][0], G[v][i]); }
    }
  }

  i64 dfs_eul(i64 v, i64 f, i64 t) {
    in[v] = t++;
    seq.push_back(v);
    for(i64 i = 0;i &lt; G[v].size();i++) {
      i64 x = G[v][i];
      if(x == f) continue;
      next[x] = (i == 0) ? next[v] : x;
      t = dfs_eul(x, v, t);
    }
    return out[v] = t;
  }

  void build(i64 r) {
    dfs_sz(r, -1);
    dfs_eul(r, -1, 0);
  }

  const vector&lt;i64&gt;&amp; sequence() const { return seq; }
  i64 lca(i64 a, i64 b) const {
    while(true) {
      if(in[b] &gt; in[a]) swap(a, b);
      if(next[b] == next[a]) return b;
      a = par[next[a]];
    }
  }

  pair&lt;vector&lt;pair&lt;i64, i64&gt;&gt;, vector&lt;pair&lt;i64, i64&gt;&gt;&gt; path(i64 a, i64 b, bool edge) const {
    vector&lt;pair&lt;i64, i64&gt;&gt; l, r;
    while(true) {
      if(in[b] &gt; in[a]) { swap(a, b); swap(l, r); }
      if(next[b] == next[a]) {
        l.push_back({ in[b] + !!edge, in[a] + 1 });
        break;
      }
      l.push_back({ in[next[a]], in[a] + 1 });
      a = par[next[a]];
    }
    return { std::move(l), std::move(r) };
  }

  pair&lt;i64, i64&gt; subtree(i64 v, bool edge) { return { in[v] + !!edge, out[v] }; }
};
</code></pre>
<h1><a class="header" href="#link-cut-tree" id="link-cut-tree">Link Cut Tree</a></h1>
<p>動的木</p>
<p>パスのsumを計算したり, パスに対する作用を遅延伝搬できる.</p>
<h3><a class="header" href="#spec-9" id="spec-9">Spec</a></h3>
<ul>
<li>
<p><code>struct node</code></p>
<ul>
<li>link cut treeで扱うノードの構造体</li>
<li>この中に載せたいデータを載せる</li>
</ul>
</li>
<li>
<p><code>fix(node * n)</code></p>
<ul>
<li>ノードの情報の再計算をする</li>
</ul>
</li>
<li>
<p><code>reverse(node * n)</code></p>
<ul>
<li>平衡二分木の反転</li>
<li>モノイドの演算順序が反転するのでその処理を書く</li>
<li>モノイドが可換であれば問題ない</li>
</ul>
</li>
<li>
<p><code>lazy(node * n, i64 l)</code></p>
<ul>
<li>遅延伝搬するときの演算</li>
<li><code>expose(n); lazy(n, x)</code>をすると, <code>[root, n]</code>のパスに<code>x</code>を作用させることになる</li>
</ul>
</li>
<li>
<p><code>push(node* n)</code></p>
<ul>
<li>遅延伝搬</li>
<li>lazyを変えている場合はここも変更</li>
</ul>
</li>
<li>
<p><code>expose(node* n)</code></p>
<ul>
<li><code>n</code>をLink Cut Treeの根として, その木が<code>[root, n]</code>のパスをあらわすようになる</li>
</ul>
</li>
<li>
<p><code>link(node* p, node* c)</code></p>
<ul>
<li><code>p</code>を親, <code>c</code>を子として繋げる</li>
</ul>
</li>
<li>
<p><code>cut(node* c)</code></p>
<ul>
<li><code>c</code>の親とつながっている辺を切る</li>
</ul>
</li>
<li>
<p><code>evert(node* t)</code></p>
</li>
<li>
<p><code>t</code>を親にする</p>
</li>
</ul>
<h3><a class="header" href="#code-13" id="code-13">Code</a></h3>
<p>パス加算, パスsumを処理している</p>
<pre><code class="language-cpp">include &lt;cstdint&gt;
#include &lt;utility&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

using i64 = long long;

namespace lctree {

  struct R {
    int a;
    R(): a(0) {}
    R(int a): a(a) {}
  };
  struct V {
    int a;
    V(): a(0) {}
    V(int a): a(a) {}
  };
  inline V compress(const V&amp; a, const V&amp; b) { return V(a.a + b.a); }
  inline V rake_merge(const V&amp; a, const R&amp; b) { return V(a.a + b.a); }
  inline V reverse(const V&amp; a) { return a; }
  inline void rake_plus(R&amp; a, const V&amp; b) { a.a += b.a; }
  inline void rake_minus(R&amp; a, const V&amp; b) { a.a -= b.a; }

  struct node;
  extern struct node n[505050];
  extern int ni;

  using node_index = std::uint_least32_t;
  using size_type = std::size_t;

  struct node {
    node_index c[3];
    V v; V f; R r;
    bool rev;
    node(): rev(false) { c[0] = c[1] = c[2] = 0; }
    node&amp; operator[](int d) { return n[c[d]]; }
  };

  inline node_index new_node(V v) { n[ni].v = v; n[ni].f = v; return ni++; }
  inline void reverse(node_index i) {
    n[i].v = reverse(n[i].v);
    n[i].f = reverse(n[i].f);
    n[i].rev ^= true;
  }
  inline void push(node_index i) {
    if(n[i].rev) {
      std::swap(n[i].c[0], n[i].c[1]);
      if(n[i].c[0]) reverse(n[i].c[0]);
      if(n[i].c[1]) reverse(n[i].c[1]);
      n[i].rev = false;
    }
  }
  inline void fix(node_index i) {
    push(i);
    n[i].f = compress(compress(n[i][0].f, n[i].v), rake_merge(n[i][1].f, n[i].r));
  }

  inline int child_dir(node_index i) {
    if(n[i].c[2]) {
      if(n[i][2].c[0] == i) { return 0; }
      else if(n[i][2].c[1] == i) { return 1; }
    }
    return 3;
  }

  inline void rotate(node_index x, size_type dir) {
    node_index p = n[x].c[2];
    int x_dir = child_dir(x);
    node_index y = n[x].c[dir ^ 1];

    n[n[y][dir].c[2] = x].c[dir ^ 1] = n[y].c[dir];
    n[n[x].c[2] = y].c[dir] = x;
    n[y].c[2] = p;
    if(x_dir &lt; 2) n[p].c[x_dir] = y;
    fix(n[x].c[dir ^ 1]);
    fix(x);
  }

  void splay(node_index i) {
    push(i);
    int i_dir;
    int j_dir;
    while(child_dir(i) &lt; 2) {
      node_index j = n[i].c[2];
      if(child_dir(j) &lt; 2) {
        node_index k = n[j].c[2];
        push(k), push(j), push(i);
        i_dir = child_dir(i);
        j_dir = child_dir(j);
        if(i_dir == j_dir) rotate(k, j_dir ^ 1), rotate(j, i_dir ^ 1);
        else rotate(j, i_dir ^ 1), rotate(k, j_dir ^ 1);
      }
      else push(j), push(i), rotate(j, child_dir(i) ^ 1);
    }
    fix(i);
  }

  node_index expose(node_index i) {
    node_index right = 0;
    node_index ii = i;
    while(i) {
      splay(i);
      rake_minus(n[i].r, n[right].f);
      rake_plus(n[i].r, n[i][1].f);
      n[i].c[1] = right;
      fix(i);
      right = i;
      i = n[i].c[2];
    }
    splay(ii);
    return ii;
  }

  void link(node_index i, node_index j) {
    if(!i || !j) return;
    expose(i);
    expose(j);
    n[n[j].c[2] = i].c[1] = j;
    fix(i);
  }

  void cut(node_index i) {
    if(!i) return;
    expose(i);
    node_index p = n[i].c[0];
    n[i].c[0] = n[p].c[2] = 0;
    fix(i);
  }

  void evert(node_index i) {
    if(!i) return;
    expose(i);
    reverse(i);
    push(i);
  }

  node n[505050];
  int ni = 1;

  int all_tree(node_index i) {
    expose(i);
    return n[i].f.a;
  }
}

#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;
#define rep(i,s,e) for(i64 (i) = (s);(i) &lt; (e);(i)++)
#define all(x) x.begin(),x.end()

template&lt;class T&gt;
static inline std::vector&lt;T&gt; ndvec(size_t&amp;&amp; n, T val) noexcept {
  return std::vector&lt;T&gt;(n, std::forward&lt;T&gt;(val));
}

template&lt;class... Tail&gt;
static inline auto ndvec(size_t&amp;&amp; n, Tail&amp;&amp;... tail) noexcept {
  return std::vector&lt;decltype(ndvec(std::forward&lt;Tail&gt;(tail)...))&gt;(n, ndvec(std::forward&lt;Tail&gt;(tail)...));
}

template&lt;class T, class Cond&gt;
struct chain {
  Cond cond; chain(Cond cond) : cond(cond) {}
  bool operator()(T&amp; a, const T&amp; b) const {
    if(cond(a, b)) { a = b; return true; }
    return false;
  }
};
template&lt;class T, class Cond&gt;
chain&lt;T, Cond&gt; make_chain(Cond cond) { return chain&lt;T, Cond&gt;(cond); }

#include &lt;cstdio&gt;
 
namespace niu {
  char cur;
  struct FIN {
    static inline bool is_blank(char c) { return c &lt;= ' '; }
    inline char next() { return cur = getc_unlocked(stdin); }
    inline char peek() { return cur; }
    inline void skip() { while(is_blank(next())){} }
#define intin(inttype)  \
    FIN&amp; operator&gt;&gt;(inttype&amp; n) { \
      bool sign = 0; \
      n = 0; \
      skip(); \
      while(!is_blank(peek())) { \
        if(peek() == '-') sign = 1; \
        else n = (n &lt;&lt; 1) + (n &lt;&lt; 3) + (peek() &amp; 0b1111); \
        next(); \
      } \
      if(sign) n = -n; \
      return *this; \
    }
intin(int)
intin(long long)
  } fin;
 
  char tmp[128];
  struct FOUT {
    static inline bool is_blank(char c) { return c &lt;= ' '; }
    inline void push(char c) { putc_unlocked(c, stdout); }
    FOUT&amp; operator&lt;&lt;(char c) { push(c); return *this; }
    FOUT&amp; operator&lt;&lt;(const char* s) { while(*s) push(*s++); return *this; }
#define intout(inttype) \
    FOUT&amp; operator&lt;&lt;(inttype n) { \
      if(n) { \
        char* p = tmp + 127; bool neg = 0; \
        if(n &lt; 0) neg = 1, n = -n; \
        while(n) *--p = (n % 10) | 0b00110000, n /= 10; \
        if(neg) *--p = '-'; \
        return (*this) &lt;&lt; p; \
      } \
      else { \
        push('0'); \
        return *this; \
      } \
    }
intout(int)
intout(long long)
  } fout;
}

int main() {
  using niu::fin;
  using niu::fout;
  i64 N, Q;
  fin &gt;&gt; N;
  vector&lt;vector&lt;int&gt;&gt; vs(N);
  vector&lt;int&gt; co(N);
  for(int i = 0;i &lt; N;i++) {
    lctree::new_node(1);
    int a;
    fin &gt;&gt; a;
    a--;
    co[i] = a;
    vs[a].push_back(i);
  }
  vector&lt;vector&lt;int&gt;&gt; G(N);
  for(int i = 0;i + 1 &lt; N;i++) {
    i64 a, b;
    fin &gt;&gt; a &gt;&gt; b;
    a--;
    b--;
    G[a].push_back(b);
    if(co[a] != co[b])
      G[b].push_back(a);
    lctree::evert(b + 1);
    lctree::link(a + 1, b + 1);
  }
 
  auto func = [&amp;](i64 ans, i64 a, i64 b) {
    i64 A = lctree::all_tree(a);
    ans -= A * (A + 1) / 2;
    lctree::evert(a);
    lctree::cut(b);
    i64 B = lctree::all_tree(a);
    ans += B * (B + 1) / 2;
    i64 C = lctree::all_tree(b);
    ans += C * (C + 1) / 2;
    //std::cout &lt;&lt; A &lt;&lt; &quot; &quot; &lt;&lt; B &lt;&lt; &quot; &quot; &lt;&lt; C &lt;&lt; std::endl;
    return ans;
  };
  for(int i = 0;i &lt; N;i++) {
    i64 ans = (N - vs[i].size()) * ((N - vs[i].size()) + 1) / 2;
    for(auto v: vs[i]) {
      lctree::expose(v + 1);
      lctree::n[v + 1].v.a = 0;
      lctree::fix(v + 1);
    }
    for(auto v: vs[i]) {
      for(auto t: G[v]) {
        ans = func(ans, v + 1, t + 1);
      }
    }
    //cout &lt;&lt; ans &lt;&lt; endl;
    fout &lt;&lt; (N * (N + 1) / 2) - ans &lt;&lt; &quot;\n&quot;;
    for(auto v: vs[i]) {
      lctree::expose(v + 1);
      lctree::n[v + 1].v.a = 1;
      lctree::fix(v + 1);
    }
    for(auto v: vs[i]) {
      for(auto t: G[v]) {
        lctree::evert(t + 1);
        lctree::link(v + 1, t + 1);
      }
    }
  }
}
 
</code></pre>
<h1><a class="header" href="#top-tree" id="top-tree">Top Tree</a></h1>
<p>なにこれ</p>
<h3><a class="header" href="#spec-10" id="spec-10">Spec</a></h3>
<p>え</p>
<h3><a class="header" href="#code-14" id="code-14">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;
#define rep(i,s,e) for(i64 (i) = (s);(i) &lt; (e);(i)++)
#define all(x) x.begin(),x.end()

template&lt;class T&gt;
static inline std::vector&lt;T&gt; ndvec(size_t&amp;&amp; n, T val) noexcept {
  return std::vector&lt;T&gt;(n, std::forward&lt;T&gt;(val));
}

template&lt;class... Tail&gt;
static inline auto ndvec(size_t&amp;&amp; n, Tail&amp;&amp;... tail) noexcept {
  return std::vector&lt;decltype(ndvec(std::forward&lt;Tail&gt;(tail)...))&gt;(n, ndvec(std::forward&lt;Tail&gt;(tail)...));
}

template&lt;class T, class Cond&gt;
struct chain {
  Cond cond; chain(Cond cond) : cond(cond) {}
  bool operator()(T&amp; a, const T&amp; b) const {
    if(cond(a, b)) { a = b; return true; }
    return false;
  }
};
template&lt;class T, class Cond&gt;
chain&lt;T, Cond&gt; make_chain(Cond cond) { return chain&lt;T, Cond&gt;(cond); }

#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cassert&gt;
using i64 = long long;

namespace toptree {
  struct cluster {
    int length;

    using V = int;
    cluster(i64 l = 0): length(l) {}
    static cluster identity() {
      return cluster(0);
    }
    static V v_identity() {
      return 0;
    }
    static cluster compress(const cluster&amp; a, const cluster&amp; b, V, V, V cv) {
      return cluster(
          a.length + b.length + cv
          ); }
    static cluster rake(const cluster&amp; a, const cluster&amp; b, V av, V bv, V cv) {
      return cluster(
          a.length + b.length + bv
          );
    }
    static cluster reverse(const cluster&amp; c) {
      return c;
    }
    static std::size_t select(const cluster&amp;, const cluster&amp;, V, V, V) {
      return 0;
    }
  };

  struct vertex;
  struct node;

  using size_type = std::size_t;
  using node_index = std::uint_least32_t;
  using vertex_index = std::uint_least32_t;

  extern struct vertex v[404040];
  extern size_type vi;
  extern struct node n[2020202];
  extern size_type ni;
  extern node_index guard;

  void link(node_index a, node_index b, cluster weight);

  struct vertex {
    cluster::V val;
    node_index hn;
  };

   vertex_index new_vertex(cluster::V val) {
    v[vi++] = { val, 0 };
    v[vi++] = { cluster::v_identity(), 0 };
    link(vi - 2, vi - 1, cluster::identity());
    return vi - 2;
  }


  enum class type { Compress, Rake, Edge };


  struct node {
    node_index i;
    node_index c[4];
    bool rev;
    cluster f;
    vertex_index v[2];
    type ty;

    inline node&amp; operator[](size_type d) { return n[c[d]]; }
    inline vertex&amp; operator()(size_type d) { return toptree::v[this-&gt;v[d]]; }
  };

  inline node_index new_node(type ty) {
    node_index i = ni++;
    n[i].i = i;
    n[i].ty = ty;
    return i;
  }

   void reverse(node_index i) {
    std::swap(n[i].v[0], n[i].v[1]);
    n[i].f = cluster::reverse(n[i].f);
    n[i].rev ^= true;
  }

   void push(node_index i) {
    if(n[i].ty != type::Edge &amp;&amp; n[i].rev) {
      std::swap(n[i].c[0], n[i].c[1]);
      reverse(n[i].c[0]);
      reverse(n[i].c[1]);
      n[i].rev = false;
    }
  }

    void fix(node_index i) {
    push(i);
    if(n[i].ty == type::Compress) {
      n[i].v[0] = n[i][0].v[0];
      n[i].v[1] = n[i][1].v[1];
      cluster l = n[i][0].f;
      if(n[i].c[2])
        l = cluster::rake(l, n[i][2].f, n[i][0](0).val, n[i][2](0).val, n[i][0](1).val);
      n[i].f = cluster::compress(l, n[i][1].f, n[i][0](0).val, n[i][1](1).val, n[i][0](1).val);
    }
    if(n[i].ty == type::Rake) {
      n[i].v[0] = n[i][0].v[0];
      n[i].v[1] = n[i][0].v[1];
      n[i].f = cluster::rake(n[i][0].f, n[i][1].f, n[i][0](0).val, n[i][1](0).val, n[i][0](1).val);
    }

    if(n[i].ty == type::Compress)
      n[i][1](0).hn = i;
    if(n[i].ty != type::Rake) {
      if(!n[i].c[3])
        n[i](0).hn = n[i](1).hn = i;
      else if(n[i][3].ty == type::Rake || n[i][3].c[2] == n[i].i)
        n[i](0).hn = i;
    }
  }


   int child_dir(node_index i) {
    if(n[i].c[3]) {
      if(n[i][3].c[0] == i) { return 0; }
      else if(n[i][3].c[1] == i) { return 1; }
      else { return 2; }
    }
    return 3;
  }

   void rotate(node_index x, size_type dir) {
    node_index p = n[x].c[3];
    int x_dir = child_dir(x);
    node_index y = n[x].c[dir ^ 1];

    n[n[y][dir].c[3] = x].c[dir ^ 1] = n[y].c[dir];
    n[n[x].c[3] = y].c[dir] = x;
    n[y].c[3] = p;
    if(x_dir &lt; 2) n[p].c[x_dir] = y;
    fix(n[x].c[dir ^ 1]);
    fix(x);
  }

   void splay(node_index i) {
    push(i);
    int i_dir;
    int j_dir;
    while(child_dir(i) &lt; 2 &amp;&amp; n[i].c[3] != guard &amp;&amp; n[i].ty == n[i][3].ty) {
      node_index j = n[i].c[3];
      if(child_dir(j) &lt; 2 &amp;&amp; n[j].c[3] != guard &amp;&amp; n[j].ty == n[j][3].ty) {
        node_index k = n[j].c[3];
        push(k), push(j), push(i);
        i_dir = child_dir(i);
        j_dir = child_dir(j);
        if(i_dir == j_dir) rotate(k, j_dir ^ 1), rotate(j, i_dir ^ 1);
        else rotate(j, i_dir ^ 1), rotate(k, j_dir ^ 1);
      }
      else push(j), push(i), rotate(j, child_dir(i) ^ 1);
    }
    fix(i);
  }

   node_index expose_raw(node_index i) {
    while(true) {
      if(n[i].ty == type::Compress) splay(i);
      node_index p = n[i].c[3];
      if(!p) break;
      else if(n[p].ty == type::Rake) {
        splay(p);
        p = n[p].c[3];
      }
      else if(p == toptree::guard &amp;&amp; child_dir(i) &lt; 2) break;

      splay(p);

      int dir = child_dir(p);
      dir = (dir &gt;= 2 || n[p][3].ty == type::Rake) ? 0 : dir;
      if(dir == 1) {
        reverse(n[p].c[dir]);
        push(n[p].c[dir]);
        reverse(i);
        push(i);
      }

      int i_dir = child_dir(i);
      int x = n[i].c[3];
      int m = n[p].c[dir];

      n[n[m].c[3] = x].c[i_dir] = m;
      n[n[i].c[3] = p].c[dir] = i;
      fix(m); fix(x); fix(i); fix(p);
      if(n[i].ty == type::Edge) {
        i = p;
      }
    }
    return i;
  }

   node_index expose(vertex_index i) {
    return expose_raw(v[i].hn);
  }

   void soft_expose(vertex_index a, vertex_index b) {
    node_index r = expose(a);
    if(v[a].hn == v[b].hn) {
      if(n[r].c[1] == a || n[r].c[0] == b) reverse(r), push(r);
      return;
    }
    guard = r;
    node_index s = expose(b);
    guard = ~0;
    fix(r);
    if(child_dir(s) == 0) reverse(r), push(r);
  }

   void link(vertex_index a, vertex_index b, cluster weight) {
    node_index e = new_node(type::Edge);
    n[e].v[0] = a; n[e].v[1] = b; n[e].f = weight;
    if(!v[a].hn &amp;&amp; !v[b].hn) { fix(e); return; }
    node_index na = v[a].hn;
    node_index nb = v[b].hn;
    node_index left;
    for(int dir = 0; dir &lt; 2; dir++) {
      if(!nb) left = e;
      else {
        nb = expose_raw(nb);
        if(n[nb].v[dir ^ 1] == b) {
          reverse(nb);
          push(nb);
        }
        if(n[nb].v[dir] == b) {
          left = new_node(type::Compress);
          n[left].c[dir] = e; n[left].c[dir ^ 1] = nb;
          n[e].c[3] = n[nb].c[3] = left;
          fix(e); fix(nb); fix(left);
        }
        else {
          node_index ch = n[nb].c[dir];
          if(dir) reverse(ch);
          n[n[e].c[3] = nb].c[dir] = e;
          node_index beta = n[nb].c[2];
          node_index rake;
          if(beta) {
            rake = new_node(type::Rake);
            n[rake].c[0] = beta; n[rake].c[1] = ch;
            n[beta].c[3] = n[ch].c[3] = rake;
            fix(beta); fix(ch);
          }
          else rake = ch;
          n[n[rake].c[3] = nb].c[2] = rake;
          fix(rake); fix(e); fix(left = nb);
        }
      }
      e = left;
      nb = na;
      b = a;
    }
  }

   cluster path_query(vertex_index a, vertex_index b) {
     soft_expose(a, b);
     node_index r = v[a].hn;
     if(n[r].v[0] == a &amp;&amp; n[r].v[1] == b) return n[r].f;
     if(n[r].v[0] == a) return n[r][0].f;
     if(n[r].v[1] == b) return n[r][1].f;
     push(n[r].c[1]);
     return n[r][1][0].f;
   }

   void bring(node_index r, int dir) {
     node_index i = n[r].c[2];
     if(!i) {
       i = n[r].c[dir ^ 1];
       n[i].c[3] = 0;
       fix(i);
     }
     else if(n[i].ty == type::Rake) {
       while(push(i), n[i][1].ty == type::Rake) i = n[i].c[1];
       splay(i);
       n[n[i][0].c[3] = r].c[2] = n[i].c[0];
       if(dir) reverse(n[i].c[1]);
       n[n[i][1].c[3] = r].c[dir] = n[i].c[1];
       fix(n[r].c[2]); fix(n[r].c[dir]); fix(r);
     }
     else {
       if(dir) reverse(i);
       n[n[i].c[3] = r].c[dir] = i;
       n[r].c[2] = 0;
       fix(n[r].c[dir]); fix(r);
     }
   }

   void cut(vertex_index a, vertex_index b) {
     soft_expose(a, b);
     node_index r = v[a].hn;
     node_index s = v[b].hn;
     push(s);
     n[s].c[3] = 0;
     n[r].c[1] = 0;
     bring(r, 1);
     bring(s, 0);
   }

   int all_tree(vertex_index a) {
     expose(a);
     return n[v[a].hn].f.length + n[v[a].hn](0).val + n[v[a].hn](1).val;
   }
}
</code></pre>
<h1><a class="header" href="#union-find" id="union-find">Union Find</a></h1>
<ul>
<li><a href="data_structures/union_find/./data_structures/union_find/union_find.html">Union Find</a></li>
<li><a href="data_structures/union_find/./data_structures/union_find/persistent_union_find.html">Persistent Union Find</a></li>
</ul>
<h1><a class="header" href="#union-find-1" id="union-find-1">Union Find</a></h1>
<h2><a class="header" href="#spec-11" id="spec-11">Spec</a></h2>
<ul>
<li>
<p><code>(constructor)</code></p>
<ul>
<li><code>n</code>要素のUnion Findを構築する.</li>
</ul>
</li>
<li>
<p><code>root</code></p>
<ul>
<li>要素の根を返す.</li>
</ul>
</li>
<li>
<p><code>unite</code></p>
<ul>
<li>2要素を結ぶ.</li>
<li>戻り値は親となった根</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#code-15" id="code-15">Code</a></h2>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;tuple&gt;

struct union_find {
  std::vector&lt;int&gt; par;
  union_find(int N): par(N, -1) {}
  int root(int x) {
    return par[x] &lt; 0 ? x : par[x] = root(par[x]);
  }
  std::tuple&lt;int, int&gt; unite(int x, int y) {
    x = root(x);
    y = root(y);
    if(x == y) return { -1, -1 };
    if(par[x] &gt; par[y]) std::swap(x, y);
    par[x] += par[y];
    par[y] = x;
    return { x, y };
  }
  int size(int x) {
    return -par[root(x)];
  }
};
</code></pre>
<h1><a class="header" href="#partially-persistent-union-find" id="partially-persistent-union-find">Partially Persistent Union Find</a></h1>
<h2><a class="header" href="#spec-12" id="spec-12">Spec</a></h2>
<ul>
<li>
<p>時刻<code>t</code>は単調増加である必要がある.</p>
</li>
<li>
<p><code>(constructor)</code></p>
<ul>
<li><code>n</code>要素のPartially Persistent Union Findを構築する.</li>
</ul>
</li>
<li>
<p><code>unite(i64 t, i64 x, i64 y)</code></p>
<ul>
<li>2要素を時刻<code>t</code>で結ぶ.</li>
<li>戻り値は親となった根</li>
</ul>
</li>
<li>
<p><code>find(i64 t, i64 x)</code></p>
<ul>
<li>時刻<code>t</code>のときの要素<code>x</code>の根を返す.</li>
</ul>
</li>
<li>
<p><code>size(i64 t, i64 x)</code></p>
<ul>
<li>時刻<code>t</code>のときの要素<code>x</code>の属する集合の大きさを返す.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#code-16" id="code-16">Code</a></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct partially_persistent_union_find {
  vector&lt;i64&gt; data;
  vector&lt;i64&gt; last;
  vector&lt;vector&lt;pair&lt;i64, i64&gt;&gt;&gt; add;

  partially_persistent_union_find(int sz) : data(sz, -1), last(sz, 1e9), add(sz) {
    for(auto &amp; vs: add) vs.push_back({ -1, -1 });
  }

  i64 unite(i64 t, i64 x, i64 y) {
    x = find(t, x);
    y = find(t, y);
    if(x == y) return -1;
    if(data[x] &gt; data[y]) swap(x, y);
    data[x] += data[y];
    add[x].push_back({t, data[x]});
    data[y] = x;
    last[y] = t;
    return x;
  }

  i64 find(i64 t, i64 x) {
    if(t &lt; last[x]) return x;
    return find(t, data[x]);
  }

  i64 size(i64 t, i64 x) {
    x = find(t, x);
    return -prev(lower_bound(begin(add[x]), end(add[x]), make_pair(t, 0ll)))-&gt;second;
  }
};
</code></pre>
<h1><a class="header" href="#self-balancing-binary-search-tree" id="self-balancing-binary-search-tree">self-Balancing Binary Search Tree</a></h1>
<ul>
<li><a href="data_structures/bbst/./splay_tree_array.html">Splay Tree Array</a></li>
<li><a href="data_structures/bbst/./splay_tree_map.html">Splay Tree Map</a></li>
<li><a href="data_structures/bbst/./avl_tree_array.html">AVL Tree Array</a></li>
<li><a href="data_structures/bbst/./persistent_avl_tree_array.html">Persistent AVL Tree Array</a></li>
</ul>
<h1><a class="header" href="#splay-tree-array" id="splay-tree-array">Splay Tree Array</a></h1>
<p>列を管理するSplay Tree</p>
<h3><a class="header" href="#spec-13" id="spec-13">Spec</a></h3>
<ul>
<li>
<p><code>struct node</code></p>
<ul>
<li>Splay Treeに載せるノードの型</li>
</ul>
</li>
<li>
<p><code>fold(node* x)</code></p>
<ul>
<li><code>fold</code>したいやつを変えたときはここを変える</li>
</ul>
</li>
<li>
<p><code>fix(node* n)</code></p>
<ul>
<li><code>fix</code>操作, foldの仕方をここで定義する</li>
</ul>
</li>
<li>
<p><code>reverse(node* n)</code></p>
<ul>
<li>反転操作, foldを反転する必要がある場合はここに.</li>
</ul>
</li>
<li>
<p><code>push(node* x)</code></p>
<ul>
<li>遅延伝搬させているときはここを変更</li>
</ul>
</li>
<li>
<p><code>split(i64 i)</code></p>
<ul>
<li><code>[0, i) / [i, ..)</code>に分ける</li>
</ul>
</li>
<li>
<p><code>merge(splay_array&amp;&amp; arr)</code></p>
<ul>
<li>mergeする</li>
</ul>
</li>
<li>
<p><code>reverse()</code></p>
<ul>
<li>列全体を反転させる</li>
</ul>
</li>
<li>
<p><code>update(i64 i, T t)</code></p>
<ul>
<li><code>i</code>番目の要素を<code>t</code>に変更する.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-17" id="code-17">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct splay_array {
  using T = i64;

  struct node {
    node* ch[2];
    node* par;
    T val;
    i64 sz;
    bool rev;

    /* option */
    T fold;
    
    node(T v): val(v), par(nullptr), sz(1), rev(false), fold(v) { ch[0] = nullptr; ch[1] = nullptr; }
  };

private:

  i64 subsize(node* x) {
    if(x) return x-&gt;sz;
    else return 0;
  }
  T fold(node* x) {
    if(x) return x-&gt;fold;
    else return 0;
  }
  node* fix(node* n) {
    if(!n) return nullptr;
    n-&gt;sz = subsize(n-&gt;ch[0]) + subsize(n-&gt;ch[1]) + 1;
    /* option */
    n-&gt;fold = fold(n-&gt;ch[0]) + n-&gt;val + fold(n-&gt;ch[1]);
    return n;
  }
  void reverse(node* n) {
    if(!n) return;
    n-&gt;rev ^= true;
    /* here reversing operation */
    /* example swap(fold, revfold) */
  }
  void push(node* x) {
    if(!x) return;
    if(x-&gt;rev) {
      swap(x-&gt;ch[0], x-&gt;ch[1]);
      reverse(x-&gt;ch[0]);
      reverse(x-&gt;ch[1]);
    }
  }
  int parent_dir(node* x) {
    node* p = x-&gt;par;
    if(!p) return -1;
    else if(p-&gt;ch[0] == x) return 0;
    else return 1;
  }
  void set(node* par, node* x, i64 dir) {
    if(par) par-&gt;ch[dir] = x;
    if(x) x-&gt;par = par;
    fix(par);
  }
  void rotate(node* x, i64 dir) {
    node* p = x-&gt;par;
    node* q = p-&gt;par;
    set(p, x-&gt;ch[dir], dir ^ 1);
    int p_dir = parent_dir(p);
    if(p_dir &gt;= 0) {
      set(q, x, p_dir);
    }
    else x-&gt;par = nullptr;
    set(x, p, dir);
  }
  node* splay(node * x) {
    if(!x) return nullptr;
    while(x-&gt;par) {
      push(x-&gt;par-&gt;par);
      push(x-&gt;par);
      push(x);
      int dir = parent_dir(x);
      int eir = parent_dir(x-&gt;par);
      if(eir == -1) {
        rotate(x, dir  ^ 1);
      }
      else if(dir == eir){
        rotate(x-&gt;par, eir ^ 1);
        rotate(x, dir ^ 1);
      }
      else {
        rotate(x, dir ^ 1);
        rotate(x, eir ^ 1);
      }
    }
    return x;
  }

  node* find(node* r, i64 i) {
    push(r);
    assert(0 &lt;= i);
    assert(i &lt; subsize(r));
    node* z = r;
    while(z) {
      push(z);
      if(subsize(z-&gt;ch[0]) == i) return splay(z);
      else if(subsize(z-&gt;ch[0]) &lt; i) {
        i -= subsize(z-&gt;ch[0]) + 1;
        z = z-&gt;ch[1];
      }
      else {
        z = z-&gt;ch[0];
      }
    }
    assert(false);
  }

  pair&lt;node*, node*&gt; split(node* r, size_t i) {
    push(r);
    assert(0 &lt;= i);
    assert(i &lt;= subsize(r));
    if(i == 0) return { nullptr, r };
    if(i == subsize(r)) return { r, nullptr };
    r = find(r, i - 1);
    node* y = r-&gt;ch[1];
    if(y) y-&gt;par = nullptr;
    r-&gt;ch[1] = nullptr;
    fix(r);
    push(y);
    return { r, y };
  }

  node* merge(node* r1, node* r2) {
    push(r1);
    push(r2);
    if(!r1) r1 = r2;
    else if(!r2) {}
    else {
      r1 = find(r1, subsize(r1) - 1);
      set(r1, r2, 1);
    }
    return r1;
  }

  node* root;

  splay_array(node* r): root(r) {}

public:

  using sarr = splay_array;

  splay_array(): root(nullptr) {}
  splay_array(T t): root(new node(t)) {}
  splay_array(splay_array&amp;&amp; arr): root(arr.root) { arr.root = nullptr; }
  splay_array&amp; operator=(splay_array&amp;&amp; arr) {
    root = arr.root;
    arr.root = nullptr;
    return *this;
  }
  /* [0 ... i - 1] +/+ [i ...] */
  pair&lt;splay_array, splay_array&gt; split(i64 i) {
    auto p = split(root, i);
    root = nullptr;
    return { splay_array(p.first), splay_array(p.second) };
  }
  /* [this] ++ [arr] */
  void merge(splay_array&amp;&amp; arr) {
    root = merge(root, arr.root);
    arr.root = nullptr;
  }
  /* reverse array */
  void reverse() { if(root) reverse(root); }
  i64 size() { return subsize(root); }

  /* option */
  T fold() { return fold(root); }
  void update(i64 i, T t) {
    root = find(root, i);
    root-&gt;val += t;
    fix(root);
  }
};
</code></pre>
<h1><a class="header" href="#splay-tree-map" id="splay-tree-map">Splay Tree Map</a></h1>
<p>map型のSplay Tree</p>
<h3><a class="header" href="#spec-14" id="spec-14">Spec</a></h3>
<ul>
<li>
<p><code>struct node</code></p>
<ul>
<li>Splay Treeに載せるノードの型</li>
</ul>
</li>
<li>
<p><code>fold(node* x)</code></p>
<ul>
<li><code>fold</code>したいやつを変えたときはここを変える</li>
</ul>
</li>
<li>
<p><code>fix(node* n)</code></p>
<ul>
<li><code>fix</code>操作, foldの仕方をここで定義する</li>
</ul>
</li>
<li>
<p><code>reverse(node* n)</code></p>
<ul>
<li>反転操作, foldを反転する必要がある場合はここに.</li>
</ul>
</li>
<li>
<p><code>push(node* x)</code></p>
<ul>
<li>遅延伝搬させているときはここを変更</li>
</ul>
</li>
<li>
<p><code>insert(Key key, T t)</code></p>
<ul>
<li><code>{key, t}</code>を入れる, すでに存在する場合はupdate</li>
</ul>
</li>
<li>
<p><code>erase(Key key)</code></p>
<ul>
<li>`{key, ..}のノードを削除する</li>
</ul>
</li>
<li>
<p><code>nth_node(i64 n)</code></p>
<ul>
<li><code>n</code>番目の要素の<code>Key</code>を返す</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-18" id="code-18">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct splay_map {
  using T = i64;
  using Key = i64;

  struct node {
    node* ch[2];
    node* par;
    T val;
    Key key;
    i64 sz;
    bool rev;

    /* option */
    //T fold;
    
    node(Key key, T v): key(key), val(v), par(nullptr), sz(1), rev(false)/*, fold(v)*/ { ch[0] = nullptr; ch[1] = nullptr; }
  };

private:

  i64 subsize(node* x) {
    if(x) return x-&gt;sz;
    else return 0;
  }
  /*
  T fold(node* x) {
    if(x) return x-&gt;fold;
    else return 0;
  }
  */
  node* fix(node* n) {
    if(!n) return nullptr;
    n-&gt;sz = subsize(n-&gt;ch[0]) + subsize(n-&gt;ch[1]) + 1;
    /* option */
    //n-&gt;fold = fold(n-&gt;ch[0]) + n-&gt;val + fold(n-&gt;ch[1]);
    return n;
  }
  void reverse(node* n) {
    if(!n) return;
    n-&gt;rev ^= true;
    /* here reversing operation */
    /* example swap(fold, revfold) */
  }
  void push(node* x) {
    if(!x) return;
    if(x-&gt;rev) {
      swap(x-&gt;ch[0], x-&gt;ch[1]);
      reverse(x-&gt;ch[0]);
      reverse(x-&gt;ch[1]);
    }
  }
  int parent_dir(node* x) {
    node* p = x-&gt;par;
    if(!p) return -1;
    else if(p-&gt;ch[0] == x) return 0;
    else return 1;
  }
  void set(node* par, node* x, i64 dir) {
    if(par) par-&gt;ch[dir] = x;
    if(x) x-&gt;par = par;
    fix(par);
  }
  void rotate(node* x, i64 dir) {
    node* p = x-&gt;par;
    node* q = p-&gt;par;
    set(p, x-&gt;ch[dir], dir ^ 1);
    int p_dir = parent_dir(p);
    if(p_dir &gt;= 0) {
      set(q, x, p_dir);
    }
    else x-&gt;par = nullptr;
    set(x, p, dir);
  }
  node* splay(node * x) {
    if(!x) return nullptr;
    while(x-&gt;par) {
      push(x-&gt;par-&gt;par);
      push(x-&gt;par);
      push(x);
      int dir = parent_dir(x);
      int eir = parent_dir(x-&gt;par);
      if(eir == -1) {
        rotate(x, dir  ^ 1);
      }
      else if(dir == eir){
        rotate(x-&gt;par, eir ^ 1);
        rotate(x, dir ^ 1);
      }
      else {
        rotate(x, dir ^ 1);
        rotate(x, eir ^ 1);
      }
    }
    return x;
  }

  node* root;

public:

  splay_map(): root(nullptr) {}

  node* lower_bound(Key key) {
    node* z = root;
    node* x = nullptr;
    while(z) {
      if(key &lt;= z-&gt;key) {
        x = z;
        z = z-&gt;ch[0];
      }
      else {
        z = z-&gt;ch[1];
      }
    }
    return x;
  }

  void insert(Key key, T t) {
    node* z = new node(key, t);
    node* x = lower_bound(key);
    if(!x) {
      set(z, root, 0);
      root = z;
    }
    else {
      root = splay(x);
      node* q = root-&gt;ch[0];
      set(z, q, 0);
      set(root, z, 0);
    }
  }

  void erase(Key key) {
    node* x = lower_bound(key);
    if(x-&gt;key == key) {
      root = splay(x);
      node* p = root-&gt;ch[0];
      node* q = root-&gt;ch[1];
      root-&gt;ch[0] = nullptr;
      root-&gt;ch[1] = nullptr;
      if(p) p-&gt;par = nullptr;
      if(q) q-&gt;par = nullptr;
      if(!p) {
        root = q;
      }
      else {
        while(p-&gt;ch[1]) p = p-&gt;ch[1];
        root = splay(p);
        set(root, q, 1);
      }
    }
  }

  i64 size() {
    return subsize(root);
  }
  Key nth_node(i64 n) {
    node* z = root;
    while(z) {
      if(subsize(z-&gt;ch[0]) == n) {
        return z-&gt;key;
      }
      if(subsize(z-&gt;ch[0]) &lt; n) {
        n -= subsize(z-&gt;ch[0]) + 1;
        z = z-&gt;ch[1];
      }
      else {
        z = z-&gt;ch[0];
      }
    }
    assert(false);
  }
  

  /* option */
  //T fold() { return fold(root); }
};
</code></pre>
<h1><a class="header" href="#avl-tree-array" id="avl-tree-array">AVL Tree Array</a></h1>
<p>列を管理するAVL Tree</p>
<h3><a class="header" href="#spec-15" id="spec-15">Spec</a></h3>
<ul>
<li>
<p><code>struct node</code></p>
<ul>
<li>AVL Treeに載せるノードの型</li>
<li><code>fix</code>に操作を書く</li>
</ul>
</li>
<li>
<p><code>split(size_type i)</code></p>
<ul>
<li><code>[0, i) / [i, ..)</code>に分けた木を返す</li>
</ul>
</li>
<li>
<p><code>merge(persistent_avl_array&amp;&amp; arr)</code></p>
<ul>
<li>mergeした木を返す.</li>
</ul>
</li>
<li>
<p><code>at(size_type i)</code></p>
<ul>
<li><code>i</code>番目の要素にアクセスする.</li>
</ul>
</li>
<li>
<p><code>set(size_type i, value_type val)</code></p>
<ul>
<li><code>i</code>番目の要素を<code>val</code>にする</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-19" id="code-19">Code</a></h3>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;array&gt;

template&lt;class T&gt;
class avl_tree_array {
  public:
    using value_type = T;
    using size_type = std::size_t;
    using height_type = long long int;
  protected:
    class node;
    using node_type = std::unique_ptr&lt;class node&gt;;

    static size_type size(const node_type&amp; node) {
      if(!node) return 0;
      else return node-&gt;size();
    }
    static height_type height(const node_type&amp; node) {
      if(!node) return 0;
      else return node-&gt;height();
    }

    class node {
      private:
        value_type val;
        size_type sz;
        height_type hei;
        std::array&lt;node_type, 2&gt; chi;
      public:

        node(value_type val): val(std::move(val)), sz(1), hei(1), chi() { fix(); }
        void fix() {
          sz = avl_tree_array::size(chi[0]) + avl_tree_array::size(chi[1]) + 1;
          hei = std::max(avl_tree_array::height(chi[0]), avl_tree_array::height(chi[1])) + 1;
        }
        void push() {}
        node_type cut(size_type dir) {
          push();
          node_type nn = std::move(chi[dir]);
          this-&gt;fix();
          return std::move(nn);
        }
        void set(node_type dir_node, size_type dir) {
          push();
          chi[dir] = std::move(dir_node);
          this-&gt;fix();
        }
        size_type size() { push(); return sz; }
        height_type height() { push(); return hei; }
        height_type diff() { push(); return avl_tree_array::height(chi[0]) - avl_tree_array::height(chi[1]); }
        value_type&amp; value() { push(); return val; }
        node_type&amp; child(size_type dir) { return chi[dir]; }
    };


    static node_type rotate(node_type x, size_type dir) {
      node_type y = x-&gt;cut(1 - dir);
      node_type b = y-&gt;cut(dir);
      x-&gt;set(std::move(b), 1 - dir);
      y-&gt;set(std::move(x), dir);
      return std::move(y);
    }

    static node_type balance(node_type node) {
      if(node-&gt;diff() == 2) {
        if(node-&gt;child(0)-&gt;diff() == -1) {
          auto ch = node-&gt;cut(0);
          node-&gt;set(rotate(std::move(ch), 0), 0);
        }
        return rotate(std::move(node), 1);
      }
      else if(node-&gt;diff() == -2) {
        if(node-&gt;child(1)-&gt;diff() == 1) {
          auto ch = node-&gt;cut(1);
          node-&gt;set(rotate(std::move(ch), 1), 1);
        }
        return rotate(std::move(node), 0);
      }
      else return std::move(node);
    }

    static std::pair&lt;node_type, node_type&gt; deepest_node(node_type node, size_type dir) {
      auto ch = node-&gt;cut(dir);
      if(ch) {
        auto pp = deepest_node(std::move(ch), dir);
        node_type deepest_node, dirn;
        deepest_node = std::move(pp.first);
        dirn = std::move(pp.second);
        node-&gt;set(std::move(dirn), dir);
        pp.first = std::move(deepest_node);
        pp.second = balance(std::move(node));
        return std::move(pp);
      }
      else {
        auto rn = node-&gt;cut(1 - dir);
        std::pair&lt;node_type, node_type&gt; pp;
        pp.first = std::move(node);
        pp.second = std::move(rn);
        return pp;
      }
    }

    static node_type merge_dir(node_type dst, node_type root, node_type src, size_type dir) {
      if(std::abs(height(dst) - height(src)) &lt;= 1) {
        root-&gt;set(std::move(src), dir);
        root-&gt;set(std::move(dst), 1 - dir);
        return std::move(root);
      }
      else {
        node_type ch = dst-&gt;cut(dir);
        if(ch) {
          ch = merge_dir(std::move(ch), std::move(root), std::move(src), dir);
          dst-&gt;set(std::move(ch), dir);
          return balance(std::move(dst));
        }
        else {
          root-&gt;set(std::move(src), dir);
          root = balance(std::move(root));
          dst-&gt;set(std::move(root), dir);
          return balance(std::move(dst));
        }
      }
    }

    static node_type merge(node_type left, node_type right) {
      if(!left) { return std::move(right); }
      else if(!right) { return std::move(left); }
      else if(height(left) &gt;= height(right)) {
        node_type deep_left, src;
        std::tie(deep_left, src) = deepest_node(std::move(right), 0);
        return merge_dir(std::move(left), std::move(deep_left), std::move(src), 1);
      }
      else {
        node_type deep_right, src;
        std::tie(deep_right, src) = deepest_node(std::move(left), 1);
        return merge_dir(std::move(right), std::move(deep_right), std::move(src), 0);
      }
    }

    static std::pair&lt;node_type, node_type&gt; split(node_type node, size_type i) {
      if(i == node-&gt;size()) { return std::pair&lt;node_type, node_type&gt;(std::move(node), node_type()); }
      auto left = node-&gt;cut(0);
      auto right = node-&gt;cut(1);
      if(i &lt; size(left)) {
        node_type sp_left, sp_right;
        std::tie(sp_left, sp_right) = split(std::move(left), i);
        node_type nright;
        if(right) {
          nright = merge_dir(std::move(right), std::move(node), std::move(sp_right), 0);
        }
        else {
          nright = merge(std::move(sp_right), std::move(node));
        }
        return std::pair&lt;node_type, node_type&gt;(std::move(sp_left), std::move(nright));
      }
      else if(i == size(left)) {
        return std::pair&lt;node_type, node_type&gt;(std::move(left), merge(std::move(node), std::move(right)));
      }
      else {
        node_type sp_left, sp_right;
        std::tie(sp_left, sp_right) = split(std::move(right), i - size(left) - 1);
        node_type nleft;
        if(left) {
          nleft = merge_dir(std::move(left), std::move(node), std::move(sp_left), 1);
        }
        else {
          nleft = merge(std::move(node), std::move(sp_left));
        }
        return std::pair&lt;node_type, node_type&gt;(std::move(nleft), std::move(sp_right));
      }
    }

    static node_type&amp; at(node_type&amp; node, size_type i) {
      if(size(node-&gt;child(0)) == i) return node;
      else if(size(node-&gt;child(0)) &lt; i) return at(node-&gt;child(1), i - size(node-&gt;child(0)) - 1);
      else return at(node-&gt;child(0), i);
    }

    static void set(node_type&amp; node, size_type i, value_type val) {
      if(size(node-&gt;child(0)) == i) {
        node-&gt;value() = std::move(val);
        node-&gt;fix();
      }
      else if(size(node-&gt;child(0)) &lt; i) {
        set(node-&gt;child(1), i - size(node-&gt;child(0)) - 1, std::move(val));
        node-&gt;fix();
      }
      else {
        set(node-&gt;child(0), i, std::move(val));
        node-&gt;fix();
      }
    }

    node_type root;
    avl_tree_array(node_type&amp;&amp; root): root(std::move(root)) {}
  public:
    avl_tree_array(): root() {}
    avl_tree_array(T val): root(node_type(new class node(std::move(val)))) {}
    avl_tree_array(avl_tree_array&amp;&amp; tree): root(std::move(tree.root)) {}
    avl_tree_array&amp; operator=(avl_tree_array&amp;&amp; tree) {
      root = std::move(tree.root);
      return *this;
    }
    template&lt;class A&gt;
      friend avl_tree_array&lt;A&gt; merge(avl_tree_array&lt;A&gt;&amp;&amp; t1, avl_tree_array&lt;A&gt;&amp;&amp; t2);
    template&lt;class A&gt;
      friend std::pair&lt;avl_tree_array&lt;A&gt;, avl_tree_array&lt;A&gt;&gt; split(avl_tree_array&lt;A&gt;&amp;&amp; t, std::size_t i);

    value_type&amp; at(size_type i) {
      return at(root, i)-&gt;value();
    }

    void set(size_type i, value_type val) {
      set(root, i, std::move(val));
    }

    size_type size() {
      if(!root) return 0;
      return root-&gt;size();
    }
};

template&lt;class T&gt;
avl_tree_array&lt;T&gt; merge(avl_tree_array&lt;T&gt;&amp;&amp; t1, avl_tree_array&lt;T&gt;&amp;&amp; t2) {
  return avl_tree_array&lt;T&gt;(avl_tree_array&lt;T&gt;::merge(std::move(t1.root), std::move(t2.root)));
}

template&lt;class T&gt;
std::pair&lt;avl_tree_array&lt;T&gt;, avl_tree_array&lt;T&gt;&gt; split(avl_tree_array&lt;T&gt;&amp;&amp; t, std::size_t i) {
  auto rp = avl_tree_array&lt;T&gt;::split(std::move(t.root), i);
  return std::make_pair(avl_tree_array&lt;T&gt;(std::move(rp.first)), avl_tree_array&lt;T&gt;(std::move(rp.second)));
}
</code></pre>
<h1><a class="header" href="#avl-tree-array-tuned" id="avl-tree-array-tuned">AVL Tree Array Tuned</a></h1>
<h3><a class="header" href="#code-20" id="code-20">Code</a></h3>
<pre><code class="language-cpp">#include &lt;utility&gt;
#include &lt;cstdint&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

struct avl_tree_array {
  using value_type = long long;
  using size_type = std::size_t;
  using height_type = std::int_least32_t;
  using node_index = std::int_least32_t;

  struct node;

  static struct node n[501010];
  static size_type ni;

  struct node {
    value_type val;
    size_type s;
    height_type h;
    node_index c[2];
    value_type f;
    node() : f(0) {}
    node&amp; operator[](size_type d) { return n[c[d]]; }
  };

  static node_index new_node(value_type v) {
    node_index i = ni++;
    n[i].val = v;
    fix(i);
    return i;
  }

  static void fix(node_index i) {
    n[i].s = n[i][0].s + 1 + n[i][1].s;
    n[i].h = std::max(n[i][0].h, n[i][1].h) + 1;
    n[i].f = n[i][0].f + n[i].val + n[i][1].f;
  }

  static void rotate(node_index&amp; x, size_type dir) {
    node_index y = n[x].c[1 ^ dir];
    n[x].c[1 ^ dir] = n[y].c[dir];
    n[y].c[dir] = x;
    fix(x);
    fix(y);
    x = y;
  }

  static void balance(node_index&amp; i) {
    fix(i);
    if(n[i][0].h - n[i][1].h == 2) {
      if(n[i][0][0].h - n[i][0][1].h == -1) {
        rotate(n[i].c[0], 0);
      }
      rotate(i, 1);
    }
    else if(n[i][0].h - n[i][1].h == -2) {
      if(n[i][1][0].h - n[i][1][1].h == 1) {
        rotate(n[i].c[1], 1);
      }
      rotate(i, 0);
    }
  }

  static std::pair&lt;node_index, node_index&gt; deepest_node(node_index i, size_type dir) {
    node_index par = -1;
    while(n[i].c[dir]) {
      std::swap(par, n[i].c[dir]);
      std::swap(par, i);
    }
    node_index ln = n[i].c[dir ^ 1];
    n[i].c[dir ^ 1] = 0;
    node_index dn = i;
    fix(dn);
    i = ln;
    while(std::swap(par, i), i &gt; 0) {
      std::swap(par, n[i].c[dir]);
      balance(i);
    }
    return std::pair&lt;node_index, node_index&gt;(par, dn);
  }

  static node_index merge_dir(node_index l, node_index root, node_index r, size_type dir) {
    node_index par = -1;
    while(std::abs(n[l].h - n[r].h) &gt; 1) {
      std::swap(par, n[l].c[dir]);
      std::swap(par, l);
    }
    n[root].c[dir ^ 1] = l;
    n[root].c[dir] = r;
    fix(root);
    l = root;
    while(std::swap(par, l), l &gt; 0) {
      std::swap(par, n[l].c[dir]);
      balance(l);
    }
    return par;
  }

  static node_index merge(node_index l, node_index r) {
    if(!l) return r;
    else if(!r) return l;
    else if(n[l].h &gt;= n[r].h) {
      auto p = deepest_node(r, 0);
      return merge_dir(l, p.second, p.first, 1);
    }
    else {
      auto p = deepest_node(l, 1);
      return merge_dir(r, p.second, p.first, 0);
    }
  }

  static std::pair&lt;node_index, node_index&gt; split(node_index root, size_type pos) {
    if(pos == n[root].s) return { root, 0 };
    node_index i = root;
    node_index par = -1;
    while(i &gt; 0 &amp;&amp; pos != n[i][0].s) {
      if(pos &lt; n[i][0].s) {
        std::swap(par, n[i].c[0]);
      }
      else {
        pos -= n[i][0].s + 1;
        std::swap(par, n[i].c[1]);
      }
      std::swap(par, i);
    }

    node_index l = n[i].c[0];
    node_index r = merge_dir(n[i].c[1], i, 0, 0);

    while(std::swap(par, i), i &gt; 0) {
      if(n[i].c[0] == -1 || n[i].h &lt; n[i][0].h) {
        par = n[i].c[0];
        r = merge_dir(n[i].c[1], i, r, 0);
      }
      else {
        par = n[i].c[1];
        l = merge_dir(n[i].c[0], i, l, 1);
      }
    }
    return { l, r };
  }

  static node_index at(node_index i, size_type pos) {
    while(pos != n[i][0].s) {
      if(pos &lt; n[i][0].s) {
        i = n[i].c[0];
      }
      else {
        pos -= n[i][0].s + 1;
        i = n[i].c[1];
      }
    }
    return i;
  }

  static void set(node_index i, size_type pos, value_type v) {
    node_index par = -1;
    while(pos != n[i][0].s) {
      if(pos &lt; n[i][0].s) {
        std::swap(par, n[i].c[0]);
      }
      else {
        pos -= n[i][0].s + 1;
        std::swap(par, n[i].c[1]);
      }
      std::swap(par, i);
    }
    n[i].val = v;
    fix(i);

    while(std::swap(par, i), i &gt; 0) {
      if(n[i].c[0] == -1 || n[i].h &lt; n[i][0].h) {
        std::swap(par, n[i].c[0]);
      }
      else {
        std::swap(par, n[i].c[1]);
      }
      fix(i);
    }
  }

  static void debug(node_index i, std::string s) {
    if(i == 0) {
      std::cout &lt;&lt; s &lt;&lt; 0 &lt;&lt; std::endl;
      return;
    }
    std::cout &lt;&lt; s &lt;&lt; i &lt;&lt; &quot; = &quot; &lt;&lt; n[i].val &lt;&lt; &quot; = &quot; &lt;&lt; n[i].h &lt;&lt; std::endl;
    debug(n[i].c[0], s + &quot;  &quot;);
    debug(n[i].c[1], s + &quot;  &quot;);
  }

public:

  node_index root;
  avl_tree_array(): root(0) {}
  avl_tree_array(value_type val): root(new_node(val)) {}

  avl_tree_array&amp; merge(avl_tree_array right) {
    root = merge(this-&gt;root, right.root);
    return *this;
  }
  avl_tree_array split(size_type i) {
    auto p = split(root, i);
    avl_tree_array avl;
    avl.root = p.second;
    root = p.first;
    return avl;
  }

  void set(size_type i, value_type v) {
    set(root, i, v);
  }

  const value_type&amp; at(size_type i) {
    return n[at(root, i)].val;
  }

  value_type fold() {
    return n[root].f;
  }

  size_type size() {
    return n[root].s;
  }

  void debug() {
    debug(root, &quot;&quot;);
  }
};

avl_tree_array::node avl_tree_array::n[501010];
avl_tree_array::size_type avl_tree_array::ni = 1;

</code></pre>
<h1><a class="header" href="#avl-tree-map" id="avl-tree-map">AVL Tree Map</a></h1>
<p>AVL TreeのMapバージョン</p>
<h3><a class="header" href="#spec-16" id="spec-16">Spec</a></h3>
<ul>
<li>
<p><code>struct node</code></p>
<ul>
<li>AVL Treeに載せるノードの型</li>
<li><code>fix</code>に操作を書く.</li>
</ul>
</li>
<li>
<p><code>at(key_value i)</code></p>
<ul>
<li><code>i</code>の要素にアクセスする.</li>
</ul>
</li>
<li>
<p><code>insert(key_value key, value_type val)</code></p>
<ul>
<li><code>key</code>の要素を<code>val</code>にする</li>
</ul>
</li>
<li>
<p><code>erase(key_value key)</code></p>
<ul>
<li><code>key</code>の要素を消す</li>
</ul>
</li>
<li>
<p><code>lower_bound(key_value key)</code></p>
<ul>
<li><code>lower_bound</code>をしたときの要素を返す.</li>
<li><code>.first</code>が<code>false</code>であるときは<code>lower_bound</code>はない.</li>
</ul>
</li>
<li>
<p><code>nth_node(size_type i)</code></p>
<ul>
<li><code>i</code>番目の要素を返す.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-21" id="code-21">Code</a></h3>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;array&gt;

template&lt;class T&gt;
class avl_tree_array {
  public:
    using value_type = T;
    using size_type = std::size_t;
    using height_type = long long int;
  protected:
    class node;
    using node_type = std::unique_ptr&lt;class node&gt;;

    static size_type size(const node_type&amp; node) {
      if(!node) return 0;
      else return node-&gt;size();
    }
    static height_type height(const node_type&amp; node) {
      if(!node) return 0;
      else return node-&gt;height();
    }

    class node {
      private:
        value_type val;
        size_type sz;
        height_type hei;
        std::array&lt;node_type, 2&gt; chi;
      public:

        node(value_type val): val(std::move(val)), sz(1), hei(1), chi() { fix(); }
        void fix() {
          sz = avl_tree_array::size(chi[0]) + avl_tree_array::size(chi[1]) + 1;
          hei = std::max(avl_tree_array::height(chi[0]), avl_tree_array::height(chi[1])) + 1;
        }
        void push() {}
        node_type cut(size_type dir) {
          push();
          node_type nn = std::move(chi[dir]);
          this-&gt;fix();
          return std::move(nn);
        }
        void set(node_type dir_node, size_type dir) {
          push();
          chi[dir] = std::move(dir_node);
          this-&gt;fix();
        }
        size_type size() { push(); return sz; }
        height_type height() { push(); return hei; }
        height_type diff() { push(); return avl_tree_array::height(chi[0]) - avl_tree_array::height(chi[1]); }
        value_type&amp; value() { push(); return val; }
        node_type&amp; child(size_type dir) { return chi[dir]; }
    };


    static node_type rotate(node_type x, size_type dir) {
      node_type y = x-&gt;cut(1 - dir);
      node_type b = y-&gt;cut(dir);
      x-&gt;set(std::move(b), 1 - dir);
      y-&gt;set(std::move(x), dir);
      return std::move(y);
    }

    static node_type balance(node_type node) {
      if(node-&gt;diff() == 2) {
        if(node-&gt;child(0)-&gt;diff() == -1) {
          auto ch = node-&gt;cut(0);
          node-&gt;set(rotate(std::move(ch), 0), 0);
        }
        return rotate(std::move(node), 1);
      }
      else if(node-&gt;diff() == -2) {
        if(node-&gt;child(1)-&gt;diff() == 1) {
          auto ch = node-&gt;cut(1);
          node-&gt;set(rotate(std::move(ch), 1), 1);
        }
        return rotate(std::move(node), 0);
      }
      else return std::move(node);
    }

    static std::pair&lt;node_type, node_type&gt; deepest_node(node_type node, size_type dir) {
      auto ch = node-&gt;cut(dir);
      if(ch) {
        auto pp = deepest_node(std::move(ch), dir);
        node_type deepest_node, dirn;
        deepest_node = std::move(pp.first);
        dirn = std::move(pp.second);
        node-&gt;set(std::move(dirn), dir);
        pp.first = std::move(deepest_node);
        pp.second = balance(std::move(node));
        return std::move(pp);
      }
      else {
        auto rn = node-&gt;cut(1 - dir);
        std::pair&lt;node_type, node_type&gt; pp;
        pp.first = std::move(node);
        pp.second = std::move(rn);
        return pp;
      }
    }

    static node_type merge_dir(node_type dst, node_type root, node_type src, size_type dir) {
      if(std::abs(height(dst) - height(src)) &lt;= 1) {
        root-&gt;set(std::move(src), dir);
        root-&gt;set(std::move(dst), 1 - dir);
        return std::move(root);
      }
      else {
        node_type ch = dst-&gt;cut(dir);
        if(ch) {
          ch = merge_dir(std::move(ch), std::move(root), std::move(src), dir);
          dst-&gt;set(std::move(ch), dir);
          return balance(std::move(dst));
        }
        else {
          root-&gt;set(std::move(src), dir);
          root = balance(std::move(root));
          dst-&gt;set(std::move(root), dir);
          return balance(std::move(dst));
        }
      }
    }

    static node_type merge(node_type left, node_type right) {
      if(!left) { return std::move(right); }
      else if(!right) { return std::move(left); }
      else if(height(left) &gt;= height(right)) {
        node_type deep_left, src;
        std::tie(deep_left, src) = deepest_node(std::move(right), 0);
        return merge_dir(std::move(left), std::move(deep_left), std::move(src), 1);
      }
      else {
        node_type deep_right, src;
        std::tie(deep_right, src) = deepest_node(std::move(left), 1);
        return merge_dir(std::move(right), std::move(deep_right), std::move(src), 0);
      }
    }

    static std::pair&lt;node_type, node_type&gt; split(node_type node, size_type i) {
      if(i == node-&gt;size()) { return std::pair&lt;node_type, node_type&gt;(std::move(node), node_type()); }
      auto left = node-&gt;cut(0);
      auto right = node-&gt;cut(1);
      if(i &lt; size(left)) {
        node_type sp_left, sp_right;
        std::tie(sp_left, sp_right) = split(std::move(left), i);
        node_type nright;
        if(right) {
          nright = merge_dir(std::move(right), std::move(node), std::move(sp_right), 0);
        }
        else {
          nright = merge(std::move(sp_right), std::move(node));
        }
        return std::pair&lt;node_type, node_type&gt;(std::move(sp_left), std::move(nright));
      }
      else if(i == size(left)) {
        return std::pair&lt;node_type, node_type&gt;(std::move(left), merge(std::move(node), std::move(right)));
      }
      else {
        node_type sp_left, sp_right;
        std::tie(sp_left, sp_right) = split(std::move(right), i - size(left) - 1);
        node_type nleft;
        if(left) {
          nleft = merge_dir(std::move(left), std::move(node), std::move(sp_left), 1);
        }
        else {
          nleft = merge(std::move(node), std::move(sp_left));
        }
        return std::pair&lt;node_type, node_type&gt;(std::move(nleft), std::move(sp_right));
      }
    }

    static node_type&amp; at(node_type&amp; node, size_type i) {
      if(size(node-&gt;child(0)) == i) return node;
      else if(size(node-&gt;child(0)) &lt; i) return at(node-&gt;child(1), i - size(node-&gt;child(0)) - 1);
      else return at(node-&gt;child(0), i);
    }

    static void set(node_type&amp; node, size_type i, value_type val) {
      if(size(node-&gt;child(0)) == i) {
        node-&gt;value() = std::move(val);
        node-&gt;fix();
      }
      else if(size(node-&gt;child(0)) &lt; i) {
        set(node-&gt;child(1), i - size(node-&gt;child(0)) - 1, std::move(val));
        node-&gt;fix();
      }
      else {
        set(node-&gt;child(0), i, std::move(val));
        node-&gt;fix();
      }
    }

    node_type root;
    avl_tree_array(node_type&amp;&amp; root): root(std::move(root)) {}
  public:
    avl_tree_array(): root() {}
    avl_tree_array(T val): root(node_type(new class node(std::move(val)))) {}
    avl_tree_array(avl_tree_array&amp;&amp; tree): root(std::move(tree.root)) {}
    avl_tree_array&amp; operator=(avl_tree_array&amp;&amp; tree) {
      root = std::move(tree.root);
      return *this;
    }
    template&lt;class A&gt;
      friend avl_tree_array&lt;A&gt; merge(avl_tree_array&lt;A&gt;&amp;&amp; t1, avl_tree_array&lt;A&gt;&amp;&amp; t2);
    template&lt;class A&gt;
      friend std::pair&lt;avl_tree_array&lt;A&gt;, avl_tree_array&lt;A&gt;&gt; split(avl_tree_array&lt;A&gt;&amp;&amp; t, std::size_t i);

    value_type&amp; at(size_type i) {
      return at(root, i)-&gt;value();
    }

    void set(size_type i, value_type val) {
      set(root, i, std::move(val));
    }

    size_type size() {
      if(!root) return 0;
      return root-&gt;size();
    }
};

template&lt;class T&gt;
avl_tree_array&lt;T&gt; merge(avl_tree_array&lt;T&gt;&amp;&amp; t1, avl_tree_array&lt;T&gt;&amp;&amp; t2) {
  return avl_tree_array&lt;T&gt;(avl_tree_array&lt;T&gt;::merge(std::move(t1.root), std::move(t2.root)));
}

template&lt;class T&gt;
std::pair&lt;avl_tree_array&lt;T&gt;, avl_tree_array&lt;T&gt;&gt; split(avl_tree_array&lt;T&gt;&amp;&amp; t, std::size_t i) {
  auto rp = avl_tree_array&lt;T&gt;::split(std::move(t.root), i);
  return std::make_pair(avl_tree_array&lt;T&gt;(std::move(rp.first)), avl_tree_array&lt;T&gt;(std::move(rp.second)));
}
</code></pre>
<h1><a class="header" href="#avl-tree-map-foldable" id="avl-tree-map-foldable">AVL Tree Map Foldable</a></h1>
<p>AVL TreeのMapバージョンでモノイドを処理できるようにした.</p>
<h3><a class="header" href="#spec-17" id="spec-17">Spec</a></h3>
<ul>
<li>
<p><code>operation()</code></p>
<ul>
<li>モノイドの演算を決める</li>
</ul>
</li>
<li>
<p><code>identity()</code></p>
<ul>
<li>モノイドの単位元を決める</li>
</ul>
</li>
<li>
<p><code>struct node</code></p>
<ul>
<li>AVL Treeに載せるノードの型</li>
<li><code>fix</code>に操作を書く.</li>
</ul>
</li>
<li>
<p><code>at(key_value i)</code></p>
<ul>
<li><code>i</code>の要素にアクセスする.</li>
</ul>
</li>
<li>
<p><code>insert(key_value key, value_type val)</code></p>
<ul>
<li><code>key</code>の要素を<code>val</code>にする</li>
</ul>
</li>
<li>
<p><code>erase(key_value key)</code></p>
<ul>
<li><code>key</code>の要素を消す</li>
</ul>
</li>
<li>
<p><code>lower_bound(key_value key)</code></p>
<ul>
<li><code>lower_bound</code>をしたときの要素を返す.</li>
<li><code>.first</code>が<code>false</code>であるときは<code>lower_bound</code>はない.</li>
</ul>
</li>
<li>
<p><code>nth_node(size_type i)</code></p>
<ul>
<li><code>i</code>番目の要素を返す.</li>
</ul>
</li>
<li>
<p><code>fold(key_value left, key_value right)</code></p>
<ul>
<li><code>[left, right)</code>に対してfoldをする.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-22" id="code-22">Code</a></h3>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;

template&lt;class Key, class Monoid&gt;
class avl_tree_map {
  public:
    using key_type = Key;
    using value_type = Monoid;
    using size_type = std::size_t;
    using height_type = long long int;
  protected:
    class node;
    using node_type = std::unique_ptr&lt;class node&gt;;

    static size_type size(const node_type&amp; node) {
      if(!node) return 0;
      else return node-&gt;size();
    }
    static height_type height(const node_type&amp; node) {
      if(!node) return 0;
      else return node-&gt;height();
    }

    static value_type identity() {
      return 0;
    }

    static value_type operation(const value_type&amp; a, const value_type&amp; b) {
      return a + b;
    }

    class node {
      private:
        key_type ky;
        value_type val;
        size_type sz;
        height_type hei;
        std::array&lt;node_type, 2&gt; chi;
      public:

        value_type fold;

        node(key_type key, value_type val): ky(std::move(key)), val(std::move(val)), fold(identity()), sz(1), hei(1), chi() { fix(); }
        void fix() {
          fold = val;
          if(chi[0]) fold = operation(chi[0]-&gt;fold, fold);
          if(chi[1]) fold = operation(fold, chi[1]-&gt;fold);
          sz = avl_tree_map::size(chi[0]) + avl_tree_map::size(chi[1]) + 1;
          hei = std::max(avl_tree_map::height(chi[0]), avl_tree_map::height(chi[1])) + 1;
        }
        void push() {}
        node_type cut(size_type dir) {
          push();
          node_type nn = std::move(chi[dir]);
          this-&gt;fix();
          return std::move(nn);
        }
        void set(node_type dir_node, size_type dir) {
          push();
          chi[dir] = std::move(dir_node);
          this-&gt;fix();
        }
        size_type size() { push(); return sz; }
        height_type height() { push(); return hei; }
        height_type diff() { push(); return avl_tree_map::height(chi[0]) - avl_tree_map::height(chi[1]); }
        value_type&amp; value() { push(); return val; }
        const key_type&amp; key() { push(); return ky; }
        node_type&amp; child(size_type dir) { return chi[dir]; }
    };


    static node_type rotate(node_type x, size_type dir) {
      node_type y = x-&gt;cut(1 - dir);
      node_type b = y-&gt;cut(dir);
      x-&gt;set(std::move(b), 1 - dir);
      y-&gt;set(std::move(x), dir);
      return std::move(y);
    }

    static node_type balance(node_type node) {
      if(node-&gt;diff() == 2) {
        if(node-&gt;child(0)-&gt;diff() == -1) {
          auto ch = node-&gt;cut(0);
          node-&gt;set(rotate(std::move(ch), 0), 0);
        }
        return rotate(std::move(node), 1);
      }
      else if(node-&gt;diff() == -2) {
        if(node-&gt;child(1)-&gt;diff() == 1) {
          auto ch = node-&gt;cut(1);
          node-&gt;set(rotate(std::move(ch), 1), 1);
        }
        return rotate(std::move(node), 0);
      }
      else return std::move(node);
    }

    static node_type insert(node_type node, key_type key, value_type val) {
      if(!node) {
        return node_type(new class node(std::move(key), std::move(val)));
      }
      else if(node-&gt;key() == key) {
        node-&gt;value() = val;
        node-&gt;fix();
        return std::move(node);
      }
      else if(node-&gt;key() &lt; key) {
        auto right = node-&gt;cut(1);
        node-&gt;set(insert(std::move(right), std::move(key), std::move(val)), 1);
        return balance(std::move(node));
      }
      else {
        auto left = node-&gt;cut(0);
        node-&gt;set(insert(std::move(left), std::move(key), std::move(val)), 0);
        return balance(std::move(node));
      }
    }

    static std::pair&lt;node_type, node_type&gt; deepest_node(node_type node, size_type dir) {
      auto ch = node-&gt;cut(dir);
      if(ch) {
        auto pp = deepest_node(std::move(ch), dir);
        node_type deepest_node, dirn;
        deepest_node = std::move(pp.first);
        dirn = std::move(pp.second);
        node-&gt;set(std::move(dirn), dir);
        pp.first = std::move(deepest_node);
        pp.second = balance(std::move(node));
        return std::move(pp);
      }
      else {
        auto rn = node-&gt;cut(1 - dir);
        std::pair&lt;node_type, node_type&gt; pp;
        pp.first = std::move(node);
        pp.second = std::move(rn);
        return pp;
      }
    }

    static node_type erase(node_type node, key_type key) {
      if(!node) { return std::move(node); }
      else if(node-&gt;key() == key) {
        node_type&amp; left = node-&gt;child(0);
        node_type&amp; right = node-&gt;child(1);
        if(!left) {
          return node-&gt;cut(1);
        }
        else {
          node_type deepest, ln;
          std::tie(deepest, ln) = deepest_node(std::move(left), 1);
          deepest-&gt;set(std::move(ln), 0);
          deepest-&gt;set(std::move(right), 1);
          return balance(std::move(deepest));
        }
      }
      else if(node-&gt;key() &lt; key) {
        auto right = node-&gt;cut(1);
        node-&gt;set(erase(std::move(right), std::move(key)), 1);
        return balance(std::move(node));
      }
      else {
        auto left = node-&gt;cut(0);
        node-&gt;set(erase(std::move(left), std::move(key)), 0);
        return balance(std::move(node));
      }
    }

    static node_type&amp; at(node_type&amp; node, key_type key) {
      if(!node) assert(false);
      else if(node-&gt;key() == key) return node;
      else if(node-&gt;key() &lt; key) return at(node-&gt;child(1), std::move(key));
      else return at(node-&gt;child(0), std::move(key));
    }

    static node_type&amp; lower_bound(node_type&amp; node, key_type key) {
      if(!node) return node;
      else if(key &lt; node-&gt;key()) {
        auto&amp; ans = lower_bound(node-&gt;child(0), std::move(key));
        if(ans) return ans;
        else return node;
      }
      else {
        return lower_bound(node-&gt;child(1), std::move(key));
      }
    }

    static node_type&amp; nth_node(node_type&amp; node, size_type i) {
      if(size(node-&gt;child(0)) == i) return node;
      else if(size(node-&gt;child(0)) &lt; i) return nth_node(node-&gt;child(1), i - size(node-&gt;child(0)) - 1);
      else return nth_node(node-&gt;child(0), i);
    }

    static value_type left_fold(node_type&amp; node, key_type left) {
      if(!node) { return identity(); }
      if(node-&gt;key() &lt; left) { return left_fold(node-&gt;child(1), std::move(left)); }
      else { 
        value_type R = identity();
        if(node-&gt;child(1)) R = node-&gt;child(1)-&gt;fold;
        return operation(left_fold(node-&gt;child(0), std::move(left)), operation(node-&gt;value(), R));
      }
    }

    static value_type right_fold(node_type&amp; node, key_type right) {
      if(!node) { return identity(); }
      if(!(node-&gt;key() &lt; right)) { return right_fold(node-&gt;child(0), std::move(right)); }
      else {
        value_type L = identity();
        if(node-&gt;child(0)) L = node-&gt;child(0)-&gt;fold;
        return operation(L, operation(node-&gt;value(), right_fold(node-&gt;child(1), std::move(right))));
      }
    }

    static value_type go_fold(node_type&amp; node, key_type left, key_type right) {
      if(!node) return identity();
      if(left &lt;= node-&gt;key() &amp;&amp; node-&gt;key() &lt; right) {
        return operation(left_fold(node-&gt;child(0), std::move(left)), operation(node-&gt;value(), right_fold(node-&gt;child(1), std::move(right))));
      }
      else if(node-&gt;key() &lt; left) {
        return go_fold(node-&gt;child(1), std::move(left), std::move(right));
      }
      else {
        return go_fold(node-&gt;child(0), std::move(left), std::move(right));
      }
    }

    node_type root;
    avl_tree_map(node_type&amp;&amp; root): root(std::move(root)) {}
  public:
    avl_tree_map(): root() {}
    avl_tree_map(avl_tree_map&amp;&amp; tree): root(std::move(tree.root)) {}
    avl_tree_map&amp; operator=(avl_tree_map&amp;&amp; tree) {
      root = std::move(tree.root);
      return *this;
    }

    value_type&amp; at(key_type key) {
      return at(root, std::move(key))-&gt;value();
    }

    void insert(key_type key, value_type val) {
      root = insert(std::move(root), std::move(key), std::move(val));
    }

    void erase(key_type key) {
      root = erase(std::move(root), std::move(key));
    }

    std::pair&lt;bool, std::pair&lt;key_type, value_type&gt;&gt; lower_bound(key_type key) {
      auto&amp; node = lower_bound(root, std::move(key));
      if(node) {
        return { true, { node-&gt;key(), node-&gt;value() } };
      }
      else {
        return { false, { key_type(), value_type() } };
      }
    }

    std::pair&lt;key_type, value_type&gt; nth_node(size_type i) {
      auto node = nth_node(root, i);
      return { node-&gt;key(), node-&gt;value() };
    }

    size_type size() {
      if(!root) return 0;
      return root-&gt;size();
    }

    value_type fold(key_type left, key_type right) {
      return go_fold(root, left, right);
    }
};
</code></pre>
<h1><a class="header" href="#persistent-avl-tree-array" id="persistent-avl-tree-array">Persistent AVL Tree Array</a></h1>
<p>列を永続的に管理するAVL Tree</p>
<h3><a class="header" href="#spec-18" id="spec-18">Spec</a></h3>
<ul>
<li>
<p><code>struct node</code></p>
<ul>
<li>
<p>Persistent AVL Treeに載せるノードの型</p>
</li>
<li>
<p><code>node(value_ref rootval, node_ref a, node_ref b)</code></p>
<ul>
<li>永続化ではノードを作るときだけ<code>fix</code>する</li>
<li>ここにfix操作を書く.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>split(size_type i)</code></p>
<ul>
<li><code>[0, i) / [i, ..)</code>に分けた木を返す</li>
</ul>
</li>
<li>
<p><code>merge(persistent_avl_array&amp;&amp; arr)</code></p>
<ul>
<li>mergeした木を返す.</li>
</ul>
</li>
<li>
<p><code>at(size_type i)</code></p>
<ul>
<li><code>i</code>番目の要素にアクセスする.</li>
</ul>
</li>
<li>
<p><code>push_back(val)</code></p>
<ul>
<li>列の一番うしろに要素を追加する.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-23" id="code-23">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#include &lt;cassert&gt;
using i64 = long long;

class persistent_avl_array {
  using T = char;

  struct node;

  using node_type = typename std::shared_ptr&lt;const node&gt;;
  using node_ref = const node_type&amp;;
  using value_type = T;
  using value_ref = const value_type&amp;;
  using size_type = i64;
  using split_node_type = std::pair&lt;node_type, node_type&gt;;

  static size_type size(node_ref n) {
    if(n) return n-&gt;sz;
    else return 0;
  }

  static size_type height(node_ref n) {
    if(n) return n-&gt;he;
    else return 0;
  }

  struct node {
    
    using node_type = std::shared_ptr&lt;const node&gt;;
    using node_ref = const node_type&amp;;
    using value_type = T;
    using value_ref = const value_type&amp;;
    using size_type = i64;

    value_type val;
    node_type ch[2];
    size_type sz;
    size_type he;

    node(value_ref val, node_ref left, node_ref right)
      : val(val) {
        sz = 1 + size(left) + size(right);
        he = 1 + std::max(height(left), height(right));
        assert(std::abs(height(left)-height(right))&lt;=1);
        ch[0] = left;
        ch[1] = right;
      }
  };

  static node_type balance(value_ref rootval, node_ref a, node_ref b) {
    if(height(a) - height(b) == 2) {
      if(height(a-&gt;ch[0]) - height(a-&gt;ch[1]) == -1)
        return std::make_shared&lt;const node&gt;(
            a-&gt;ch[1]-&gt;val,
            std::make_shared&lt;const node&gt; (a-&gt;val, a-&gt;ch[0], a-&gt;ch[1]-&gt;ch[0]),
            std::make_shared&lt;const node&gt; (rootval, a-&gt;ch[1]-&gt;ch[1], b)
            );
      else
        return std::make_shared&lt;const node&gt;(
            a-&gt;val, 
            a-&gt;ch[0],
            std::make_shared&lt;const node&gt; (rootval, a-&gt;ch[1], b)
            );
    }
    else if(height(a) - height(b) == -2) {
      if(height(b-&gt;ch[0]) - height(b-&gt;ch[1]) == 1)
        return std::make_shared&lt;const node&gt; (
            b-&gt;ch[0]-&gt;val,
            std::make_shared&lt;const node&gt; (rootval, a, b-&gt;ch[0]-&gt;ch[0]),
            std::make_shared&lt;const node&gt; (b-&gt;val, b-&gt;ch[0]-&gt;ch[1], b-&gt;ch[1])
            );
      else
        return std::make_shared&lt;const node&gt; (
            b-&gt;val,
            std::make_shared&lt;const node&gt;(rootval, a, b-&gt;ch[0]),
            b-&gt;ch[1]
            );
    }
    else
      return std::make_shared&lt;const node&gt;(rootval, a, b);
  }

  static node_ref back(node_ref node) {
    if(node-&gt;ch[1]) return back(node-&gt;ch[1]);
    else return node;
  }

  static node_type push_back(node_ref node, value_ref val) {
    if(!node) return std::make_shared&lt;const struct node&gt;(val, nullptr, nullptr);
    else if(node-&gt;ch[1]) return merge(node-&gt;val, node-&gt;ch[0], push_back(node-&gt;ch[1], val));
    else return merge(node-&gt;val, node-&gt;ch[0], std::make_shared&lt;const struct node&gt;(val, nullptr, nullptr));
  }

  static node_type pop_back(node_ref node) {
    if(node-&gt;ch[1]) return merge(node-&gt;val, node-&gt;ch[0], pop_back(node-&gt;ch[1]));
    else return node-&gt;ch[0];
  }

  static node_type merge_1(value_ref rootval, node_ref dst, node_ref src) {
    if(height(dst) - height(src) &lt;= 1)
      return std::make_shared&lt;const node&gt;(rootval, dst, src);
    else
      return balance(dst-&gt;val, dst-&gt;ch[0], merge_1(rootval, dst-&gt;ch[1], src));
  }

  static node_type merge_0(value_ref rootval, node_ref dst, node_ref src) {
    if(height(dst) - height(src) &lt;= 1)
      return std::make_shared&lt;const node&gt;(rootval, src, dst);
    else
      return balance(dst-&gt;val, merge_0(rootval, dst-&gt;ch[0], src), dst-&gt;ch[1]);
  }

  static node_type merge(value_ref rootval, node_ref left, node_ref right) {
    if(height(left) &gt;= height(right)) 
      return merge_1(rootval, left, right);
    else
      return merge_0(rootval, right, left);
  }

  static split_node_type split(node_ref node, size_type i) {
    if(i == 0)
      return split_node_type(node_type(), node);
    else if(i &lt;= size(node-&gt;ch[0])) {
      auto sp = split(node-&gt;ch[0], i);
      return split_node_type(sp.first, merge(node-&gt;val, sp.second, node-&gt;ch[1]));
    }
    else {
      auto sp = split(node-&gt;ch[1], i - size(node-&gt;ch[0]) - 1);
      return split_node_type(merge(node-&gt;val, node-&gt;ch[0], sp.first), sp.second);
    }
  }

  static node_ref at(node_ref node, size_type i) {
    if(i == size(node-&gt;ch[0])) return node;
    else if(i &lt; size(node-&gt;ch[0])) return at(node-&gt;ch[0], i);
    else return at(node-&gt;ch[1], i - 1 - size(node-&gt;ch[0]));
  }

  node_type root;

public:
  
  using split_array_type = std::pair&lt;persistent_avl_array, persistent_avl_array&gt;;

  persistent_avl_array() {}
  persistent_avl_array(node_ref r) : root(r) {}

  persistent_avl_array merge(persistent_avl_array other) const {
    if(!root) return other;
    else return persistent_avl_array(merge(back(root)-&gt;val, pop_back(root), other.root));
  }

  split_array_type split(size_type i) const {
    auto p = split(root, i);
    return { persistent_avl_array(p.first), persistent_avl_array(p.second) };
  }

  persistent_avl_array push_back(value_ref val) const {
    return persistent_avl_array(push_back(root, val));
  }

  size_type len() const { return size(root); }

  value_ref at(size_type i) const { return at(root, i)-&gt;val; }
};

using namespace std;

void debug_cout(const persistent_avl_array&amp; arr) {
    for(int i = 0;i &lt; arr.len();i++){
      cout &lt;&lt; arr.at(i);
    }
    cout &lt;&lt; endl;
}

int main() {
  std::ios::sync_with_stdio(false);
  cin.tie(nullptr);
  i64 m;
  cin &gt;&gt; m;
  string s;
  cin &gt;&gt; s;
  i64 n;
  cin &gt;&gt; n;

  persistent_avl_array arr;

  for(char c: s) { arr = arr.push_back(c);}

  for(int i = 0;i &lt; n;i++) {
    i64 a, b, c;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    
    auto cpy = arr.split(b).first.split(a).second;
    auto spl = arr.split(c);
    

    arr = spl.first.merge(cpy).merge(spl.second);
    if(arr.len() &gt; m) arr = arr.split(m).first;
  }

  for(int i = 0;i &lt; arr.len();i++){
    cout &lt;&lt; arr.at(i);
  }
  cout &lt;&lt; endl;
}

</code></pre>
<h1><a class="header" href="#sparse-table" id="sparse-table">Sparse Table</a></h1>
<h2><a class="header" href="#spec-19" id="spec-19">Spec</a></h2>
<ul>
<li>
<p><code>ope</code></p>
<ul>
<li>束の演算を定義する.</li>
</ul>
</li>
<li>
<p><code>(constructor)</code></p>
<ul>
<li>Sparse Tableを構築する. \( O(N \log N) \)</li>
</ul>
</li>
<li>
<p><code>query(i64 s, i64 t)</code></p>
<ul>
<li><code>[s, t)</code>に対してクエリを処理する.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#code-24" id="code-24">Code</a></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct sparse_table {
  using Band = int;
  inline Band ope(const Band&amp; a, const Band b) { return min(a, b); }

  i64 N;
  vector&lt;vector&lt;Band&gt;&gt; table;

  sparse_table(vector&lt;Band&gt; arr) : N(arr.size()) {
    table.resize(__lg(N) + 1);

    table[0].resize(N);
    for(int i = 0;i &lt; N;i++) {
      table[0][i] = arr[i];
    }

    for(int k = 1;(1 &lt;&lt; k) &lt;= N;k++) {
      table[k].resize(N);
      for(int i = 0;i + (1 &lt;&lt; k) &lt;= N;i++) {
        table[k][i] = ope(table[k - 1][i], table[k - 1][i + (1 &lt;&lt; (k - 1))]);
      }
    }
  }
  /* [s, t) */
  Band query(i64 s, i64 t) {
    int k = __lg(t - s);
    return ope(table[k][s], table[k][t - (1 &lt;&lt; k)]);
  }
};
</code></pre>
<h1><a class="header" href="#sparse-table-1" id="sparse-table-1">Sparse Table</a></h1>
<h2><a class="header" href="#spec-20" id="spec-20">Spec</a></h2>
<ul>
<li>
<p><code>ope</code></p>
<ul>
<li>束の演算を定義する.</li>
</ul>
</li>
<li>
<p><code>(constructor)</code></p>
<ul>
<li>Sparse Tableを構築する. \( O(N \log N) \)</li>
</ul>
</li>
<li>
<p><code>query(i64 s, i64 t)</code></p>
<ul>
<li><code>[s, t)</code>に対してクエリを処理する.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#code-25" id="code-25">Code</a></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct sparse_table {
  using Band = int;
  inline Band ope(const Band&amp; a, const Band b) { return min(a, b); }

  i64 N;
  vector&lt;vector&lt;Band&gt;&gt; table;

  sparse_table(vector&lt;Band&gt; arr) : N(arr.size()) {
    table.resize(__lg(N) + 1);

    table[0].resize(N);
    for(int i = 0;i &lt; N;i++) {
      table[0][i] = arr[i];
    }

    for(int k = 1;(1 &lt;&lt; k) &lt;= N;k++) {
      table[k].resize(N);
      for(int i = 0;i + (1 &lt;&lt; k) &lt;= N;i++) {
        table[k][i] = ope(table[k - 1][i], table[k - 1][i + (1 &lt;&lt; (k - 1))]);
      }
    }
  }
  /* [s, t) */
  Band query(i64 s, i64 t) {
    int k = __lg(t - s);
    return ope(table[k][s], table[k][t - (1 &lt;&lt; k)]);
  }
};
</code></pre>
<h1><a class="header" href="#wavelet-matrix" id="wavelet-matrix">Wavelet Matrix</a></h1>
<h1><a class="header" href="#wavelet-matrix-1" id="wavelet-matrix-1">Wavelet Matrix</a></h1>
<h2><a class="header" href="#spec-21" id="spec-21">Spec</a></h2>
<h2><a class="header" href="#code-26" id="code-26">Code</a></h2>
<pre><code class="language-cpp">#include &lt;cstdint&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

using i64 = long long;

class bitvector {
  using bit_type = std::uint_least64_t;
  using size_type = std::size_t;
  static constexpr size_type wordsize = 64;
  
  std::vector&lt;bit_type&gt; bit;
  std::vector&lt;size_type&gt; sum;
  
public:

  bitvector() : bit(), sum() {} 
  bitvector(const size_type size)
    : bit(size / wordsize + 1, 0), sum(size / wordsize + 1, 0) {}

  void set(const size_type i) {
    bit[i / wordsize] |= static_cast&lt;bit_type&gt;(1) &lt;&lt; (i % wordsize);
  }
  void build() {
    for (size_type i = 1; i &lt; bit.size(); i++) {
      sum[i] = sum[i - 1] + __builtin_popcountll(bit[i - 1]);
    }
  }

  size_type at(const size_type i) const {
    return bit[i / wordsize] &gt;&gt; (i % wordsize);
  }

  // count of ones in [0, i)
  size_type rank(const size_type i) const {
    return sum[i / wordsize]
      + __builtin_popcountll(bit[i / wordsize] &amp; (static_cast&lt;bit_type&gt;(1) &lt;&lt; (i % wordsize)) - 1);
  }

  // count of ones in [0, i)
  size_type rank(const size_type i, const size_type b) const {
    size_type ans = sum[i / wordsize]
      + __builtin_popcountll(bit[i / wordsize] &amp; (static_cast&lt;bit_type&gt;(1) &lt;&lt; (i % wordsize)) - 1);
    if(b) return ans;
    else return i - ans;
  }
};

class wavelet_matrix {
  using Integer = i64;
  using integer_type = Integer;
  using size_type = std::size_t;


  const size_type depth;
  const size_type len;
  std::vector&lt;bitvector&gt; mat;
  std::vector&lt;size_type&gt; spl;

public:

  wavelet_matrix(const std::vector&lt;integer_type&gt;&amp; arr, size_type de)
    : depth(de),
      len(arr.size()),
      mat(std::vector&lt;bitvector&gt;(depth, bitvector(arr.size()))),
      spl(std::vector&lt;size_type&gt;(depth, 0)) {
        std::vector&lt;size_type&gt; idx(len);
        std::vector&lt;size_type&gt; left(len), right(len);
        for(size_type i = 0;i &lt; len;i++) idx[i] = i;
        for(size_type d = depth; d-- &gt; 0;) {
          size_type l = 0, r = 0;
          
          for(size_type i = 0; i &lt; len; i++) {
            size_type k = (arr[idx[i]] &gt;&gt; d) &amp; 1;
            if(k) right[r++] = idx[i], mat[d].set(i);
            else left[l++] = idx[i];
          }
          mat[d].build();
          spl[d] = l;
          swap(idx, left);
          for(size_type i = 0; i &lt; r; i++) idx[i + l] = right[i];
        }
      }

  integer_type at(size_type i) const {
    integer_type x = static_cast&lt;integer_type&gt;(0);
    for(size_type d = depth; d-- &gt; 0;) {
      size_type k = mat[d].at(i);
      x |= (static_cast&lt;integer_type&gt;(k) &lt;&lt; d);
      i = mat[d].rank(i, k) + spl[d] * k;
    }
    return x;
  }

  // counting elements that equal to x in range [left, right)
  size_type rank_x(size_type left, size_type right, integer_type x) const {
    for(size_type d = depth; d-- &gt; 0;) {
      size_type k = ((x &gt;&gt; d) &amp; 1);
      left = mat[d].rank(left, k) + spl[d] * k;
      right = mat[d].rank(right, k) + spl[d] * k;
    }
    return right - left;
  }

  // sorted(arr[left..right])[i]
  integer_type quantile(size_type left, size_type right, size_type i) const {
    integer_type x = static_cast&lt;integer_type&gt;(0);
    for(size_type d = depth; d-- &gt; 0;) {
      size_type cnt = mat[d].rank(right, 0) - mat[d].rank(left, 0);
      size_type k = (i &lt; cnt) ? 0 : 1;
      if(k == 1) {
        i -= cnt;
        x |= (1 &lt;&lt; d);
      }
      left = mat[d].rank(left, k) + spl[d] * k;
      right = mat[d].rank(right, k) + spl[d] * k;
    }
    return x;
  }

  struct rank_result {
    size_type le;
    size_type eq;
    size_type mo;
  };

  // couting elements that less than x, equal to x, and more than x in range [left, right)
  rank_result rank_less_eq_more(size_type left, size_type right, integer_type x) const {
    size_type le = 0, mo = 0;
    for(size_type d = depth; d --&gt; 0;) {
      size_type k = (x &gt;&gt; d) &amp; 1;
      size_type l = mat[d].rank(left, 1);
      size_type r = mat[d].rank(right, 1);
      if(k == 0) {
        mo += r - l;
        left -= l;
        right -= r;
      }
      else {
        le += (right - left) - (r - l);
        left = l + spl[d];
        right = r + spl[d];
      }
    }
    return rank_result { le, right - left, mo };
  }

  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y, integer_type l, size_type d) const {
    integer_type r = l + (1 &lt;&lt; d);
    if(x &lt;= l &amp;&amp; r &lt;= y) {
      return right - left;
    }
    else if(y &lt;= l || r &lt;= x) {
      return 0;
    }
    else {
      d--;
      size_type lr = mat[d].rank(left, 1);
      size_type rr = mat[d].rank(right, 1);
      return
        rangefreq(left - lr, right - rr, x, y, l, d) +
        rangefreq(lr + spl[d], rr + spl[d], x, y, l + (1 &lt;&lt; d), d);
    }
  }

  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y) const {
    return rangefreq(left, right, x, y, 0, depth);
  }
};
</code></pre>
<h1><a class="header" href="#dynamic-wavelet-matrix" id="dynamic-wavelet-matrix">Dynamic Wavelet Matrix</a></h1>
<h2><a class="header" href="#spec-22" id="spec-22">Spec</a></h2>
<h2><a class="header" href="#code-27" id="code-27">Code</a></h2>
<pre><code class="language-cpp">#include &lt;array&gt;
#include &lt;set&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;cstdint&gt;
#include &lt;cassert&gt;
#include &lt;bitset&gt;

struct dynamic_bitvector {


  struct node;
  using size_type = std::size_t;
  using height_type = long long;
  using node_type = std::unique_ptr&lt;struct node&gt;;
  using node_reference = const node_type&amp;;
  using bits_type = std::uint64_t;
  using children_type = std::array&lt;node_type, 2&gt;;


  const static size_type bit_limit = 32;

  struct bitvector_builder {
    const static size_type bit_size = bit_limit * 2;
    const size_type len;
    std::vector&lt;bits_type&gt; bits;
    bitvector_builder(size_type len): len(len), bits(len / bit_size + !!(len &amp; (bit_size - 1))) {}
    void set(size_type i) { bits[i / bit_size] |= (bits_type(1) &lt;&lt; (i &amp; (bit_size - 1))); }
    dynamic_bitvector build() const {
      return dynamic_bitvector(bits, len);
    }
  };

  static size_type bits_popcount(bits_type bits) {
    return __builtin_popcountll(bits);
  }

  struct section_t {
    height_type he;
    children_type ch;
  };

  struct leaf_t {
    bits_type bits;
  };

  union info_t {
    section_t section;
    leaf_t leaf;
    info_t(section_t sec): section(std::move(sec)) {}
    info_t(leaf_t leaf): leaf(leaf) {}
    ~info_t() {}
  };

  struct node {
    const bool is_leaf;
    size_type sz;
    size_type popcnt;
    info_t info;

    static node_type new_section(node_type left, node_type right) {
      node* n = new node(section_t { 0, children_type { std::move(left), std::move(right) } });
      n-&gt;fix();
      return node_type(n);
    }

    static node_type new_leaf(bits_type bits, size_type sz, size_type popcnt) {
      node* n = new node(leaf_t { bits });
      n-&gt;sz = sz;
      n-&gt;popcnt = popcnt;
      return node_type(n); } node(section_t sec): is_leaf(false), info(std::move(sec)) {}
    node(leaf_t leaf): is_leaf(true), info(leaf) {}

    height_type height() const {
      if(is_leaf) return 0;
      else return info.section.he;
    }
    size_type size() const {
      return sz;
    }

    size_type popcount() const {
      return popcnt;
    }

    // operation for only section node

    node_type take(size_type dir) {
      assert(!is_leaf);
      return std::move(info.section.ch[dir]);
    }

    node_type swap(size_type dir, node_type new_node) {
      assert(!is_leaf);
      node_type old_node = take(dir);
      info.section.ch[dir] = std::move(new_node);
      return old_node;
    }

    const node_type&amp; child(size_type dir) const {
      assert(!is_leaf);
      return info.section.ch[dir];
    }

    height_type diff() const {
      assert(!is_leaf);
      return child(0)-&gt;height() - child(1)-&gt;height();
    }

    void fix() {
      assert(!is_leaf);
      sz = child(0)-&gt;size() + child(1)-&gt;size();
      popcnt = child(0)-&gt;popcount() + child(1)-&gt;popcount();
      info.section.he = std::max(child(0)-&gt;height(), child(1)-&gt;height()) + 1;
    }

    // operation for only leaf node

    bits_type bits() const {
      assert(is_leaf);
      return info.leaf.bits;
    }

    bool at_bits(size_type pos) const {
      assert(is_leaf);
      return (bits() &gt;&gt; pos) &amp; 1;
    }

    size_type rank(size_type pos) const {
      assert(pos &lt;= size());
      return bits_popcount(bits() &amp; ((bits_type(1) &lt;&lt; pos) - 1));
    }

    void set_bits(bits_type bits, size_type sz_, size_type popcnt_) {
      assert(is_leaf);
      sz = sz_;
      popcnt = popcnt_;
      info.leaf.bits = bits;
    }

    // [0, pos) and [pos, sz)
    std::pair&lt;bits_type, bits_type&gt; split_bits(size_type pos) const {
      assert(is_leaf);
      assert(pos &lt;= size());
      return std::make_pair(bits() &amp; ((bits_type(1) &lt;&lt; pos) - 1), bits() &gt;&gt; pos);
    }

    void insert_bit(size_type pos, bool bit) {
      assert(is_leaf);
      assert(sz &lt; bit_limit * 2);
      bits_type l, r;
      std::tie(l, r) = split_bits(pos);
     // std::cout &lt;&lt; &quot;insert &quot; &lt;&lt; bit  &lt;&lt; &quot; to &quot; &lt;&lt; pos &lt;&lt; std::endl;
     // std::cout &lt;&lt; &quot;insert &quot; &lt;&lt; std::bitset&lt;bit_limit * 2&gt;(l) &lt;&lt; &quot; &quot; &lt;&lt; std::bitset&lt;bit_limit * 2&gt;(r) &lt;&lt; std::endl;
     // std::cout &lt;&lt; &quot;insert &quot; &lt;&lt; std::bitset&lt;bit_limit * 2&gt;(bits()) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; std::bitset&lt;bit_limit * 2&gt;(l | ((bits_type(bit) &lt;&lt; pos)) | (r &lt;&lt; (pos + 1))) &lt;&lt; std::endl;
      set_bits(l | ((bits_type(bit) &lt;&lt; pos)) | (r &lt;&lt; (pos + 1)), sz + 1, popcount() + bit);
    } 

    void erase_bit(size_type pos) {
      assert(is_leaf);
      assert(0 &lt; sz);
      bits_type l, r;
      std::tie(l, r) = split_bits(pos);
      size_type pos_bit = r &amp; 1;
      r &gt;&gt;= 1;
      set_bits(l | (r &lt;&lt; pos), sz - 1, popcount() - pos_bit);
    }
  };


  static node_type rotate(node_type x, size_type dir) {
    x-&gt;fix();
    node_type y = x-&gt;take(1 - dir);
    node_type b = y-&gt;take(dir);
    x-&gt;swap(1 - dir, std::move(b));
    x-&gt;fix();
    y-&gt;swap(dir, std::move(x));
    y-&gt;fix();
    return std::move(y);
  }

  static node_type balance(node_type node) {
    node-&gt;fix();
    if(node-&gt;diff() == 2) {
      if(node-&gt;child(0)-&gt;diff() == -1) {
        auto ch = node-&gt;take(0);
        node-&gt;swap(0, rotate(std::move(ch), 0));
      }
      return rotate(std::move(node), 1);
    }
    else if(node-&gt;diff() == -2) {
      if(node-&gt;child(1)-&gt;diff() == 1) {
        auto ch = node-&gt;take(1);
        node-&gt;swap(1, rotate(std::move(ch), 1));
      }
      return rotate(std::move(node), 0);
    }
    else return std::move(node);
  }

  static node_type split_node(node_type node) {
    assert(node-&gt;is_leaf);
    bits_type l, r;
    std::tie(l, r) = node-&gt;split_bits(bit_limit);
    return node::new_section(
        node::new_leaf(l, bit_limit, bits_popcount(l)), node::new_leaf(r, node-&gt;size() - bit_limit, bits_popcount(r))
        );
  }

  static node_type insert(node_type node, size_type pos, bool bit) {
    if(node-&gt;is_leaf) {
      if(node-&gt;size() == 2 * bit_limit) {
        return insert(split_node(std::move(node)), pos, bit);
      }
      else {
        node-&gt;insert_bit(pos, bit);
        return node;
      }
    }
    else if(pos &lt; node-&gt;child(0)-&gt;size()) {
      node-&gt;swap(0, insert(node-&gt;take(0), pos, bit));
      return balance(std::move(node));
    }
    else {
      node-&gt;swap(1, insert(node-&gt;take(1), pos - node-&gt;child(0)-&gt;size(), bit));
      return balance(std::move(node));
    }
  }

  template&lt;const size_type dir&gt;
  static std::tuple&lt;node_type, bits_type, size_type&gt; take_bit(node_type node, size_type len) {
    if(node-&gt;is_leaf) {
      if(node-&gt;size() &lt; bit_limit / 2 + len) {
        return std::tuple&lt;node_type, bits_type, size_type&gt;{ node_type(nullptr), node-&gt;bits(), node-&gt;size() };
      }
      else {
        auto p = node-&gt;split_bits(dir == 0 ? len : node-&gt;size() - len);
        bits_type node_bit = std::get&lt;1 - dir&gt;(p);
        bits_type take = std::get&lt;dir&gt;(p);
        node-&gt;set_bits(node_bit, node-&gt;size() - len, bits_popcount(node_bit));
        return std::tuple&lt;node_type, bits_type, size_type&gt; { std::move(node), take, len };
      }
    }
    else {
      node_type ch;
      bits_type bits;
      size_type take_len;
      std::tie(ch, bits, take_len) = take_bit&lt;dir&gt;(node-&gt;take(dir), len);
      if(ch) {
        node-&gt;swap(dir, std::move(ch));
        return std::tuple&lt;node_type, bits_type, size_type&gt;{ balance(std::move(node)), bits, take_len };
      }
      else {
        return std::tuple&lt;node_type, bits_type, size_type&gt; { node-&gt;take(1 - dir), bits, take_len };
      }
    }
  }

  static node_type erase(node_type node, size_type pos) {
    if(node-&gt;is_leaf) {
      node-&gt;erase_bit(pos);
      return node;
    }
    else if(pos &lt; node-&gt;child(0)-&gt;size()) {
      auto left = erase(node-&gt;take(0), pos);
      if(left-&gt;size() &lt; bit_limit / 2) {
        assert(left-&gt;is_leaf);
        node_type right;
        bits_type bits;
        size_type len;
        std::tie(right, bits, len) = take_bit&lt;0&gt;(node-&gt;take(1), bit_limit / 2 - left-&gt;size());

        left-&gt;set_bits(left-&gt;bits() | (bits &lt;&lt; left-&gt;size()), left-&gt;size() + len, left-&gt;popcount() + bits_popcount(bits));
        if(right) {
          node-&gt;swap(0, std::move(left));
          node-&gt;swap(1, std::move(right));
          return balance(std::move(node));
        }
        else {
          return left;
        }
      }
      else {
        node-&gt;swap(0, std::move(left));
        return balance(std::move(node));
      }
    }
    else {
      auto right = erase(node-&gt;take(1), pos - node-&gt;child(0)-&gt;size());
      if(right-&gt;size() &lt; bit_limit / 2) {
        assert(right-&gt;is_leaf);
        node_type left;
        bits_type bits;
        size_type len;
        std::tie(left, bits, len) = take_bit&lt;1&gt;(node-&gt;take(0), bit_limit / 2 - right-&gt;size());

        right-&gt;set_bits((right-&gt;bits() &lt;&lt; len) | bits, right-&gt;size() + len, right-&gt;popcount() + bits_popcount(bits));
        if(left) {
          node-&gt;swap(0, std::move(left));
          node-&gt;swap(1, std::move(right));
          return balance(std::move(node));
        }
        else {
          return right;
        }
      }
      else {
        node-&gt;swap(1, std::move(right));
        return balance(std::move(node));
      }
    }
  }

  static node_type merge_dir(node_type dst, node_type src, size_type dir) {
    if(std::abs(dst-&gt;height() - src-&gt;height()) &lt;= 1) {
      if(dir == 0)
        return node::new_section(std::move(src), std::move(dst));
      else
        return node::new_section(std::move(dst), std::move(src));
    }
    else {
      node_type ch = dst-&gt;take(dir);
      assert(ch);
      dst-&gt;swap(dir, merge_dir(std::move(ch), std::move(src), dir));
      return balance(std::move(dst));
    }
  }

  static node_type merge(node_type left, node_type right) {
    if(!left) { return std::move(right); }
    else if(!right) { return std::move(left); }
    else if(left-&gt;height() &gt;= right-&gt;height()) {
      return merge_dir(std::move(left), std::move(right), 1);
    }
    else {
      return merge_dir(std::move(right), std::move(left), 0);
    }
  }

  static node_type build(const std::vector&lt;bits_type&gt;&amp; bits, size_type l, size_type r, size_type len) {
    if(len == 0) node::new_leaf(0, 0, 0);
    //std::cout &lt;&lt; &quot;build &quot; &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; len &lt;&lt; std::endl;
    if(l + 1 &gt;= r) {
      //std::cout &lt;&lt; &quot;create leaf&quot; &lt;&lt; std::endl;
      //std::cout &lt;&lt; &quot;-----------&quot; &lt;&lt; std::endl;
      return node::new_leaf(bits[l], len, bits_popcount(bits[l]));
    }
    else {
      size_type m = (l + r) &gt;&gt; 1;
      return merge(build(bits, l, m, (m - l) * 64), build(bits, m, r, len - (m - l) * 64));
    }
  }

  static size_type at(node_reference node, size_type pos) {
    if(node-&gt;is_leaf) {
      return node-&gt;at_bits(pos);
    }
    else if(pos &lt; node-&gt;child(0)-&gt;size()) {
      return at(node-&gt;child(0), pos);
    }
    else {
      return at(node-&gt;child(1), pos - node-&gt;child(0)-&gt;size());
    }
  }

  static size_type rank(node_reference node, size_type pos) {
    if(node-&gt;is_leaf) {
      return node-&gt;rank(pos);
    }
    else if(pos == node-&gt;size()) {
      return node-&gt;popcount();
    }
    else if(pos &lt; node-&gt;child(0)-&gt;size()) {
      return rank(node-&gt;child(0), pos);
    }
    else {
      return node-&gt;child(0)-&gt;popcount() + rank(node-&gt;child(1), pos - node-&gt;child(0)-&gt;size());
    }
  }


  node_type root;

  dynamic_bitvector(): root(node::new_leaf(0, 0, 0)) {}
  dynamic_bitvector(const std::vector&lt;bits_type&gt;&amp; bits, size_type len): root(build(bits, 0, bits.size(), len)) {}
  void insert(size_type pos, bool bit) {
    root = insert(std::move(root), pos, bit);
  }
  void erase(size_type pos) {
    root = erase(std::move(root), pos);
  }
  bool at(size_type pos) const {
    return at(root, pos);
  }
  size_type rank(size_type pos) const {
    return rank(root, pos);
  }
  size_type rank(size_type pos, bool bit) const {
    if(bit) {
      return rank(root, pos);
    }
    else {
      return pos - rank(root, pos);
    }
  }
  size_type size() const {
    return root-&gt;size();
  }

  void debug_tree(node_reference node, std::string d) const {
    if(node-&gt;is_leaf) {
      std::cout &lt;&lt; d &lt;&lt; &quot;leaf &quot; &lt;&lt; node-&gt;size() &lt;&lt; &quot; &quot; &lt;&lt; node-&gt;popcount() &lt;&lt; &quot; -----------&quot; &lt;&lt; std::endl;
      std::cout &lt;&lt; d &lt;&lt; std::bitset&lt;bit_limit * 2&gt;(node-&gt;bits()) &lt;&lt; std::endl;
      std::cout &lt;&lt; d &lt;&lt; &quot;-------------&quot; &lt;&lt; std::endl;
    }
    else {
      std::cout &lt;&lt; d &lt;&lt; &quot;node &quot; &lt;&lt; node-&gt;size() &lt;&lt; &quot; &quot; &lt;&lt; node-&gt;popcount() &lt;&lt; &quot; ----------&quot; &lt;&lt; std::endl;
      std::cout &lt;&lt; d &lt;&lt; &quot;left&quot; &lt;&lt; std::endl;
      debug_tree(node-&gt;child(0), d + &quot;   &quot;);
      std::cout &lt;&lt; d &lt;&lt; &quot;--------------&quot; &lt;&lt; std::endl;
      std::cout &lt;&lt; d &lt;&lt; &quot;right&quot; &lt;&lt; std::endl;
      debug_tree(node-&gt;child(1), d + &quot;   &quot;);
      std::cout &lt;&lt; d &lt;&lt; &quot;--------------&quot; &lt;&lt; std::endl;
    }
  }

  void debug_tree() const {
    debug_tree(root, &quot;&quot;);
  }
};

#include &lt;vector&gt;
struct dynamic_wavelet_matrix {
  using Integer = long long;
  using integer_type = Integer;
  using size_type = std::size_t;


  const size_type depth;
  const size_type len;
  std::vector&lt;dynamic_bitvector&gt; mat;
  std::vector&lt;size_type&gt; spl;

public:

  dynamic_wavelet_matrix(const std::vector&lt;integer_type&gt;&amp; arr, size_type de)
    : depth(de),
      mat(de),
      len(arr.size()),
      spl(std::vector&lt;size_type&gt;(depth, 0)) {
        std::vector&lt;size_type&gt; idx(len);
        std::vector&lt;size_type&gt; left(len), right(len);

        for(size_type i = 0;i &lt; len;i++) idx[i] = i;

        for(size_type d = depth; d-- &gt; 0;) {
          size_type l = 0, r = 0;
          dynamic_bitvector::bitvector_builder builder(len);
          for(size_type i = 0; i &lt; len; i++) {
            size_type k = (arr[idx[i]] &gt;&gt; d) &amp; 1;
            if(k) right[r++] = idx[i], builder.set(i);
            else left[l++] = idx[i];
          }
          mat[d] = builder.build();
          spl[d] = l;
          swap(idx, left);
          for(size_type i = 0; i &lt; r; i++) idx[i + l] = right[i];
        }
      }

  void insert(size_type i, integer_type x) {
    for(size_type d = depth; d --&gt; 0;) {
      size_type k = ((x &gt;&gt; d) &amp; 1);
      mat[d].insert(i, k);
      i = mat[d].rank(i, k) + spl[d] * k;
      if(k == 0) spl[d]++;
    }
  }

  void erase(size_type i) {
    for(size_type d = depth; d--&gt; 0;) {
      size_type k = mat[d].at(i);
      mat[d].erase(i);
      i = mat[d].rank(i, k) + spl[d] * k;
      if(k == 0) spl[d]--;
    }
  }

  integer_type at(size_type i) const {
    integer_type x = static_cast&lt;integer_type&gt;(0);
    for(size_type d = depth; d-- &gt; 0;) {
      size_type k = mat[d].at(i);
      x |= (static_cast&lt;integer_type&gt;(k) &lt;&lt; d);
      i = mat[d].rank(i, k) + spl[d] * k;
    }
    return x;
  }

  // counting elements that equal to x in range [left, right)
  size_type rank_x(size_type left, size_type right, integer_type x) const {
    for(size_type d = depth; d-- &gt; 0;) {
      size_type k = ((x &gt;&gt; d) &amp; 1);
      left = mat[d].rank(left, k) + spl[d] * k;
      right = mat[d].rank(right, k) + spl[d] * k;
    }
    return right - left;
  }

  // sorted(arr[left..right])[i]
  integer_type quantile(size_type left, size_type right, size_type i) const {
    integer_type x = static_cast&lt;integer_type&gt;(0);
    for(size_type d = depth; d-- &gt; 0;) {
      size_type l = mat[d].rank(left, 1);
      size_type r = mat[d].rank(right, 1);
      size_type cnt = (right - left) - (r - l);
      size_type k = (i &lt; cnt) ? 0 : 1;
      if(k == 0) {
        left -= l;
        right -= r;
      }
      else {
        x |= (1 &lt;&lt; d);
        i -= cnt;
        left = l + spl[d];
        right = r + spl[d];
      }
    }
    return x;
  }

  struct rank_result {
    size_type le;
    size_type eq;
    size_type mo;
  };

  // couting elements that less than x, equal to x, and more than x in range [left, right)
  rank_result rank_less_eq_more(size_type left, size_type right, integer_type x) const {
    size_type le = 0, mo = 0;
    for(size_type d = depth; d --&gt; 0;) {
      size_type k = (x &gt;&gt; d) &amp; 1;
      size_type l = mat[d].rank(left, 1);
      size_type r = mat[d].rank(right, 1);
      if(k == 0) {
        mo += r - l;
        left -= l;
        right -= r;
      }
      else {
        le += (right - left) - (r - l);
        left = l + spl[d];
        right = r + spl[d];
      }
    }
    return rank_result { le, right - left, mo };
  }

  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y, integer_type l, size_type d) const {
    integer_type r = l + (1 &lt;&lt; d);
    if(x &lt;= l &amp;&amp; r &lt;= y) {
      return right - left;
    }
    else if(y &lt;= l || r &lt;= x) {
      return 0;
    }
    else {
      d--;
      size_type lr = mat[d].rank(left, 1);
      size_type rr = mat[d].rank(right, 1);
      return
        rangefreq(left - lr, right - rr, x, y, l, d) +
        rangefreq(lr + spl[d], rr + spl[d], x, y, l + (1 &lt;&lt; d), d);
    }
  }

  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y) const {
    return rangefreq(left, right, x, y, 0, depth);
  }

  size_type rangefreq_count(size_type left, size_type right, integer_type x, integer_type y) const {
    auto p = rank_less_eq_more(left, right, x);
    auto q = rank_less_eq_more(left, right, y);
    return p.eq + p.mo - q.eq - q.mo;
  }
};

#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;
#define rep(i,s,e) for(i64 (i) = (s);(i) &lt; (e);(i)++)
#define all(x) x.begin(),x.end()

template&lt;class T&gt;
static inline std::vector&lt;T&gt; ndvec(size_t&amp;&amp; n, T val) noexcept {
  return std::vector&lt;T&gt;(n, std::forward&lt;T&gt;(val));
}

template&lt;class... Tail&gt;
static inline auto ndvec(size_t&amp;&amp; n, Tail&amp;&amp;... tail) noexcept {
  return std::vector&lt;decltype(ndvec(std::forward&lt;Tail&gt;(tail)...))&gt;(n, ndvec(std::forward&lt;Tail&gt;(tail)...));
}


int main() {
  cin.tie(nullptr);
  std::ios::sync_with_stdio(false);

  i64 N, Q;
  cin &gt;&gt; N &gt;&gt; Q;
  vector&lt;i64&gt; A(N);
  rep(i,0,N) cin &gt;&gt; A[i];
  
  dynamic_wavelet_matrix wm(A, 30);

  while(Q--) {
    i64 l, r, k;
    cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;
    cout &lt;&lt; wm.quantile(l, r, k) &lt;&lt; &quot;\n&quot;;
  }
}
</code></pre>
<h1><a class="header" href="#fully-retroactive-stack" id="fully-retroactive-stack">Fully Retroactive Stack</a></h1>
<h3><a class="header" href="#code-28" id="code-28">Code</a></h3>
<pre><code class="language-cpp">#include &lt;cstdint&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;

struct retroactive_stack {
  using value_type = long long;
  using size_type = std::size_t;
  using height_type = std::int_least32_t;
  using node_index = std::int_least32_t;

  struct diff {
    value_type p_value;
    height_type d;
    height_type max_d;
    height_type min_d;

    static diff push_diff(value_type value) {
      diff i;
      i.p_value = value;
      i.d = 1;
      i.max_d = 1;
      i.min_d = 0;
      return i;
    }
    static diff pop_diff() {
      diff i;
      i.d = -1;
      i.max_d = 0;
      i.min_d = -1;
      return i;
    }

    static diff ope(const diff&amp; l, const diff&amp; r) {
      diff i;
      i.d = l.d + r.d;
      i.max_d = std::max(l.max_d, l.d + r.max_d);
      i.min_d = std::min(l.min_d, l.d + r.min_d);
      return i;
    }
  };

  struct node;

  static struct node n[2020202];
  static size_type ni;

  struct node {
    diff d;
    size_type s;
    height_type h;
    node_index c[2];
    node_index p;
    node() {}
    node&amp; operator[](size_type d) { return n[c[d]]; }
  };

  static node_index new_node(const diff&amp; d) {
    node_index i = ni++;
    n[i].s = 1;
    n[i].h = 1;
    n[i].d = d;
    return i;
  }
  static void fix(node_index i) {
    n[i].s = n[i][0].s + n[i][1].s;
    n[i].h = std::max(n[i][0].h, n[i][1].h) + 1;
    n[i].d = diff::ope(n[i][0].d, n[i][1].d);
  }

  static size_type child_dir(node_index i) {
    if(n[i].p) {
      if(n[n[i].p].c[0] == i) { return 0; }
      else if(n[n[i].p].c[1] == i) { return 1; }
      assert(false);
    }
    return -1;
  }
  static node_index rotate(node_index x, size_type dir) {
    node_index p = n[x].p;
    size_type x_dir = child_dir(x);
    node_index y = n[x].c[1 ^ dir];
    n[n[y][dir].p = x].c[1 ^ dir] = n[y].c[dir];
    n[n[x].p = y].c[dir] = x;
    n[y].p = p;
    if(p &gt; 0) n[p].c[x_dir] = y;
    fix(x);
    fix(y);
    return y;
  }

  static node_index balance(node_index i) {
    fix(i);
    if(n[i][0].h - n[i][1].h == 2) {
      if(n[i][0][0].h - n[i][0][1].h == -1) {
        rotate(n[i].c[0], 0);
      }
      return rotate(i, 1);
    }
    else if(n[i][0].h - n[i][1].h == -2) {
      if(n[i][1][0].h - n[i][1][1].h == 1) {
        rotate(n[i].c[1], 1);
      }
      return rotate(i, 0);
    }
    return i;
  }


  static node_index merge_dir(node_index l, node_index root, node_index r, size_type dir) {
    while(std::abs(n[l].h - n[r].h) &gt; 1) {
      l = n[l].c[dir];
    }
    node_index x = n[l].p;
    n[n[l].p = root].c[dir ^ 1] = l;
    n[n[r].p = root].c[dir] = r;
    fix(root);
    n[n[root].p = x].c[dir] = root;
    x = root;
    while(n[x].p &gt; 0) {
      x = n[x].p;
      x = balance(x);
    }
    return x;
  }

  static node_index merge(node_index l, node_index r) {
    if(!l) return r;
    else if(!r) return l;
    else if(n[l].h &gt;= n[r].h) {
      return merge_dir(l, new_node(diff()), r, 1);
    }
    else {
      return merge_dir(r, new_node(diff()), l, 0);
    }
  }

  static std::pair&lt;node_index, node_index&gt; split(node_index root, size_type pos) {
    if(pos == 0) return { 0, root };
    if(pos == n[root].s) return { root, 0 };
    node_index i = root;
    node_index par = -1;
    while(i &gt; 0 &amp;&amp; pos != n[i][0].s) {
      if(pos &lt; n[i][0].s) {
        i = n[i].c[0];
      }
      else {
        pos -= n[i][0].s;
        i = n[i].c[1];
      }
    }
    node_index l = n[i].c[0];
    n[l].p = 0;
    node_index r = n[i].c[1];
    n[r].p = 0;
    size_type dir;
    node_index p = n[i].p;
    node_index pd = child_dir(i);
    while(dir = pd, i = p, i &gt; 0) {
      //std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; dir &lt;&lt; std::endl;
      pd = child_dir(i);
      p = n[i].p;
      n[i].p = 0;
      if(dir == 0) {
        n[i][1].p = 0;
        //std::cout &lt;&lt; &quot;merge_dir, 0&quot; &lt;&lt; std::endl;
        //debug(n[i].c[1], &quot;&quot;);
        //debug(r, &quot;&quot;);
        r = merge_dir(n[i].c[1], i, r, 0);
        //debug(r, &quot;&quot;);
      }
      else {
        n[i][0].p = 0;
        //std::cout &lt;&lt; &quot;merge_dir, 0&quot; &lt;&lt; std::endl;
        //debug(n[i].c[0], &quot;&quot;);
        //debug(l, &quot;&quot;);
        l = merge_dir(n[i].c[0], i, l, 1);
        //debug(l, &quot;&quot;);
      }
    }
    return { l, r };
  }

  static node_index at(node_index i, size_type pos) {
    while(n[i].c[0]) {
      if(pos &lt; n[i][0].s) {
        i = n[i].c[0];
      }
      else {
        pos -= n[i][0].s;
        i = n[i].c[1];
      }
    }
    return i;
  }

  static void set(node_index i, size_type pos, diff v) {
    node_index par = -1;
    while(n[i].c[0]) {
      if(pos &lt; n[i][0].s) {
        i = n[i].c[0];
      }
      else {
        pos -= n[i][0].s;
        i = n[i].c[1];
      }
    }
    n[i].d = v;

    while(i = n[i].p, i &gt; 0) {
      fix(i);
    }
  }

  static size_type index(node_index i) {
    size_type pos = 0;
    while(n[i].p &gt; 0) {
      if(child_dir(i) == 1) {
        pos += n[n[i].p][0].s;
      }
      i = n[i].p;
    }
    return pos;
  }

  static node_index search(node_index i, height_type pos) {
    while(n[i].c[0]) {
      if(n[i][0].d.d + n[i][1].d.min_d &lt;= pos &amp;&amp; pos &lt; n[i][0].d.d + n[i][1].d.max_d) {
        pos -= n[i][0].d.d;
        i = n[i].c[1];
      }
      else {
        i = n[i].c[0];
      }
    }
    return i;
  }

  static std::pair&lt;node_index, node_index&gt; min_depth_split(node_index i) {
    node_index r = i;
    size_type pos = n[i].d.min_d;
    size_type res = 0;
    while(n[i].c[0]) {
      if(n[i][0].d.d + n[i][1].d.min_d &lt;= pos &amp;&amp; pos &lt; n[i][0].d.d + n[i][1].d.max_d) {
        pos -= n[i][0].d.d;
        res += n[i][0].s;
        i = n[i].c[1];
      }
      else {
        i = n[i].c[0];
      }
    }
    return split(r, res);
  }

  static void debug(node_index i, std::string s) {
    if(i == 0) {
      std::cout &lt;&lt; s &lt;&lt; 0 &lt;&lt; std::endl;
      return;
    }
    std::cout &lt;&lt; s &lt;&lt; i &lt;&lt; &quot; = &quot; &lt;&lt; n[i].d.p_value &lt;&lt; &quot; = &quot; &lt;&lt; n[i].p &lt;&lt; &quot; = &quot; &lt;&lt; n[i].s &lt;&lt; std::endl;
    if(n[i].c[0] &amp;&amp; n[i][0].p != i) {
      assert(false);
    }
    debug(n[i].c[0], s + &quot;  &quot;);
    if(n[i].c[1] &amp;&amp; n[i][1].p != i) {
      assert(false);
    }
    debug(n[i].c[1], s + &quot;  &quot;);
  }


public:

  node_index root;
  retroactive_stack(): root(0) {}
  retroactive_stack(node_index i): root(i) {}

  static node_index new_push_operation(value_type val) {
    return new_node(diff::push_diff(val));
  }
  static node_index new_pop_operation() {
    return new_node(diff::pop_diff());
  }

  retroactive_stack&amp; merge(retroactive_stack right) {
    root = merge(this-&gt;root, right.root);
    return *this;
  }
  retroactive_stack split(node_index i) {
    auto p = split(root, index(i));
    retroactive_stack avl;
    avl.root = p.second;
    root = p.first;
    return avl;
  }

  void update(node_index i, diff v) {
    set(root, index(i), v);
  }

  size_type operation_size() {
    return n[root].s;
  }

  height_type stack_size() {
    return n[root].d.d;
  }

  value_type top() {
    auto P = min_depth_split(root);
    auto res = n[search(P.second, n[P.second].d.d - 1)].d.p_value;
    root = merge(P.first, P.second);
    return res;
  }

  void debug() {
    debug(root, &quot;&quot;);
  }
};

retroactive_stack::size_type retroactive_stack::ni = 1;
retroactive_stack::node retroactive_stack::n[2020202];

#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;
#define rep(i,s,e) for(i64 (i) = (s);(i) &lt; (e);(i)++)
#define all(x) x.begin(),x.end()

template&lt;class T&gt;
static inline std::vector&lt;T&gt; ndvec(size_t&amp;&amp; n, T val) noexcept {
  return std::vector&lt;T&gt;(n, std::forward&lt;T&gt;(val));
}

template&lt;class... Tail&gt;
static inline auto ndvec(size_t&amp;&amp; n, Tail&amp;&amp;... tail) noexcept {
  return std::vector&lt;decltype(ndvec(std::forward&lt;Tail&gt;(tail)...))&gt;(n, ndvec(std::forward&lt;Tail&gt;(tail)...));
}

template&lt;class T, class Cond&gt;
struct chain {
  Cond cond; chain(Cond cond) : cond(cond) {}
  bool operator()(T&amp; a, const T&amp; b) const {
    if(cond(a, b)) { a = b; return true; }
    return false;
  }
};
template&lt;class T, class Cond&gt;
chain&lt;T, Cond&gt; make_chain(Cond cond) { return chain&lt;T, Cond&gt;(cond); }

int main() {
  std::vector&lt;int&gt; opes;
  opes.push_back(retroactive_stack::new_push_operation(1));
  opes.push_back(retroactive_stack::new_push_operation(2));
  opes.push_back(retroactive_stack::new_push_operation(3));

  retroactive_stack st;

  st.merge(retroactive_stack::new_pop_operation());
  st.merge(retroactive_stack::new_pop_operation());
  st.merge(retroactive_stack::new_pop_operation());

  for(auto i: opes) {
    st.merge(retroactive_stack(i));
  }
  std::cout &lt;&lt; st.top() &lt;&lt; std::endl; // 3

  int pop_ope = retroactive_stack::new_pop_operation();

  st.merge(retroactive_stack(pop_ope));

  std::cout &lt;&lt; st.top() &lt;&lt; std::endl; // 2

  st.merge(retroactive_stack(retroactive_stack::new_pop_operation()));
  std::cout &lt;&lt; st.top() &lt;&lt; std::endl; // 1

  st.update(pop_ope, retroactive_stack::diff::push_diff(4));
  std::cout &lt;&lt; st.top() &lt;&lt; std::endl; // 3 (push 1 -&gt; push 2 -&gt; push 3 -&gt; push 4 -&gt; pop)

  auto after = st.split(opes[2]);
  std::cout &lt;&lt; st.top() &lt;&lt; std::endl; // 2 st := (push 1 -&gt; push 2)
}
</code></pre>
<h1><a class="header" href="#fully-retroactive-stack-1" id="fully-retroactive-stack-1">Fully Retroactive Stack</a></h1>
<h3><a class="header" href="#code-29" id="code-29">Code</a></h3>
<pre><code class="language-cpp">#include &lt;cstdint&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;

struct retroactive_stack {
  using value_type = long long;
  using size_type = std::size_t;
  using height_type = std::int_least32_t;
  using node_index = std::int_least32_t;

  struct diff {
    value_type p_value;
    height_type d;
    height_type max_d;
    height_type min_d;

    static diff push_diff(value_type value) {
      diff i;
      i.p_value = value;
      i.d = 1;
      i.max_d = 1;
      i.min_d = 0;
      return i;
    }
    static diff pop_diff() {
      diff i;
      i.d = -1;
      i.max_d = 0;
      i.min_d = -1;
      return i;
    }

    static diff ope(const diff&amp; l, const diff&amp; r) {
      diff i;
      i.d = l.d + r.d;
      i.max_d = std::max(l.max_d, l.d + r.max_d);
      i.min_d = std::min(l.min_d, l.d + r.min_d);
      return i;
    }
  };

  struct node;

  static struct node n[2020202];
  static size_type ni;

  struct node {
    diff d;
    size_type s;
    height_type h;
    node_index c[2];
    node_index p;
    node() {}
    node&amp; operator[](size_type d) { return n[c[d]]; }
  };

  static node_index new_node(const diff&amp; d) {
    node_index i = ni++;
    n[i].s = 1;
    n[i].h = 1;
    n[i].d = d;
    return i;
  }
  static void fix(node_index i) {
    n[i].s = n[i][0].s + n[i][1].s;
    n[i].h = std::max(n[i][0].h, n[i][1].h) + 1;
    n[i].d = diff::ope(n[i][0].d, n[i][1].d);
  }

  static size_type child_dir(node_index i) {
    if(n[i].p) {
      if(n[n[i].p].c[0] == i) { return 0; }
      else if(n[n[i].p].c[1] == i) { return 1; }
      assert(false);
    }
    return -1;
  }
  static node_index rotate(node_index x, size_type dir) {
    node_index p = n[x].p;
    size_type x_dir = child_dir(x);
    node_index y = n[x].c[1 ^ dir];
    n[n[y][dir].p = x].c[1 ^ dir] = n[y].c[dir];
    n[n[x].p = y].c[dir] = x;
    n[y].p = p;
    if(p &gt; 0) n[p].c[x_dir] = y;
    fix(x);
    fix(y);
    return y;
  }

  static node_index balance(node_index i) {
    fix(i);
    if(n[i][0].h - n[i][1].h == 2) {
      if(n[i][0][0].h - n[i][0][1].h == -1) {
        rotate(n[i].c[0], 0);
      }
      return rotate(i, 1);
    }
    else if(n[i][0].h - n[i][1].h == -2) {
      if(n[i][1][0].h - n[i][1][1].h == 1) {
        rotate(n[i].c[1], 1);
      }
      return rotate(i, 0);
    }
    return i;
  }


  static node_index merge_dir(node_index l, node_index root, node_index r, size_type dir) {
    while(std::abs(n[l].h - n[r].h) &gt; 1) {
      l = n[l].c[dir];
    }
    node_index x = n[l].p;
    n[n[l].p = root].c[dir ^ 1] = l;
    n[n[r].p = root].c[dir] = r;
    fix(root);
    n[n[root].p = x].c[dir] = root;
    x = root;
    while(n[x].p &gt; 0) {
      x = n[x].p;
      x = balance(x);
    }
    return x;
  }

  static node_index merge(node_index l, node_index r) {
    if(!l) return r;
    else if(!r) return l;
    else if(n[l].h &gt;= n[r].h) {
      return merge_dir(l, new_node(diff()), r, 1);
    }
    else {
      return merge_dir(r, new_node(diff()), l, 0);
    }
  }

  static std::pair&lt;node_index, node_index&gt; split(node_index root, size_type pos) {
    if(pos == 0) return { 0, root };
    if(pos == n[root].s) return { root, 0 };
    node_index i = root;
    node_index par = -1;
    while(i &gt; 0 &amp;&amp; pos != n[i][0].s) {
      if(pos &lt; n[i][0].s) {
        i = n[i].c[0];
      }
      else {
        pos -= n[i][0].s;
        i = n[i].c[1];
      }
    }
    node_index l = n[i].c[0];
    n[l].p = 0;
    node_index r = n[i].c[1];
    n[r].p = 0;
    size_type dir;
    node_index p = n[i].p;
    node_index pd = child_dir(i);
    while(dir = pd, i = p, i &gt; 0) {
      //std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; dir &lt;&lt; std::endl;
      pd = child_dir(i);
      p = n[i].p;
      n[i].p = 0;
      if(dir == 0) {
        n[i][1].p = 0;
        //std::cout &lt;&lt; &quot;merge_dir, 0&quot; &lt;&lt; std::endl;
        //debug(n[i].c[1], &quot;&quot;);
        //debug(r, &quot;&quot;);
        r = merge_dir(n[i].c[1], i, r, 0);
        //debug(r, &quot;&quot;);
      }
      else {
        n[i][0].p = 0;
        //std::cout &lt;&lt; &quot;merge_dir, 0&quot; &lt;&lt; std::endl;
        //debug(n[i].c[0], &quot;&quot;);
        //debug(l, &quot;&quot;);
        l = merge_dir(n[i].c[0], i, l, 1);
        //debug(l, &quot;&quot;);
      }
    }
    return { l, r };
  }

  static node_index at(node_index i, size_type pos) {
    while(n[i].c[0]) {
      if(pos &lt; n[i][0].s) {
        i = n[i].c[0];
      }
      else {
        pos -= n[i][0].s;
        i = n[i].c[1];
      }
    }
    return i;
  }

  static void set(node_index i, size_type pos, diff v) {
    node_index par = -1;
    while(n[i].c[0]) {
      if(pos &lt; n[i][0].s) {
        i = n[i].c[0];
      }
      else {
        pos -= n[i][0].s;
        i = n[i].c[1];
      }
    }
    n[i].d = v;

    while(i = n[i].p, i &gt; 0) {
      fix(i);
    }
  }

  static size_type index(node_index i) {
    size_type pos = 0;
    while(n[i].p &gt; 0) {
      if(child_dir(i) == 1) {
        pos += n[n[i].p][0].s;
      }
      i = n[i].p;
    }
    return pos;
  }

  static node_index search(node_index i, height_type pos) {
    while(n[i].c[0]) {
      if(n[i][0].d.d + n[i][1].d.min_d &lt;= pos &amp;&amp; pos &lt; n[i][0].d.d + n[i][1].d.max_d) {
        pos -= n[i][0].d.d;
        i = n[i].c[1];
      }
      else {
        i = n[i].c[0];
      }
    }
    return i;
  }

  static std::pair&lt;node_index, node_index&gt; min_depth_split(node_index i) {
    node_index r = i;
    size_type pos = n[i].d.min_d;
    size_type res = 0;
    while(n[i].c[0]) {
      if(n[i][0].d.d + n[i][1].d.min_d &lt;= pos &amp;&amp; pos &lt; n[i][0].d.d + n[i][1].d.max_d) {
        pos -= n[i][0].d.d;
        res += n[i][0].s;
        i = n[i].c[1];
      }
      else {
        i = n[i].c[0];
      }
    }
    return split(r, res);
  }

  static void debug(node_index i, std::string s) {
    if(i == 0) {
      std::cout &lt;&lt; s &lt;&lt; 0 &lt;&lt; std::endl;
      return;
    }
    std::cout &lt;&lt; s &lt;&lt; i &lt;&lt; &quot; = &quot; &lt;&lt; n[i].d.p_value &lt;&lt; &quot; = &quot; &lt;&lt; n[i].p &lt;&lt; &quot; = &quot; &lt;&lt; n[i].s &lt;&lt; std::endl;
    if(n[i].c[0] &amp;&amp; n[i][0].p != i) {
      assert(false);
    }
    debug(n[i].c[0], s + &quot;  &quot;);
    if(n[i].c[1] &amp;&amp; n[i][1].p != i) {
      assert(false);
    }
    debug(n[i].c[1], s + &quot;  &quot;);
  }


public:

  node_index root;
  retroactive_stack(): root(0) {}
  retroactive_stack(node_index i): root(i) {}

  static node_index new_push_operation(value_type val) {
    return new_node(diff::push_diff(val));
  }
  static node_index new_pop_operation() {
    return new_node(diff::pop_diff());
  }

  retroactive_stack&amp; merge(retroactive_stack right) {
    root = merge(this-&gt;root, right.root);
    return *this;
  }
  retroactive_stack split(node_index i) {
    auto p = split(root, index(i));
    retroactive_stack avl;
    avl.root = p.second;
    root = p.first;
    return avl;
  }

  void update(node_index i, diff v) {
    set(root, index(i), v);
  }

  size_type operation_size() {
    return n[root].s;
  }

  height_type stack_size() {
    return n[root].d.d;
  }

  value_type top() {
    auto P = min_depth_split(root);
    auto res = n[search(P.second, n[P.second].d.d - 1)].d.p_value;
    root = merge(P.first, P.second);
    return res;
  }

  void debug() {
    debug(root, &quot;&quot;);
  }
};

retroactive_stack::size_type retroactive_stack::ni = 1;
retroactive_stack::node retroactive_stack::n[2020202];

#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;
#define rep(i,s,e) for(i64 (i) = (s);(i) &lt; (e);(i)++)
#define all(x) x.begin(),x.end()

template&lt;class T&gt;
static inline std::vector&lt;T&gt; ndvec(size_t&amp;&amp; n, T val) noexcept {
  return std::vector&lt;T&gt;(n, std::forward&lt;T&gt;(val));
}

template&lt;class... Tail&gt;
static inline auto ndvec(size_t&amp;&amp; n, Tail&amp;&amp;... tail) noexcept {
  return std::vector&lt;decltype(ndvec(std::forward&lt;Tail&gt;(tail)...))&gt;(n, ndvec(std::forward&lt;Tail&gt;(tail)...));
}

template&lt;class T, class Cond&gt;
struct chain {
  Cond cond; chain(Cond cond) : cond(cond) {}
  bool operator()(T&amp; a, const T&amp; b) const {
    if(cond(a, b)) { a = b; return true; }
    return false;
  }
};
template&lt;class T, class Cond&gt;
chain&lt;T, Cond&gt; make_chain(Cond cond) { return chain&lt;T, Cond&gt;(cond); }

int main() {
  std::vector&lt;int&gt; opes;
  opes.push_back(retroactive_stack::new_push_operation(1));
  opes.push_back(retroactive_stack::new_push_operation(2));
  opes.push_back(retroactive_stack::new_push_operation(3));

  retroactive_stack st;

  st.merge(retroactive_stack::new_pop_operation());
  st.merge(retroactive_stack::new_pop_operation());
  st.merge(retroactive_stack::new_pop_operation());

  for(auto i: opes) {
    st.merge(retroactive_stack(i));
  }
  std::cout &lt;&lt; st.top() &lt;&lt; std::endl; // 3

  int pop_ope = retroactive_stack::new_pop_operation();

  st.merge(retroactive_stack(pop_ope));

  std::cout &lt;&lt; st.top() &lt;&lt; std::endl; // 2

  st.merge(retroactive_stack(retroactive_stack::new_pop_operation()));
  std::cout &lt;&lt; st.top() &lt;&lt; std::endl; // 1

  st.update(pop_ope, retroactive_stack::diff::push_diff(4));
  std::cout &lt;&lt; st.top() &lt;&lt; std::endl; // 3 (push 1 -&gt; push 2 -&gt; push 3 -&gt; push 4 -&gt; pop)

  auto after = st.split(opes[2]);
  std::cout &lt;&lt; st.top() &lt;&lt; std::endl; // 2 st := (push 1 -&gt; push 2)
}
</code></pre>
<h1><a class="header" href="#hash-map" id="hash-map">Hash Map</a></h1>
<h3><a class="header" href="#code-30" id="code-30">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;set&gt;
#include &lt;iostream&gt;

template&lt;class Key, class Value, class Hash&gt;
struct hash_map {
  using size_type = std::size_t;
  using key_type = Key;
  using value_type = Value;
  using pair_type = std::pair&lt;key_type, value_type&gt;;

  enum class State: std::uint8_t {
    INACTIVE,
    ACTIVE,
    FILLED
  };

  Hash hashf;

  std::vector&lt;State&gt; st;
  std::vector&lt;pair_type&gt; bck;
  size_type mask;
  size_type prode;
  size_type sz;
  size_type min_elem;
  hash_map():
    mask(0), prode(-1), sz(0), min_elem(0) {
  }

  size_type find_empty(const key_type&amp; key) {
    size_type h = hashf(key);
    for(size_type delta = 0;;delta++) {
      size_type i = (h + delta) &amp; mask;
      if(st[i] != State::FILLED) {
        if(prode &lt; delta) prode = delta;
        return i;
      }
    }
  }

  size_type find_filled(const key_type&amp; key) {
    if(sz == 0) return size_type(-1);
    size_type h = hashf(key);
    for(size_type delta = 0; delta &lt;= prode; delta++) {
      size_type i = (h + delta) &amp; mask;
      if(st[i] == State::FILLED) {
        if(bck[i].first == key) {
          return i;
        }
      }
      else if(st[i] == State::INACTIVE) {
        return size_type(-1);
      }
    }
    return size_type(-1);
  }

  size_type find_or_allocate(const key_type&amp; key) {
    size_type h = hashf(key);
    size_type hole = size_type(-1);
    size_type delta = 0;
    for(; delta &lt;= prode; delta++) {
      size_type i = (h + delta) &amp; mask;
      if(st[i] == State::FILLED) {
        if(bck[i].first == key) return i;
      }
      else if(st[i] == State::INACTIVE) return i;
      else {
        if(hole == size_type(-1)) {
          hole = i;
        }
      }
    }
    if(hole != size_type(-1)) return hole;
    for(; ; delta++) {
      size_type i = (h + delta) &amp; mask;
      if(st[i] != State::FILLED) {
        prode = delta;
        return i;
      }
    }
  }

  void reserve(int next_cnt) {
    size_type required_cnt = next_cnt + (next_cnt &gt;&gt; 1) + 1;
    if(required_cnt &gt; bck.size()) {
      next_cnt = 4;
      while(next_cnt &lt; required_cnt) next_cnt &lt;&lt;= 1;
    }
    else if(next_cnt &lt;= bck.size() / 4) {
      next_cnt = std::max(4, (int)bck.size() / 2);
    }
    else {
      return;
    }
    std::vector&lt;State&gt; old_st(next_cnt, State::INACTIVE);
    std::vector&lt;pair_type&gt; old_bck(next_cnt);

    std::swap(old_st, st);
    std::swap(old_bck, bck);
    mask = next_cnt - 1;
    sz = 0;
    prode = 0;
    min_elem = next_cnt - 1;


    for(size_type pos = 0; pos &lt; old_bck.size(); pos++) {
      if(old_st[pos] == State::FILLED) {
        size_type i = find_empty(old_bck[pos].first);
        st[i] = State::FILLED;
        bck[i] = std::move(old_bck[pos]);
        min_elem = std::min(min_elem, i);
        sz += 1;
      }
    }
  }

  void insert(const key_type&amp; key, const value_type&amp; val) {
    reserve(sz + 1);
    size_type i = find_or_allocate(key);
    if(st[i] != State::FILLED) {
      st[i] = State::FILLED;
      bck[i] = pair_type(key, val);
      min_elem = std::min(min_elem, i);
      sz++;
    }
    else {
      bck[i] = pair_type(key, val);
    }
  }

  bool erase(const key_type&amp; key) {
    size_type i = find_filled(key);
    if(i == size_type(-1)) {
      return false;
    }
    else {
      st[i] = State::ACTIVE;
      bck[i].~pair_type();
      sz--;
      return true;
    }
  }

  pair_type* get(const key_type&amp; key) {
    size_type i = find_filled(key);
    if(i == size_type(-1)) {
      return nullptr;
    }
    else {
      return &amp;bck[i];
    }
  }

  pair_type* get_or_insert(const key_type&amp; key, const value_type val) {
    reserve(sz + 1);
    size_type i = find_or_allocate(key);
    if(st[i] != State::FILLED) {
      st[i] = State::FILLED;
      bck[i] = pair_type(key, val);
      min_elem = std::min(min_elem, i);
      sz++;
    }
    return &amp;bck[i];
  }

  pair_type get_and_erase(const key_type&amp; key) {
    size_type i = find_filled(key);
    st[i] = State::ACTIVE;
    pair_type p = std::move(bck[i]);
    sz--;
    return p;
  }


  template&lt;class Func&gt;
  void search_all(Func func) {
    for(size_type i = min_elem; i &lt; bck.size(); i++) {
      if(st[i] == State::FILLED) {
        min_elem = i;
        size_type res = func(bck[i]);
        if(res &amp; 0b10) {
          st[i] = State::ACTIVE;
          bck[i].~pair_type();
          sz--;
        }
        if(res &amp; 0b01) {
           return;
        }
      }
    }
  }

  size_type size() const { return sz; }
};


struct Hashu32 {
  std::uint32_t operator()(std::uint32_t key) {
    int c2=0x27d4eb2d; // a prime or an odd constant
    key = (key ^ 61) ^ (key &gt;&gt; 16);
    key = key + (key &lt;&lt; 3);
    key = key ^ (key &gt;&gt; 4);
    key = key * c2;
    key = key ^ (key &gt;&gt; 15);
    return key;
  }
};

struct Hashu64 {
  std::size_t operator()(std::uint64_t key) {
    key = (~key) + (key &lt;&lt; 18); // key = (key &lt;&lt; 18) - key - 1;
    key = key ^ (key &gt;&gt; 31);
    key = key * 21; // key = (key + (key &lt;&lt; 2)) + (key &lt;&lt; 4);
    key = key ^ (key &gt;&gt; 11);
    key = key + (key &lt;&lt; 6);
    key = key ^ (key &gt;&gt; 22);
    return (int) key;
  }

};
</code></pre>
<h1><a class="header" href="#data-structures-other" id="data-structures-other">Data Structures Other</a></h1>
<p>うまく分類できなかったもの</p>
<h1><a class="header" href="#swag" id="swag">SWAG</a></h1>
<h3><a class="header" href="#spec-23" id="spec-23">Spec</a></h3>
<h3><a class="header" href="#code-31" id="code-31">Code</a></h3>
<pre><code class="language-cpp">#include &lt;stack&gt;

struct swag {

  using T = int;
  static T ide() {
    return 0;
  }
  static T ope(const T&amp; a, const T&amp; b) {
    return a + b;
  }

  std::stack&lt;T&gt; left_v, right_v, left_f, right_f;

  swag() {
    left_f.push(ide());
    right_f.push(ide());
  }

  void push(T val) {
    left_f.push(ope(left_f.top(), val));
    left_v.push(std::move(val));
  }

  T fold() {
    return ope(right_f.top(), left_f.top());
  }

  void pop() {
    if(right_f.size() == 1) {
      while(left_f.size() &gt; 1) {
        right_f.push(ope(left_v.top(), right_f.top()));
        right_v.push(left_v.top());
        left_f.pop();
        left_v.pop();
      }
    }
    right_f.pop();
    right_v.pop();
  }
};
</code></pre>
<h1><a class="header" href="#fenwick-tree" id="fenwick-tree">Fenwick Tree</a></h1>
<h3><a class="header" href="#spec-24" id="spec-24">Spec</a></h3>
<h3><a class="header" href="#code-32" id="code-32">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
using i64 = long long;

template&lt;class AbelianMonoid, class Ope, const AbelianMonoid&amp; Ide&gt;
struct fenwick_tree {
  using value_type = AbelianMonoid;

  i64 n;
  std::vector&lt;value_type&gt; node;
  Ope ope;

  fenwick_tree(i64 n_): n(n_), node(n + 1, Ide) {}
  fenwick_tree(const std::vector&lt;value_type&gt;&amp; init): n(init.size()), node(n + 1, Ide) {
    for(i64 i = 0;i &lt; init.size(); i++) node[i + 1] = init[i];
    for(i64 i = 1;i &lt; n;i++) node[i + (i &amp; -i)] = ope(node[i + (i &amp; -i)], node[i]);
  }
  void modify(i64 i, value_type x) {
    i++;
    while(i &lt;= n) {
      node[i] = ope(node[i], x);
      i += (i &amp; -i);
    }
  }
  // [0, i)
  value_type sum(i64 i) const {
    value_type ret = Ide;
    while(i &gt; 0) {
      ret = ope(ret, node[i]);
      i -= i &amp; (-i);
    }
    return ret;
  }
};
</code></pre>
<h1><a class="header" href="#online-dynamic-connectivity" id="online-dynamic-connectivity">Online Dynamic Connectivity</a></h1>
<h3><a class="header" href="#code-33" id="code-33">Code</a></h3>
<pre><code class="language-cpp">#include &lt;cstdint&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;cassert&gt;

const int NODE_SIZE = 303030 * 6;
struct euler_tour_tree {
  using value_type = long long;
  using size_type = std::size_t;
  using node_index = std::int_least32_t;
  using vertex_index = std::int_least32_t;

  struct node;
  static struct node n[NODE_SIZE];
  static node_index ni;

  struct node {
    vertex_index s, d;
    node_index c[3];
    int sz;
    int flag;
    value_type val;
    value_type Sigma;
    node(): sz(1) {}
    inline node&amp; operator[](size_type d) { return n[c[d]]; }
  };

  node_index new_edge(int s, int d, bool hi) {
    int i = ni++;
    int ri = ni++;
    n[i].s = n[ri].d = s;
    n[i].d = n[ri].s = d;
    n[i].sz = n[ri].sz = 0;
    n[i].flag = hi;
    return i;
  }

  static void fix(node_index i) {
    n[i].sz = (n[i].s == n[i].d) ? 1 : 0;
    if(n[i].c[0]) n[i].sz += n[i][0].sz;
    if(n[i].c[1]) n[i].sz += n[i][1].sz;
    n[i].flag &amp;= 0b0101;
    n[i].flag |= n[i].flag &lt;&lt; 1;
    if(n[i].c[0]) n[i].flag |= n[i][0].flag &amp; 0b1010;
    if(n[i].c[1]) n[i].flag |= n[i][1].flag &amp; 0b1010;
    n[i].Sigma = n[i].val;
    if(n[i].c[0]) n[i].Sigma += n[i][0].Sigma;
    if(n[i].c[1]) n[i].Sigma += n[i][1].Sigma;
  }

  static int child_dir(node_index i) {
    if(n[i].c[2]) {
      if(n[i][2].c[0] == i) { return 0; }
      else if(n[i][2].c[1] == i) { return 1; }
    }
    return 2;
  }

  static void rotate(node_index x, size_type dir) {
    node_index p = n[x].c[2];
    int x_dir = child_dir(x);
    node_index y = n[x].c[dir ^ 1];
    if(n[y].c[dir]) n[y][dir].c[2] = x;
    n[x].c[dir ^ 1] = n[y].c[dir];
    n[n[x].c[2] = y].c[dir] = x;
    n[y].c[2] = p;
    if(x_dir &lt; 2) n[p].c[x_dir] = y;
    if(n[x].c[dir ^ 1]) fix(n[x].c[dir ^ 1]);
    fix(x);
  }

  static void splay(node_index i) {
    int i_dir;
    int j_dir;
    while((i_dir = child_dir(i)) &lt; 2) {
      node_index j = n[i].c[2];
      if((j_dir = child_dir(j)) &lt; 2) {
        node_index k = n[j].c[2];
        if(i_dir == j_dir) rotate(k, j_dir ^ 1), rotate(j, i_dir ^ 1);
        else rotate(j, i_dir ^ 1), rotate(k, j_dir ^ 1);
      }
      else rotate(j, i_dir ^ 1);
    }
    fix(i);
  }

  static node_index merge_back(node_index l, node_index r) {
    if(!l) return r;
    if(!r) return l;
    while(n[l].c[1]) l = n[l].c[1];
    splay(l);
    n[n[r].c[2] = l].c[1] = r;
    fix(l);
    return l;
  }

  static std::pair&lt;node_index, node_index&gt; split(node_index i) {
    splay(i);
    node_index l = n[i].c[0];
    n[i].c[0] = n[l].c[2] = 0;
    fix(i);
    return { l, i };
  }

  static void reroot(node_index v) {
    auto p = split(v);
    merge_back(p.second, p.first);
    splay(v);
  }

  static bool same_root(node_index i, node_index j) {
    if(i) splay(i);
    if(j) splay(j);
    while(n[i].c[2]) i = n[i].c[2];
    while(n[j].c[2]) j = n[j].c[2];
    return i == j;
  }

  node_index n_start;
  std::unordered_map&lt;long long, node_index&gt; emp;
  euler_tour_tree() {}
  euler_tour_tree(int N): n_start(ni) {
    ni += N;
    for(int i = 0; i &lt; N; i++) {
      n[i + n_start].s = n[i + n_start].d = i;
    }
  }

  bool edge_exist(vertex_index x, vertex_index y) {
    if(x &gt; y) std::swap(x, y);
    return emp.count(((long long)x &lt;&lt; 32) | (long long)y);
  }

  void link(vertex_index x, vertex_index y, bool hi) {
    if(x &gt; y) std::swap(x, y);
    int ei = new_edge(x, y, hi);
    assert(!emp.count(((long long)x &lt;&lt; 32) | (long long)y));
    emp[((long long)x &lt;&lt; 32) | (long long)y] = ei;
    x += n_start;
    y += n_start;
    reroot(x);
    reroot(y);
    n[n[x].c[2] = ei].c[0] = x;
    n[n[y].c[2] = ei].c[1] = y;
    fix(ei);
    merge_back(ei, ei + 1);
  }

  void cut(vertex_index x, vertex_index y) {
    if(x &gt; y) std::swap(x, y);
    auto iter = emp.find(((long long)x &lt;&lt; 32) | (long long)y);
    int ei = iter-&gt;second;
    int rei = ei + 1;
    emp.erase(iter);

    auto p = split(ei);
    if(p.first &amp;&amp; same_root(p.first, rei)) {
      auto q = split(rei);
      node_index left = q.first;
      node_index center = n[q.second].c[1];
      node_index right = n[p.second].c[1];
      n[center].c[2] = 0;
      n[right].c[2] = 0;
      merge_back(left, right);
    }
    else {
      splay(ei);
      ei = n[ei].c[1];
      n[ei].c[2] = 0;
      auto q = split(rei);
      splay(p.first);
      node_index left = p.first;
      node_index center = q.first;
      node_index right = n[q.second].c[1];
      n[right].c[2] = 0;
      merge_back(left, right);
    }
  }

  bool same_tree(vertex_index x, vertex_index y) {
    return same_root(x + n_start, y + n_start);
  }

  int tree_size(vertex_index x) {
    x += n_start;
    splay(x);
    return n[x].sz;
  }

  void subedge_set(vertex_index x, bool val) {
    x += n_start;
    splay(x);
    if(val) n[x].flag |= (0b0100);
    else n[x].flag &amp;= ~(0b0100);
    fix(x);
  }

  void add_val(vertex_index x, value_type val) {
    x += n_start;
    splay(x);
    n[x].val += val;
    fix(x);
  }
  value_type tree_sum(vertex_index x) {
    x += n_start;
    splay(x);
    return n[x].Sigma;
  }

  template&lt;class Func&gt;
  void hilevel_edges(vertex_index v, Func f) {
    node_index i = v + n_start;
    splay(i);
    while(i &amp;&amp; (n[i].flag &amp; 0b0010)) {
      while(1) {
        if(n[i].flag &amp; 0b0001) {
          f(n[i].s, n[i].d);
          splay(i);
          n[i].flag &amp;= ~(0b0001);
          fix(i);
          break;
        }
        else if(n[i].c[0] &amp;&amp; (n[i][0].flag &amp; 0b0010)) i = n[i].c[0];
        else i = n[i].c[1];
      }
    }
  }
  template&lt;class Func&gt;
  int subedges(vertex_index v, Func f) {
    node_index i = v + n_start;
    splay(i);
    while(i &amp;&amp; (n[i].flag &amp; 0b1000)) {
      while(1) {
        if(n[i].flag &amp; 0b0100) {
          if(f(n[i].s)) {
            return 1;
          }
          splay(i);
          break;
        }
        else if(n[i].c[0] &amp;&amp; (n[i][0].flag &amp; 0b1000)) i = n[i].c[0];
        else i = n[i].c[1];
      }
    }
    return 0;
  }


  void debug_tree(node_index i, std::string indent) {
    if(n[i].c[0]) {
      debug_tree(n[i].c[0], indent + &quot;l&quot;);
    }
    std::cout &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; = (&quot; &lt;&lt; n[i].s &lt;&lt; &quot; &quot; &lt;&lt; n[i].d &lt;&lt; &quot;)&quot; &lt;&lt; &quot; p &quot; &lt;&lt; n[i].c[2] &lt;&lt; std::endl;
    if(n[i].c[1]) {
      debug_tree(n[i].c[1], indent + &quot;r&quot;);
    }
  }
};

euler_tour_tree::node_index euler_tour_tree::ni = 1;
euler_tour_tree::node euler_tour_tree::n[NODE_SIZE];

struct online_dynamic_connectivity {
  int N;
  std::vector&lt;euler_tour_tree&gt; ett;
  std::vector&lt;std::vector&lt;std::unordered_set&lt;int&gt;&gt;&gt; E;

  online_dynamic_connectivity(int N): N(N) {
    ett.emplace_back(N);
    E.emplace_back(N);
  }

  void link(int x, int y) {
    if(ett[0].same_tree(x, y)) {
      if(E[0][x].size() == 0) ett[0].subedge_set(x, 1);
      if(E[0][y].size() == 0) ett[0].subedge_set(y, 1);
      E[0][x].insert(y);
      E[0][y].insert(x);
    }
    else {
      ett[0].link(x, y, true);
    }
  }

  void replace(int x, int y, int level) {
    for(int k = 0; k &lt; level; k++) {
      ett[k].cut(x, y);
    }
    for(int k = level; k --&gt; 0;) {
      if(ett[k].tree_size(x) &gt; ett[k].tree_size(y)) std::swap(x, y);
      ett[k].hilevel_edges(x, [&amp;](int s, int d) { ett[k + 1].link(s, d, true); });
      int res = ett[k].subedges(x, [&amp;](int s) {
        for(auto iter = E[k][s].begin(); iter != E[k][s].end(); ) {
          int d = *iter;
          iter = E[k][s].erase(iter);
          E[k][d].erase(s);
          if(E[k][s].size() == 0) ett[k].subedge_set(s, 0);
          if(E[k][d].size() == 0) ett[k].subedge_set(d, 0);
          if(ett[k].same_tree(s, d)) {
            if(E[k + 1][s].size() == 0) ett[k + 1].subedge_set(s, 1);
            if(E[k + 1][d].size() == 0) ett[k + 1].subedge_set(d, 1);
            E[k + 1][s].insert(d);
            E[k + 1][d].insert(s);
          }
          else {
            for(int kk = k + 1; kk --&gt; 0;) {
              ett[kk].link(s, d, kk == k);
            }
            return 1;
          }
        }
        return 0;
        });
      if(res) return;
    }
  }

  void cut(int x, int y) {
    for(int k = 0; k &lt; ett.size(); k++) {
      if(E[k][x].count(y)) {
        E[k][x].erase(y);
        E[k][y].erase(x);
        if(E[k][x].size() == 0) ett[k].subedge_set(x, 0);
        if(E[k][y].size() == 0) ett[k].subedge_set(y, 0);
        return;
      }
    }
    for(int k = ett.size(); k --&gt; 0;) {
      if(ett[k].edge_exist(x, y)) {
        if(k + 1 == ett.size()) {
          ett.emplace_back(N);
          E.emplace_back(N);
        }
        replace(x, y, k + 1);
      }
    }
  }
  void add_val(int x, long long val) {
    ett[0].add_val(x, val);
  }
  int size(int x) {
    return ett[0].tree_size(x);
  }
  long long sum(int x) {
    return ett[0].tree_sum(x);
  }
  bool same(int x, int y) {
    return ett[0].same_tree(x, y);
  }
};

</code></pre>
<h1><a class="header" href="#math" id="math">Math</a></h1>
<p>数学系を</p>
<ul>
<li><a href="math/./modint.html">modint</a></li>
<li><a href="math/./matrix.html">Matrix</a> \</li>
<li><a href="math/./garner.html">Garner's Algorithm</a></li>
<li><a href="math/./polynomial.html">Polynomial</a> \</li>
<li><a href="math/./runtime_fp.html">Runtime fp</a> \</li>
</ul>
<h1><a class="header" href="#modint" id="modint">modint</a></h1>
<p>xxで割ったあまりを求めよで使える構造体</p>
<h3><a class="header" href="#spec-25" id="spec-25">Spec</a></h3>
<ul>
<li>
<p>template</p>
<ul>
<li><code>i64 M</code>
<ul>
<li>\( \mod M \)の剰余環</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>modint(const i64 x = 0)</code></p>
<ul>
<li>\( x \mod M \)で初期化</li>
</ul>
</li>
<li>
<p><code>value()</code></p>
<ul>
<li>\( x \mod M \)を返す</li>
</ul>
</li>
<li>
<p><code>pow(i64 r)</code></p>
<ul>
<li>\( x^r \mod M \)を返す</li>
</ul>
</li>
<li>
<p><code>+, -, *, /</code></p>
</li>
</ul>
<h3><a class="header" href="#code-34" id="code-34">Code</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using i64 = long long;
template&lt;i64 M&gt; struct modint { i64 a;
  constexpr modint(const i64 x = 0): a((x%M+M)%M){}
  constexpr i64 value() const { return a; }
  constexpr modint inv() const { return this-&gt;pow(M-2); }
  constexpr modint pow(i64 r) const {
    modint ans(1); modint aa = *this;
    while(r) { if(r &amp; 1) ans *= aa; aa *= aa; r &gt;&gt;= 1; }
    return ans;
  }
  constexpr modint&amp; operator=(const i64 r) { a = (r % M + M) % M; return *this; }
  constexpr modint&amp; operator+=(const modint r) { a += r.a; if(a &gt;= M) a -= M; return *this; }
  constexpr modint&amp; operator-=(const modint r) { a -= r.a; if(a &lt; 0) a += M; return *this; }
  constexpr modint&amp; operator*=(const modint r) { a = a * r.a % M; return *this; }
  constexpr modint&amp; operator/=(const modint r) { (*this) *= r.inv(); return *this; }
  constexpr modint operator+(const modint r) const { return modint(*this) += r; }
  constexpr modint operator-(const modint r) const { return modint(*this) -= r; }
  constexpr modint operator*(const modint r) const { return modint(*this) *= r; }
  constexpr modint operator/(const modint r) const { return modint(*this) /= r; }
  constexpr bool operator!=(const modint r) const { return this-&gt;value() != r.value(); }
};

template&lt;const i64 M&gt; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const modint&lt;M&gt;&amp; m) { os &lt;&lt; m.value(); return os; }

</code></pre>
<h1><a class="header" href="#matrix" id="matrix">Matrix</a></h1>
<p>行列演算</p>
<h3><a class="header" href="#code-35" id="code-35">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;
#define rep(i,s,e) for(i64 (i) = (s);(i) &lt; (e);(i)++)
#define rev(i,s,e) for(i64 (i) = (s);(i) --&gt; (e);)
#define all(x) x.begin(),x.end()
 
template&lt;class T, const i64 N, const i64 M&gt;
struct matrix {
  vector&lt;vector&lt;T&gt;&gt; mat;
  matrix(T init = T()): mat(N, vector&lt;T&gt;(M, init)) {}
  vector&lt;T&gt;&amp; operator[](i64 i) { return mat[i]; }
  const vector&lt;T&gt;&amp; operator[](i64 i) const { return mat[i]; }
  static matrix&lt;T, N, N&gt; E() {
    matrix&lt;T, N, N&gt; mat(0);
    rep(i,0,N) mat[i][i] = 1;
    return mat;
  }
};
template&lt;class T, const i64 L, const i64 M, const i64 N&gt;
matrix&lt;T, L, N&gt; operator*(const matrix&lt;T, L, M&gt;&amp; lm, const matrix&lt;T, M, N&gt;&amp; rm) {
  matrix&lt;T, L, N&gt; ret;
  rep(i, 0, L) rep(j, 0, M) rep(k, 0, N) (ret[i][k] += lm[i][j] * rm[j][k]);
  return ret;
}
 
template&lt;class T, const i64 N&gt;
matrix&lt;T, N, N&gt; matrix_pow(matrix&lt;T, N, N&gt; mat, i64 r) {
  matrix&lt;T, N, N&gt; ret = matrix&lt;T, N, N&gt;::E();
  while(r &gt; 0) {
    if(r &amp; 1) ret = ret * mat;
    mat = mat * mat;
    r &gt;&gt;= 1;
  }
  return ret;
}
</code></pre>
<h1><a class="header" href="#garners-algorithm" id="garners-algorithm">Garner's Algorithm</a></h1>
<p>FPSで使う</p>
<h3><a class="header" href="#spec-26" id="spec-26">Spec</a></h3>
<p>\(m_0, \cdots, m_{k-1} \)が互いに素とする.<br />
\( x &lt; \prod{m_i} \)を満たす\( x \)について, \( x \mod m_i \)がわかっている時,<br />
\( O(k^2 + k \log m) \)で \( x \mod M \) を求めることができる.</p>
<h3><a class="header" href="#code-36" id="code-36">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

i64 pow_mod(i64 x, i64 r, i64 mod) {
  i64 ans = 1;
  while(r) {
    if(r &amp; 1) ans = (ans * x) % mod;
    r &gt;&gt;= 1;
    x = x * x % mod;
  }
  return ans;
}

i64 inv_mod(i64 x, i64 mod) {
  return pow_mod(x, mod - 2, mod);
}

i64 garner(const vector&lt;i64&gt; &amp;x, vector&lt;i64&gt; mods, i64 mod) {
  mods.emplace_back(mod);
  vector&lt;i64&gt; coeffs(x.size() + 1, 1);
  vector&lt;i64&gt; constants(x.size() + 1, 0);
  for(i64 i = 0; i &lt; x.size(); i++) {
    i64 v = (x[i] - constants[i]) * inv_mod(coeffs[i], mods[i]) % mods[i];
    if(v &lt; 0) v += mods[i];
    for(i64 j = i + 1; j &lt; x.size() + 1; j++) {
      constants[j] = (constants[j] + coeffs[j] * v) % mods[j];
      coeffs[j] = (coeffs[j] * mods[i]) % mods[j];
    }
  }
  return constants.back();
}
</code></pre>
<h1><a class="header" href="#formal-power-series" id="formal-power-series">Formal Power Series</a></h1>
<h2><a class="header" href="#code-37" id="code-37">Code</a></h2>
<p>#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;</p>
<p>template<i64 M>
struct modint {
i64 a;
constexpr modint(const i64 x = 0) noexcept: a((x % M + M) % M) {}
constexpr i64 value() const noexcept { return a; }
constexpr modint pow(i64 r) const noexcept {
modint ans(1);
modint aa = *this;
while(r) {
if(r &amp; 1) {
ans *= aa;
}
aa *= aa;
r &gt;&gt;= 1;
}
return ans;
}
constexpr modint&amp; operator+=(const modint r) noexcept {
a += r.a;
if(a &gt;= M) a -= M;
return *this;
}
constexpr modint&amp; operator=(const i64 r) {
a = (r % M + M) % M;
return *this;
}
constexpr modint&amp; operator-=(const modint r) noexcept {
a -= r.a;
if(a &lt; 0) a += M;
return <em>this;
}
constexpr modint&amp; operator</em>=(const modint r) noexcept {
a = a * r.a % M;
return *this;
}
constexpr modint&amp; operator/=(modint r) noexcept {
i64 ex = M - 2;
while(ex) {
if(ex &amp; 1) {
*this *= r;
}
r *= r;
ex &gt;&gt;= 1;
}
return *this;
}</p>
<p>constexpr modint operator+(const modint r) const {
return modint(*this) += r;
}
constexpr modint operator-(const modint r) const {
return modint(<em>this) -= r;
}
constexpr modint operator</em>(const modint r) const {
return modint(*this) *= r;
}
constexpr modint operator/(const modint r) const {
return modint(*this) /= r;
}</p>
<p>constexpr bool operator!=(const modint r) const {
return this-&gt;value() != r.value();
}</p>
<p>};</p>
<p>constexpr i64 NTT_PRIMES[][2] = {
{1224736769, 3}, // 2^24 * 73 + 1,
{1053818881, 7}, // 2^20 * 3 * 5 * 67 + 1
{1051721729, 6}, // 2^20 * 17 * 59 + 1
{1045430273, 3}, // 2^20 * 997 + 1
{1012924417, 5}, // 2^21 * 3 * 7 * 23 + 1
{1007681537, 3}, // 2^20 * 31^2 + 1
{1004535809, 3}, // 2^21 * 479 + 1
{998244353, 3},  // 2^23 * 7 * 17 + 1
{985661441, 3},  // 2^22 * 5 * 47 + 1
{976224257, 3},  // 2^20 * 7^2 * 19 + 1
{975175681, 17}, // 2^21 * 3 * 5 * 31 + 1
{962592769, 7},  // 2^21 * 3^3 * 17 + 1
{950009857, 7},  // 2^21 * 4 * 151 + 1
{943718401, 7},  // 2^22 * 3^2 * 5^2 + 1
{935329793, 3},  // 2^22 * 223 + 1
{924844033, 5},  // 2^21 * 3^2 * 7^2 + 1
{469762049, 3},  // 2^26 * 7 + 1
{167772161, 3},  // 2^25 * 5 + 1
};</p>
<p>template&lt;const i64 mod, const i64 primitive&gt;
vector&lt;modint<mod>&gt; number_theoretic_transform(vector&lt;modint<mod>&gt; a) {
i64 n = a.size();
for(i64 s = n &gt;&gt; 1; s &gt;= 1; s &gt;&gt;= 1) {
modint<mod> zeta = modint<mod>(primitive).pow((mod - 1) / (s &lt;&lt; 1));
for(i64 i = 0; i &lt; n; i += (s &lt;&lt; 1)) {
modint<mod> zi = 1;
for(i64 j = 0;j &lt; s;j++) {
modint<mod> t = a[i + j] - a[s + i + j];
a[i + j] += a[s + i + j];
a[s + i + j] = t * zi;
zi = zi * zeta;
}
}
}
return a;
}</p>
<p>template&lt;const i64 mod, const i64 primitive&gt;
vector&lt;modint<mod>&gt; inverse_number_theoretic_transform(vector&lt;modint<mod>&gt; a) {
i64 n = a.size();
for(i64 s = 1; s &lt; n; s &lt;&lt;= 1) {
modint<mod> zeta = modint<mod>(primitive).pow((mod - 1) / (s &lt;&lt; 1)).pow(mod - 2);
for(i64 i = 0; i &lt; n; i += (s &lt;&lt; 1)) {
modint<mod> zi = 1;
for(i64 j = 0;j &lt; s;j++) {
modint<mod> t = a[s + i + j] * zi;
a[s + i + j] = a[i + j] - t;
a[i + j] = a[i + j] + t;
zi = zi * zeta;
}
}
}
auto inv_n = modint<mod>(n).pow(mod - 2);
for(int i = 0;i &lt; n;i++) a[i] *= inv_n;
return a;
}</p>
<p>template&lt;const i64 mod, const i64 primitive&gt;
struct fps_ntt_multiply {
using fps_type = modint<mod>;
using conv_type = modint<mod>;
static std::vector&lt;conv_type&gt; dft(std::vector&lt;fps_type&gt; arr) {
return number_theoretic_transform&lt;mod, primitive&gt;(std::move(arr));
}
static std::vector&lt;fps_type&gt; idft(std::vector&lt;conv_type&gt; arr) {
return inverse_number_theoretic_transform&lt;mod, primitive&gt;(std::move(arr));
}
static std::vector&lt;conv_type&gt; multiply(std::vector&lt;conv_type&gt; a, std::vector&lt;conv_type&gt; b) {
for(int i = 0;i &lt; a.size();i++) a[i] *= b[i];
return a;
}
};</p>
<p>struct FPS {
using T = modint&lt;998244353&gt;;
using fps_multiply = fps_ntt_multiply&lt;998244353, 3&gt;;
std::vector<T> coef;</p>
<p>FPS(const std::vector<T>&amp; arr): coef(arr) {
i64 n = 1;
i64 m = arr.size();
while(n &lt; m) n &lt;&lt;= 1;
coef.resize(n);
}
size_t size() const { return coef.size(); }
T operator[](int i) const {
if(i &lt; coef.size()) return coef[i];
else return T();
}
T &amp; operator[](int i) { return coef[i]; }
FPS pre(int n) const {
std::vector<T> nex(n);
for(int i = 0;i &lt; coef.size() &amp;&amp; i &lt; n; i++) nex[i] = coef[i];
return FPS(nex);
}</p>
<p>// F(0) must not be 0
FPS inv() const {
FPS g = FPS(std::vector<T>{ T(1) / (*this)[0] });
i64 n = this-&gt;size();
for(int i = 1;i &lt; n;i &lt;&lt;= 1) {
g = g.pre(i &lt;&lt; 1);
auto gdft = fps_multiply::dft(g.coef);
auto e = fps_multiply::idft(
fps_multiply::multiply(
fps_multiply::dft(this-&gt;pre(i &lt;&lt; 1).coef), gdft
)
);
for(int j = 0;j &lt; i;j++) {
e[j] = T(0);
e[j + i] = e[j + i] * T(-1);
}
auto f = fps_multiply::idft(
fps_multiply::multiply(
fps_multiply::dft(e), std::move(gdft)
)
);
for(int j = 0;j &lt; i;j++) {
f[j] = g[j];
}
g.coef = std::move(f);
}
return g.pre(n);
}</p>
<p>FPS diff() const {
FPS res(vector<T>(this-&gt;size() - 1, T(0)));
for(i64 i = 1;i &lt; this-&gt;size();i++) res[i - 1] = coef[i] * T(i);
return res;
}</p>
<p>FPS integral() const {
FPS res(vector<T>(this-&gt;size() + 1, T(0)));
for(i64 i = 0;i &lt; this-&gt;size();i++) res[i + 1] = coef[i] / T(i + 1);
return res;
}</p>
<p>// F(0) must be 0
FPS log() const {
return (this-&gt;diff() * this-&gt;inv()).integral().pre(this-&gt;size());
}</p>
<p>FPS exp() const {
FPS f(vector<T>{ T(1) });
FPS g = *this;
g[0] += T(1);
for(i64 i = 1;i &lt; size();i &lt;&lt;= 1 ) {
f = (f * (g.pre(i &lt;&lt; 1) - f.pre(i &lt;&lt; 1).log())).pre(i &lt;&lt; 1);
}
return f;
}</p>
<p>FPS operator+(const FPS&amp; rhs) {
i64 n = std::max(this-&gt;size(), rhs.size());
std::vector<T> ans(n);
for(int i = 0;i &lt; n;i++) ans[i] = (*this)[i] + rhs[i];
return FPS(ans);
}
FPS operator-(const FPS&amp; rhs) {
i64 n = std::max(this-&gt;size(), rhs.size());
std::vector<T> ans(n);
for(int i = 0;i &lt; n;i++) ans[i] = (<em>this)[i] - rhs[i];
return FPS(ans);
}
FPS operator</em>(const FPS&amp; rhs) {
i64 n = std::max(this-&gt;size(), rhs.size()) &lt;&lt; 1;
return fps_multiply::idft(
fps_multiply::multiply(
fps_multiply::dft(this-&gt;pre(n).coef), fps_multiply::dft(rhs.pre(n).coef)
)
);
}</p>
<p>};</p>
<h1><a class="header" href="#runtime-fp" id="runtime-fp">Runtime fp</a></h1>
<h3><a class="header" href="#code-38" id="code-38">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct modint {
  i64 a;
  static i64&amp; M() {
    static i64 mod_ = 2999;
    return mod_;
  }
  modint(const i64 x = 0) noexcept: a((x % M() + M()) % M()) {}
  i64 value() const noexcept { return a; }
  modint&amp; operator=(const i64 r) {
    a = (r % M() + M()) % M();
    return *this;
  }
  modint&amp; operator+=(const modint r) noexcept {
    a += r.a;
    if(a &gt;= M()) a -= M();
    return *this;
  }
  modint&amp; operator-=(const modint r) noexcept {
    a -= r.a;
    if(a &lt; 0) a += M();
    return *this;
  }
  modint&amp; operator*=(const modint r) noexcept {
    a = a * r.a % M();
    return *this;
  }
  modint&amp; operator/=(modint r) noexcept {
    i64 ex = M() - 2;
    while(ex) {
      if(ex &amp; 1) {
        *this *= r;
      }
      r *= r;
      ex &gt;&gt;= 1;
    }
    return *this;
  }

  modint operator+(const modint r) const {
    return modint(*this) += r;
  }
  modint operator-(const modint r) const {
    return modint(*this) -= r;
  }
  modint operator*(const modint r) const {
    return modint(*this) *= r;
  }
  modint operator/(const modint r) const {
    return modint(*this) /= r;
  }
};
</code></pre>
<h1><a class="header" href="#f2x" id="f2x">F2[[x]]</a></h1>
<h3><a class="header" href="#spec-27" id="spec-27">Spec</a></h3>
<p>gcdとか, modとかができます.</p>
<h3><a class="header" href="#code-39" id="code-39">Code</a></h3>
<pre><code class="language-cpp">#include &lt;array&gt;
#include &lt;cstdint&gt;
#include &lt;cassert&gt;


#include &lt;iostream&gt;
#include &lt;bitset&gt;

template&lt;const std::size_t N&gt;
struct binfps {
  using size_type = std::size_t;
  using bit_type = std::uint_fast64_t;

  const static size_type lg = 6;
  const static size_type lgmask = (bit_type(1) &lt;&lt; lg) - 1;
  const static size_type _w_len = (N + (bit_type(1) &lt;&lt; lg) - 1) &gt;&gt; lg;
  std::array&lt;bit_type, _w_len&gt; w;
  size_type len;

  binfps(): len(0) {
    for(size_type i = 0; i &lt; _w_len; i++) {
      w[i] = 0;
    }
  }

  binfps(const std::bitset&lt;N&gt;&amp; b) {
    for(size_type i = 0; i &lt; _w_len; i++) {
      w[i] = 0;
    }
    for(size_type i = 0; i &lt; N; i++) {
      if(b[i]) set(i);
    }
    recalc();
  }

  int size() const { return this-&gt;len; }
  void recalc() {
    len = 0;
    for(size_type i = w.size(); i --&gt; 0; ) {
      if(w[i]) {
        for(size_type j = (1 &lt;&lt; lg); j --&gt; 0;) {
          if(w[i] &gt;&gt; j) {
            len = j + 1 + (i &lt;&lt; lg);
            return;
          }
        }
      }
    }
  }

  void set(size_type i) { w[i &gt;&gt; lg] |= (bit_type(1) &lt;&lt; (i &amp; lgmask)); }
  void unset(size_type i) { w[i &gt;&gt; lg] &amp;= ~(bit_type(1) &lt;&lt; (i &amp; lgmask)); }

  bool any() const {
    for(size_type i = 0; i &lt; _w_len; i++) {
      if(w[i]) {
        return true;
      }
    }
    return false;
  }

  bool operator[](size_type i) const {
    return (w[i &gt;&gt; lg] &gt;&gt; (i &amp; lgmask)) &amp; 1;
  }

  binfps&amp; operator^=(const binfps&amp; b) {
    for(size_type i = w.size(); i --&gt; 0;) {
      w[i] ^= b.w[i];
    }
    return *this;
  }
  binfps&amp; operator&amp;=(const binfps&amp; b) {
    for(size_type i = w.size(); i --&gt; 0;) {
      w[i] &amp;= b.w[i];
    }
    return *this;
  }
  binfps&amp; operator|=(const binfps&amp; b) {
    for(size_type i = w.size(); i --&gt; 0;) {
      w[i] &amp;= b.w[i];
    }
    return *this;
  }


  binfps&amp; operator&lt;&lt;=(size_type x) {
    std::array&lt;bit_type, _w_len&gt; next;
    for(size_type i = 0; i &lt; _w_len; i++) {
      next[i] = 0;
    }
    size_type off = x &gt;&gt; lg;
    size_type m = x &amp; lgmask;
    bit_type dwmask = ((bit_type)(1) &lt;&lt; (64 - m)) - 1;
    if(m == 0) {
      dwmask = ~(bit_type)(0);
    }
    bit_type upmask = ~dwmask;
    // up
    for(size_type i = 0; i + off + 1 &lt; _w_len; i++) {
      next[i + off + 1] |= (w[i] &amp; upmask) &gt;&gt; (64 - m);
    }
    // down
    for(size_type i = 0; i + off &lt; _w_len; i++) {
      next[i + off] |= (w[i] &amp; dwmask) &lt;&lt; m;
    }

    w = std::move(next);
    len = std::min(N, len + x);
    return (*this);
  }

  binfps&amp; operator&gt;&gt;=(size_type x) {
    std::array&lt;bit_type, _w_len&gt; next;
    for(size_type i = 0; i &lt; _w_len; i++) {
      next[i] = 0;
    }
    bit_type off = x &gt;&gt; lg;
    bit_type m = x &amp; lgmask;
    bit_type dwmask = (bit_type(1) &lt;&lt; m) - 1;
    if(m == 0) {
      dwmask = 0;
    }
    bit_type upmask = ~dwmask;
    // down
    for(size_type i = 0; i + off + 1 &lt; _w_len; i++) {
      next[i] |= (w[i + off + 1] &amp; dwmask) &lt;&lt; (64 - m);
    }
    // up
    for(size_type i = 0; i + off &lt; _w_len; i++) {
      next[i] |= (w[i + off] &amp; upmask) &gt;&gt; m;
    }
    w = std::move(next);
    if(len &lt; x) {
      len = 0;
    }
    else {
      len = len - x;
    }
    return (*this);
  }

  binfps operator^(const binfps&amp; b) const { return binfps(*this) ^= b; }
  binfps operator&amp;(const binfps&amp; b) const { return binfps(*this) &amp;= b; }
  binfps operator|(const binfps&amp; b) const { return binfps(*this) |= b; }
  binfps operator&lt;&lt;(const size_type x) const { return binfps(*this) &lt;&lt;= x; }
  binfps operator&gt;&gt;(const size_type x) const { return binfps(*this) &gt;&gt;= x; }
  binfps operator~() {
    binfps a = *this;
    for(size_type i = w.size(); i --&gt; 0;) {
      a.w[i] = ~w[i];
    }
    return a;
  }

  bool operator&lt;(const binfps&amp; b) const {
    bool OK = false;
    for(size_type i = _w_len; i --&gt; 0; ) {
      if(w[i] != b.w[i]) {
        if(w[i] &lt; b.w[i]) {
          OK = true;
        }
        break;
      }
    }
    return OK;
  }
  bool operator&lt;=(const binfps&amp; b) const {
    bool OK = true;
    for(size_type i = _w_len; i --&gt; 0; ) {
      if(w[i] != b.w[i]) {
        if(w[i] &gt; b.w[i]) {
          OK = false;
        }
        break;
      }
    }
    return OK;
  }

  static binfps mod(binfps a, const binfps&amp; b) {
    assert(b.size() &gt; 0);
    for(int i = (int)a.size() - (int)b.size() + 1; i --&gt; 0;) {
      if(a[i + b.size() - 1]) {
        a ^= (b &lt;&lt; i);
      }
    }
    a.recalc();
    return a;
  }

  static binfps div(binfps a, const binfps&amp; b) {
    assert(b.size() &gt; 0);
    binfps d;
    for(int i = (int)a.size() - (int)b.size() + 1; i --&gt; 0;) {
      if(a[i + b.size() - 1]) {
        a ^= (b &lt;&lt; i);

        binfps e;
        e.set(i);
        d ^= e;
      }
    }
    d.recalc();
    return d;
  }

  static binfps gcd(binfps a, binfps b) {
    while(b.any()) {
      auto m = mod(a, b);
      a = std::move(b);
      b = std::move(m);
    }
    return a;
  }

  void dump() const {
    for(size_type i = _w_len; i --&gt; 0; ) {
      std::cerr &lt;&lt; std::bitset&lt;64&gt;(w[i]) &lt;&lt; &quot;|&quot; &lt;&lt; std::endl;
    }
    std::cerr &lt;&lt; std::endl;
  }
};


const int BN = 5000;
using bits = binfps&lt;BN&gt;;

#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;
#define rep(i,s,e) for(i64 (i) = (s);(i) &lt; (e);(i)++)
#define all(x) x.begin(),x.end()

template&lt;class T&gt;
static inline std::vector&lt;T&gt; ndvec(size_t&amp;&amp; n, T val) noexcept {
  return std::vector&lt;T&gt;(n, std::forward&lt;T&gt;(val));
}

template&lt;class... Tail&gt;
static inline auto ndvec(size_t&amp;&amp; n, Tail&amp;&amp;... tail) noexcept {
  return std::vector&lt;decltype(ndvec(std::forward&lt;Tail&gt;(tail)...))&gt;(n, ndvec(std::forward&lt;Tail&gt;(tail)...));
}
 
int main() {
  i64 N;
  cin &gt;&gt; N;
  std::bitset&lt;BN&gt; binp;
  cin &gt;&gt; binp;
  bits X(binp);
  X.recalc();
 
  vector&lt;bits&gt; A(N);
  rep(i,0,N) {
    cin &gt;&gt; binp;
    A[i] = bits(binp);
    A[i].recalc();
  }
  auto G = A[0];
  for(i64 i = 1; i &lt; N; i++) {
    G = bits::gcd(G, A[i]);
  }
  i64 ans = 0;
  const i64 MOD = 998244353;
  if(X.size() - G.size() + 1 &gt;= 0) {
    vector&lt;i64&gt; Bs(X.size() - G.size() + 1, 1);
    for(i64 i = 1; i &lt; X.size() - G.size() + 1; i++) {
      Bs[i] = (Bs[i - 1] * 2) % MOD;
    } 
    bits now;
    for(i64 i = X.size() - G.size() + 1; i --&gt; 0;) {
      if(X[i + G.size() - 1]) {
        ans = (ans + Bs[i]) % MOD;
      }
      if(now[i + G.size() - 1] != X[i + G.size() - 1]) {
        now ^= (G &lt;&lt; i);
      }
    }
    if(now &lt;= X) ans = (ans + 1) % MOD;
  }
  cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>
<h1><a class="header" href="#factorial" id="factorial">factorial</a></h1>
<h2><a class="header" href="#code-40" id="code-40">Code</a></h2>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;tuple&gt;
using i64 = long long;

template&lt;class T&gt;
std::tuple&lt;std::vector&lt;T&gt;, std::vector&lt;T&gt;, std::vector&lt;T&gt;&gt; build_factorial(int N) {
  std::vector&lt;T&gt; fact(N);
  std::vector&lt;T&gt; finv(N);
  std::vector&lt;T&gt; inv(N);
  fact[0] = T(1);
  for(int i = 1;i &lt; N;i++) {
    fact[i] = fact[i - 1] * T(i);
  }
  finv[N - 1] = T(1) / fact[N - 1];
  for(int i = N - 1; i --&gt; 0;) {
    finv[i] = finv[i + 1] * T(i + 1);
  }
  for(int i = 0;i &lt; N;i++) {
    inv[i] = fact[i - 1] * finv[i];
  }
  return std::make_tuple(std::move(fact), std::move(finv), std::move(inv));
}
</code></pre>
<h1><a class="header" href="#convolution" id="convolution">Convolution</a></h1>
<p>畳み込み <a href="http://kazuma8128.hatenablog.com/entry/2018/07/29/231819">参考 - 約数集合でのゼータ変換・メビウス変換的なやつと畳み込み</a></p>
<h2><a class="header" href="#集合の畳み込みについて" id="集合の畳み込みについて">集合の畳み込みについて</a></h2>
<p>\(A \subseteq B\) のとき, \( B \)は\( A \)の上位集合という. また\( A \)は\( B \)の下位集合という.</p>
<p>上位集合について和を求める変換して互いをかけ合わせて逆変換をすると, 積集合(And)の個数が求められる.<br />
下位集合について和を求める変換して互いをかけ合わせて逆変換をすると, 和集合(Or)の個数が求められる.</p>
<p>例) <code>multiple_transform</code>(<code>i</code>について, <code>i</code>を約数に持つ<code>j</code>の<code>a[j]</code>の総和を求める --&gt; 上位集合)をして互いをかけ合わせて逆変換すると, 積集合(<code>gcd</code>についての畳み込み)がの個数が求められる.</p>
<h2><a class="header" href="#transforms" id="transforms">Transforms</a></h2>
<ul>
<li><a href="math/convolution/./multiple_transform.html">Multiple Transform</a></li>
<li><a href="math/convolution/./divisor_transform.html">Divisor Transform</a></li>
<li><a href="math/convolution/./fast_fourier_transform.html">Fast Fourier Transform</a></li>
<li><a href="math/convolution/./numeric_theoretic_transform.html">Number Theoretic Transform</a></li>
</ul>
<h1><a class="header" href="#multiple-transform" id="multiple-transform">Multiple Transform</a></h1>
<p>約数幇助と呼ばれる. <a href="http://noshi91.hatenablog.com/entry/2018/12/27/121649">参考 - 高速ゼータ変換の約数版</a></p>
<h3><a class="header" href="#spec-28" id="spec-28">Spec</a></h3>
<p><code>i</code>について, <code>i</code>を約数に持つ<code>j</code>(上位集合)の<code>a[j]</code>の総和を求める. \( O(N \log{\log N}) \).<br />
<code>inverse multiple transform</code>と共に使うと<code>gcd</code>に関する畳み込みができる. こんな感じ</p>
<p>\[ h(z) = \sum_{\gcd(x, y) = z} {f(x) * g(y)} \]</p>
<h3><a class="header" href="#code-41" id="code-41">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

template &lt;class T&gt;
void multiple_transform(vector&lt;T&gt; &amp;a) {
	int n = a.size();
	vector&lt;bool&gt; sieve(n, true);
	for (int p = 2; p &lt; n; ++p) {
		if (sieve[p]) {
			for (int k = (n - 1) / p; k != 0; --k) {
				sieve[k * p] = false;
				a[k] += a[k * p];
			}
		}
	}
	for (int i = 0; ++i != n;) {
		a[i] += a[0];
	}
}

template &lt;class T&gt;
void inverse_multiple_transform(vector&lt;T&gt; &amp;a) {
	int n = a.size();
	vector&lt;bool&gt; sieve(n, true);
	for (int i = 0; ++i != n;) {
		a[i] -= a[0];
	}
	for (int p = 2; p &lt; n; ++p) {
		if (sieve[p]) {
			for (int k = 1; k * p &lt; n; ++k) {
				sieve[k * p] = false;
				a[k] -= a[k * p];
			}
		}
	}
}
</code></pre>
<h1><a class="header" href="#divisor-transform" id="divisor-transform">Divisor Transform</a></h1>
<p>約数幇助と呼ばれる. <a href="http://noshi91.hatenablog.com/entry/2018/12/27/121649">参考 - 高速ゼータ変換の約数版</a></p>
<h3><a class="header" href="#spec-29" id="spec-29">Spec</a></h3>
<p><code>i</code>について, <code>i</code>の約数である<code>j</code>(下位集合)について<code>a[j]</code>の総和を求める. \( O(N \log{\log N}) \).<br />
<code>inverse divisor transform</code>と共に使うと<code>lcm</code>に関する畳み込みができる. こんな感じ</p>
<p>\[  h(z) = \sum_{ \operatorname{lcm} (x, y) = z } { f(x) * g(y) } \]</p>
<h3><a class="header" href="#code-42" id="code-42">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

template &lt;class T&gt;
void divisor_transform(vector&lt;T&gt; &amp;a) {
	int n = a.size();
	vector&lt;bool&gt; sieve(n, true);
	for (int p = 2; p &lt; n; ++p) {
		if (sieve[p]) {
			for (int k = 1; k * p &lt; n; ++k) {
				sieve[k * p] = false;
				a[k * p] += a[k];
			}
		}
	}
	for (int i = 0; ++i != n;) {
		a[i] += a[0];
	}
}

template &lt;class T&gt;
void inverse_divisor_transform(vector&lt;T&gt; &amp;a) {
	int n = a.size();
	vector&lt;bool&gt; sieve(n, true);
	for (int i = 0; ++i != n;) {
		a[i] -= a[0];
	}
	for (int p = 2; p &lt; n; ++p) {
		if (sieve[p]) {
			for (int k = (n - 1) / p; k != 0; --k) {
				sieve[k * p] = false;
				a[k * p] -= a[k];
			}
		}
	}
}

</code></pre>
<h1><a class="header" href="#fast-fourier-transform" id="fast-fourier-transform">Fast Fourier Transform</a></h1>
<h3><a class="header" href="#spec-30" id="spec-30">Spec</a></h3>
<p>離散フーリエ変換(discrete Fourier transformation)を\( O(n \log n) \)で行う.</p>
<p>誤差厳しい, 整数ならNTT使おう(誤差をなくすようにFFTするのもあるらしい)</p>
<h3><a class="header" href="#code-43" id="code-43">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;complex&gt;
using namespace std;
using i64 = long long;

const double pi = std::acos(-1);

vector&lt;complex&lt;double&gt;&gt; fast_fourier_transform(vector&lt;complex&lt;double&gt;&gt; a) {
  i64 n = a.size();
  for(i64 s = n &gt;&gt; 1; s &gt;= 1; s &gt;&gt;= 1) {
    complex&lt;double&gt; zeta = std::polar(1.0, 2 * pi / (double)(s &lt;&lt; 1));
    for(i64 i = 0;i &lt; n;i += (s &lt;&lt; 1)) {
      complex&lt;double&gt; zi = 1.0;
      for(i64 j = 0;j &lt; s;j++) {
        complex&lt;double&gt; t = a[i + j] - a[s + i + j];
        a[i + j] = a[i + j] + a[s + i + j];
        a[s + i + j] = t * zi;
        zi = zi * zeta;
      }
    }
  }
  return a;
}

vector&lt;complex&lt;double&gt;&gt; inverse_fast_fourier_transform(vector&lt;complex&lt;double&gt;&gt; a) {
  i64 n = a.size();
  for(i64 s = 1; s &lt; n; s &lt;&lt;= 1) {
    complex&lt;double&gt; zeta = std::polar(1.0, -1 * 2 * pi / (double)(s &lt;&lt; 1));
    for(i64 i = 0; i &lt; n; i += (s &lt;&lt; 1)) {
      complex&lt;double&gt; zi = 1;
      for(i64 j = 0;j &lt; s;j++) {
        complex&lt;double&gt; t = a[s + i + j] * zi;
        a[s + i + j] = a[i + j] - t;
        a[i + j] = a[i + j] + t;
        zi = zi * zeta;
      }
    }
  }
  i64 inv_n = 1 / (double)n;
  for(int i = 0;i &lt; n;i++) a[i] *= inv_n;
  return a;
}
</code></pre>
<h1><a class="header" href="#numeric-theoretic-transform" id="numeric-theoretic-transform">Numeric Theoretic Transform</a></h1>
<h3><a class="header" href="#spec-31" id="spec-31">Spec</a></h3>
<p>素数\( m = 2^k + 1, 2^k &gt;= n\)として\(F_m \)剰余環上での離散フーリエ変換(discrete Fourier transformation)を\( O(n \log n) \)で行う<br />
<code>NTT_PRIMES</code>は<a href="https://lumakernel.github.io/ecasdqina/math/FFT/NTT">るまライブラリ</a>からお借りしています</p>
<p>ほとんど単体でNTTを使うことはなさそう(FPSで使うね)</p>
<h3><a class="header" href="#code-44" id="code-44">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

template&lt;i64 M&gt;
struct modint {
  i64 a;
  constexpr modint(const i64 x = 0) noexcept: a((x % M + M) % M) {}
  constexpr i64 value() const noexcept { return a; }
  constexpr modint pow(i64 r) const noexcept {
    modint ans(1);
    modint aa = *this;
    while(r) {
      if(r &amp; 1) {
        ans *= aa;
      }
      aa *= aa;
      r &gt;&gt;= 1;
    }
    return ans;
  }
  constexpr modint&amp; operator+=(const modint r) noexcept {
    a += r.a;
    if(a &gt;= M) a -= M;
    return *this;
  }
  constexpr modint&amp; operator=(const i64 r) {
    a = (r % M + M) % M;
    return *this;
  }
  constexpr modint&amp; operator-=(const modint r) noexcept {
    a -= r.a;
    if(a &lt; 0) a += M;
    return *this;
  }
  constexpr modint&amp; operator*=(const modint r) noexcept {
    a = a * r.a % M;
    return *this;
  }
  constexpr modint&amp; operator/=(modint r) noexcept {
    i64 ex = M - 2;
    while(ex) {
      if(ex &amp; 1) {
        *this *= r;
      }
      r *= r;
      ex &gt;&gt;= 1;
    }
    return *this;
  }

  constexpr modint operator+(const modint r) const {
    return modint(*this) += r;
  }
  constexpr modint operator-(const modint r) const {
    return modint(*this) -= r;
  }
  constexpr modint operator*(const modint r) const {
    return modint(*this) *= r;
  }
  constexpr modint operator/(const modint r) const {
    return modint(*this) /= r;
  }
};

constexpr i64 NTT_PRIMES[][2] = {
    {1224736769, 3}, // 2^24 * 73 + 1,
    {1053818881, 7}, // 2^20 * 3 * 5 * 67 + 1
    {1051721729, 6}, // 2^20 * 17 * 59 + 1
    {1045430273, 3}, // 2^20 * 997 + 1
    {1012924417, 5}, // 2^21 * 3 * 7 * 23 + 1
    {1007681537, 3}, // 2^20 * 31^2 + 1
    {1004535809, 3}, // 2^21 * 479 + 1
    {998244353, 3},  // 2^23 * 7 * 17 + 1
    {985661441, 3},  // 2^22 * 5 * 47 + 1
    {976224257, 3},  // 2^20 * 7^2 * 19 + 1
    {975175681, 17}, // 2^21 * 3 * 5 * 31 + 1
    {962592769, 7},  // 2^21 * 3^3 * 17 + 1
    {950009857, 7},  // 2^21 * 4 * 151 + 1
    {943718401, 7},  // 2^22 * 3^2 * 5^2 + 1
    {935329793, 3},  // 2^22 * 223 + 1
    {924844033, 5},  // 2^21 * 3^2 * 7^2 + 1
    {469762049, 3},  // 2^26 * 7 + 1
    {167772161, 3},  // 2^25 * 5 + 1
};

template&lt;const i64 mod, const i64 primitive&gt;
vector&lt;modint&lt;mod&gt;&gt; number_theoretic_transform(vector&lt;modint&lt;mod&gt;&gt; a) {
  i64 n = a.size();
  for(i64 s = n &gt;&gt; 1; s &gt;= 1; s &gt;&gt;= 1) {
    modint&lt;mod&gt; zeta = modint&lt;mod&gt;(primitive).pow((mod - 1) / (s &lt;&lt; 1));
    for(i64 i = 0; i &lt; n; i += (s &lt;&lt; 1)) {
      modint&lt;mod&gt; zi = 1;
      for(i64 j = 0;j &lt; s;j++) {
        modint&lt;mod&gt; t = a[i + j] - a[s + i + j];
        a[i + j] += a[s + i + j];
        a[s + i + j] = t * zi;
        zi = zi * zeta;
      }
    }
  }
  return a;
}

template&lt;const i64 mod, const i64 primitive&gt;
vector&lt;modint&lt;mod&gt;&gt; inverse_number_theoretic_transform(vector&lt;modint&lt;mod&gt;&gt; a) {
  i64 n = a.size();
  for(i64 s = 1; s &lt; n; s &lt;&lt;= 1) {
    modint&lt;mod&gt; zeta = modint&lt;mod&gt;(primitive).pow((mod - 1) / (s &lt;&lt; 1)).pow(mod - 2);
    for(i64 i = 0; i &lt; n; i += (s &lt;&lt; 1)) {
      modint&lt;mod&gt; zi = 1;
      for(i64 j = 0;j &lt; s;j++) {
        modint&lt;mod&gt; t = a[s + i + j] * zi;
        a[s + i + j] = a[i + j] - t;
        a[i + j] = a[i + j] + t;
        zi = zi * zeta;
      }
    }
  }
  auto inv_n = modint&lt;mod&gt;(n).pow(mod - 2);
  for(int i = 0;i &lt; n;i++) a[i] *= inv_n;
  return a;
}
</code></pre>
<h1><a class="header" href="#string" id="string">String</a></h1>
<p><a href="https://snuke.hatenablog.com/entry/2014/12/01/235807">文字列の頭良い感じの線形アルゴリズムたち</a></p>
<ul>
<li><a href="string/./manacher.html">Manacher</a> \</li>
<li><a href="string/./mp.html">MP (Morris Pratt)</a></li>
<li><a href="string/./rolling_hash.html">Rolling Hash</a> \</li>
<li><a href="string/./suffix_array.html">Suffix Array</a> \</li>
<li><a href="string/./Z-algorithm.html">Z-algorithm</a> \</li>
</ul>
<h1><a class="header" href="#231-rolling-hash" id="231-rolling-hash">2^31 Rolling Hash</a></h1>
<h2><a class="header" href="#code-45" id="code-45">Code</a></h2>
<pre><code class="language-cpp">#include &lt;vector&gt;
using u64 = unsigned long long;

struct hash_bases {
  static const u64 MOD = (1ull &lt;&lt; 61) - 1;
  const int N;
  std::vector&lt;std::vector&lt;u64&gt;&gt; bases;
  
  inline static u64 mod(u64 x) {
    x = (x &gt;&gt; 61) + (x &amp; MOD);
    if(x &gt;= MOD) {
      x -= MOD;
    }
    return x;
  }

  inline static u64 mul(u64 a, u64 b) {
    u64 ac = a &gt;&gt; 31;
        a  = a &amp; ((1ull &lt;&lt; 31) - 1);
    u64 bc = b &gt;&gt; 31;
        b  = b &amp; ((1ull &lt;&lt; 31) - 1);
    u64 x = ac * b + bc * a;;
    x = ac * bc * 2 + (x &gt;&gt; 30) + ((x &amp; ((1ull &lt;&lt; 30) - 1)) &lt;&lt; 31) + a * b;
    return mod(x);
  }
  
  hash_bases(std::vector&lt;u64&gt; bs, int M) : N(bs.size()), bases(M, std::vector&lt;u64&gt;(N, 1)) {
    for(int i = 1; i &lt; M; i++) {
      for(int j = 0;j &lt; N; j++){
        bases[i][j] = mul(bases[i - 1][j], bs[j]);
      }
    }
  }

  u64 operator()(int i, int r) {
    return bases[r][i];
  }
} bases(std::vector&lt;u64&gt; { 9973, 10007 }, 202020);

struct rhash {
  static const u64 MOD = hash_bases::MOD;
  std::vector&lt;u64&gt; h;
  u64 len;

  rhash() : h(bases.N), len(0) {}
  rhash(u64 x): h(bases.N), len(1) {
    x = hash_bases::mod(x);
    for(int i = 0; i &lt; bases.N; i++) {
      h[i] = x;
    }
  }

  rhash next(u64 r) const {
    rhash ans;
    for(int i = 0;i &lt; bases.N; i++) { 
      ans.h[i] = hash_bases::mul(h[i], bases(i, r));
    }
    ans.len = len + r;
    return ans;
  }

  rhash&amp; operator+=(const rhash&amp; r) {
    for(int i = 0;i &lt; bases.N; i++) {
      h[i] += r.h[i];
      if(h[i] &gt;= MOD) h[i] -= MOD;
    }
    len = std::max(len, r.len);
    return (*this);
  }

  rhash&amp; operator-=(const rhash&amp; r) {
    for(int i = 0;i &lt; bases.N; i++) {
      if(h[i] &lt; r.h[i]) {
        h[i] = h[i] + MOD - r.h[i];
      }
      else {
        h[i] = h[i] - r.h[i];
      }
    }
    return (*this);
  }

  rhash operator+(const rhash&amp; r) const { return rhash(*this) += r; }
  rhash operator-(const rhash&amp; r) const { return rhash(*this) -= r; }
  bool operator==(const rhash&amp; r) const {
    bool OK = true;
    for(int i = 0;i &lt; bases.N; i++){
      OK &amp;= h[i] == r.h[i];
    }
    return OK;
  }
};
</code></pre>
<h1><a class="header" href="#manacher" id="manacher">Manacher</a></h1>
<h2><a class="header" href="#code-46" id="code-46">Code</a></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

/*
 * 文字 i を中心とする最長の回文の半径 = (全長 + 1) / 2
 */

vector&lt;i64&gt; manacher(string S) {
  vector&lt;i64&gt; R(S.size());
  int i = 0, j = 0;
  while (i &lt; S.size()) {
    while (i-j &gt;= 0 &amp;&amp; i+j &lt; S.size() &amp;&amp; S[i-j] == S[i+j]) ++j;
    R[i] = j;
    int k = 1;
    while (i-k &gt;= 0 &amp;&amp; i+k &lt; S.size() &amp;&amp; k+R[i-k] &lt; j) R[i+k] = R[i-k], ++k;
    i += k; j -= k;
  }
  return R;
}
</code></pre>
<h1><a class="header" href="#mp-morris-pratt" id="mp-morris-pratt">MP (Morris Pratt)</a></h1>
<p><a href="https://snuke.hatenablog.com/entry/2014/12/01/235807">文字列の頭良い感じの線形アルゴリズムたち</a></p>
<h3><a class="header" href="#spec-32" id="spec-32">Spec</a></h3>
<p>文字列S[0, i-1]のprefixとsuffixが最大何文字一致しているかを \( O(|S|) \)で求める.</p>
<h4><a class="header" href="#example" id="example">Example</a></h4>
<pre><code>aabaabaaa
_010123452
</code></pre>
<h3><a class="header" href="#code-47" id="code-47">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

/*
 * 文字列S[0, i-1]のprefixとsuffixが最大何文字一致しているか
 */

vector&lt;i64&gt; mp(string S) {
  vector&lt;i64&gt; A(S.size() + 1);
  A[0] = -1;
  int j = -1;
  for (int i = 0; i &lt; S.size(); i++) {
    while (j &gt;= 0 &amp;&amp; S[i] != S[j]) j = A[j];
    j++;
    A[i+1] = j;
  }
  return A;
}

</code></pre>
<h1><a class="header" href="#suffix-array" id="suffix-array">Suffix Array</a></h1>
<h2><a class="header" href="#code-48" id="code-48">Code</a></h2>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;

template&lt;class T&gt;
const std::vector&lt;int&gt;&amp; sa_is(std::vector&lt;T&gt; s, int k) {
  int N = s.size();
  static std::vector&lt;int&gt; sa;
  static std::vector&lt;int&gt; cnt;
  sa.resize(N + 1);

  if(N == 0) return sa;

  for(auto&amp; c: s) c++;
  s.push_back(0);
  k++;

  std::vector&lt;bool&gt; iss(N + 1);
  std::vector&lt;int&gt; lms;
  std::vector&lt;int&gt; is_lms(N + 1, -1);
  std::vector&lt;int&gt; bin(k + 1);

  iss[N] = true;
  bin[1]++;
  for(int i = N; i --&gt; 0; ) {
    if(s[i] == s[i + 1])
      iss[i] = iss[i + 1];
    else
      iss[i] = s[i] &lt; s[i + 1];
    if(!iss[i] &amp;&amp; iss[i + 1]) {
      is_lms[i + 1] = lms.size();
      lms.push_back(i + 1);
    }
    bin[s[i] + 1]++;
  }

  for(int i = 1;i &lt;= k;i++)
    bin[i] += bin[i - 1];

  auto induce = [&amp;](const std::vector&lt;int&gt;&amp; lms) {
    sa.assign(N + 1, -1);
    cnt.assign(k, 0);

    for(int i = 0;i &lt; lms.size();i++) {
      int x = lms[i];
      sa[bin[s[x] + 1] - 1 - cnt[s[x]]] = x;
      cnt[s[x]]++;
    }

    cnt.assign(k, 0);
    for(int i = 0;i &lt;= N;i++) {
      int x = sa[i] - 1;
      if(x &gt;= 0 &amp;&amp; !iss[x]) {
        sa[bin[s[x]] + cnt[s[x]]] = x;
        cnt[s[x]]++;
      }
    }

    cnt.assign(k, 0);
    for(int i = N + 1;i --&gt; 0;) {
      int x = sa[i] - 1;
      if(x &gt;= 0 &amp;&amp; iss[x]) {
        sa[bin[s[x] + 1] - 1 - cnt[s[x]]] = x;
        cnt[s[x]]++;
      }
    }
  };

  induce(lms);


  if(lms.size() &gt;= 2) {
    int M = lms.size();
    int li = 0;
    std::vector&lt;int&gt; rec_lms(M);
    for(auto x: sa) {
      if(is_lms[x] != -1) rec_lms[li++] = x;
    }
    int rec_n = 1;
    std::vector&lt;int&gt; rec_s(M);
    rec_s[M - 1 - is_lms[rec_lms[1]]] = 1;
    for(int i = 2;i &lt; M;i++) {
      int xl = rec_lms[i];
      int yl = rec_lms[i - 1];
      int xr = lms[is_lms[xl] - 1];
      int yr = lms[is_lms[yl] - 1];
      if(xr - xl != yr - yl)
        rec_n++;
      else {
        while(xl &lt;= xr) {
          if(s[xl] != s[yl]) {
            rec_n++;
            break;
          }
          xl++;
          yl++;
        }
      }
      rec_s[M - 1 - is_lms[rec_lms[i]]] = rec_n;
    }


    sa_is(std::move(rec_s), rec_n + 1);
    li = M;
    for(int i = 1;i &lt; M + 1;i++) {
      rec_lms[--li] = lms[M - 1 - sa[i]];
    }
    induce(rec_lms);
  }

  return sa;
}
</code></pre>
<h1><a class="header" href="#z-algorithm" id="z-algorithm">Z-algorithm</a></h1>
<h2><a class="header" href="#code-49" id="code-49">Code</a></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

vector&lt;i64&gt; z_algorithm(string S) {
  vector&lt;i64&gt; A(S.size());
  A[0] = S.size();
  int i = 1, j = 0;
  while (i &lt; S.size()) {
    while (i+j &lt; S.size() &amp;&amp; S[j] == S[i+j]) ++j;
    A[i] = j;
    if (j == 0) { ++i; continue;}
    int k = 1;
    while (i+k &lt; S.size() &amp;&amp; k+A[k] &lt; j) A[i+k] = A[k], ++k;
    i += k; j -= k;
  }
  return A;
}
</code></pre>
<h1><a class="header" href="#burrows-wheeler" id="burrows-wheeler">Burrows Wheeler</a></h1>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;

template&lt;class T&gt;
const std::vector&lt;int&gt;&amp; sa_is(std::vector&lt;T&gt; s, int k) {
  int N = s.size();
  static std::vector&lt;int&gt; sa;
  static std::vector&lt;int&gt; cnt;
  sa.resize(N + 1);

  if(N == 0) return sa;

  for(auto&amp; c: s) c++;
  s.push_back(0);
  k++;

  std::vector&lt;bool&gt; iss(N + 1);
  std::vector&lt;int&gt; lms;
  std::vector&lt;int&gt; is_lms(N + 1, -1);
  std::vector&lt;int&gt; bin(k + 1);

  iss[N] = true;
  bin[1]++;
  for(int i = N; i --&gt; 0; ) {
    if(s[i] == s[i + 1])
      iss[i] = iss[i + 1];
    else
      iss[i] = s[i] &lt; s[i + 1];
    if(!iss[i] &amp;&amp; iss[i + 1]) {
      is_lms[i + 1] = lms.size();
      lms.push_back(i + 1);
    }
    bin[s[i] + 1]++;
  }

  for(int i = 1;i &lt;= k;i++)
    bin[i] += bin[i - 1];

  auto induce = [&amp;](const std::vector&lt;int&gt;&amp; lms) {
    sa.assign(N + 1, -1);
    cnt.assign(k, 0);

    for(int i = 0;i &lt; lms.size();i++) {
      int x = lms[i];
      sa[bin[s[x] + 1] - 1 - cnt[s[x]]] = x;
      cnt[s[x]]++;
    }

    cnt.assign(k, 0);
    for(int i = 0;i &lt;= N;i++) {
      int x = sa[i] - 1;
      if(x &gt;= 0 &amp;&amp; !iss[x]) {
        sa[bin[s[x]] + cnt[s[x]]] = x;
        cnt[s[x]]++;
      }
    }

    cnt.assign(k, 0);
    for(int i = N + 1;i --&gt; 0;) {
      int x = sa[i] - 1;
      if(x &gt;= 0 &amp;&amp; iss[x]) {
        sa[bin[s[x] + 1] - 1 - cnt[s[x]]] = x;
        cnt[s[x]]++;
      }
    }
  };

  induce(lms);


  if(lms.size() &gt;= 2) {
    int M = lms.size();
    int li = 0;
    std::vector&lt;int&gt; rec_lms(M);
    for(auto x: sa) {
      if(is_lms[x] != -1) rec_lms[li++] = x;
    }
    int rec_n = 1;
    std::vector&lt;int&gt; rec_s(M);
    rec_s[M - 1 - is_lms[rec_lms[1]]] = 1;
    for(int i = 2;i &lt; M;i++) {
      int xl = rec_lms[i];
      int yl = rec_lms[i - 1];
      int xr = lms[is_lms[xl] - 1];
      int yr = lms[is_lms[yl] - 1];
      if(xr - xl != yr - yl)
        rec_n++;
      else {
        while(xl &lt;= xr) {
          if(s[xl] != s[yl]) {
            rec_n++;
            break;
          }
          xl++;
          yl++;
        }
      }
      rec_s[M - 1 - is_lms[rec_lms[i]]] = rec_n;
    }


    sa_is(std::move(rec_s), rec_n + 1);
    li = M;
    for(int i = 1;i &lt; M + 1;i++) {
      rec_lms[--li] = lms[M - 1 - sa[i]];
    }
    induce(rec_lms);
  }

  return sa;
}

#include &lt;cstdint&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

using i64 = long long;

class bitvector {
  using bit_type = std::uint_least64_t;
  using size_type = std::size_t;
  static constexpr size_type wordsize = 64;
  
  std::vector&lt;bit_type&gt; bit;
  std::vector&lt;size_type&gt; sum;
  
public:

  bitvector() : bit(), sum() {} 
  bitvector(const size_type size)
    : bit(size / wordsize + 1, 0), sum(size / wordsize + 1, 0) {}

  void set(const size_type i) {
    bit[i / wordsize] |= static_cast&lt;bit_type&gt;(1) &lt;&lt; (i % wordsize);
  }
  void build() {
    for (size_type i = 1; i &lt; bit.size(); i++) {
      sum[i] = sum[i - 1] + __builtin_popcountll(bit[i - 1]);
    }
  }

  size_type at(const size_type i) const {
    return bit[i / wordsize] &gt;&gt; (i % wordsize);
  }

  // count of ones in [0, i)
  size_type rank(const size_type i) const {
    return sum[i / wordsize]
      + __builtin_popcountll(bit[i / wordsize] &amp; (static_cast&lt;bit_type&gt;(1) &lt;&lt; (i % wordsize)) - 1);
  }

  // count of ones in [0, i)
  size_type rank(const size_type i, const size_type b) const {
    size_type ans = sum[i / wordsize]
      + __builtin_popcountll(bit[i / wordsize] &amp; (static_cast&lt;bit_type&gt;(1) &lt;&lt; (i % wordsize)) - 1);
    if(b) return ans;
    else return i - ans;
  }
};

template&lt;class T&gt;
class wavelet_matrix {
  using Integer = T;
  using integer_type = Integer;
  using size_type = std::size_t;


  size_type depth;
  size_type len;
  std::vector&lt;bitvector&gt; mat;
  std::vector&lt;size_type&gt; spl;

public:

  wavelet_matrix(): depth(0), len(0) {}
  wavelet_matrix(const std::vector&lt;integer_type&gt;&amp; arr, size_type de)
    : depth(de),
      len(arr.size()),
      mat(std::vector&lt;bitvector&gt;(depth, bitvector(arr.size()))),
      spl(std::vector&lt;size_type&gt;(depth, 0)) {
        std::vector&lt;size_type&gt; idx(len);
        std::vector&lt;size_type&gt; left(len), right(len);
        for(size_type i = 0;i &lt; len;i++) idx[i] = i;
        for(size_type d = depth; d-- &gt; 0;) {
          size_type l = 0, r = 0;
          
          for(size_type i = 0; i &lt; len; i++) {
            size_type k = (arr[idx[i]] &gt;&gt; d) &amp; 1;
            if(k) right[r++] = idx[i], mat[d].set(i);
            else left[l++] = idx[i];
          }
          mat[d].build();
          spl[d] = l;
          swap(idx, left);
          for(size_type i = 0; i &lt; r; i++) idx[i + l] = right[i];
        }
      }

  integer_type at(size_type i) const {
    integer_type x = static_cast&lt;integer_type&gt;(0);
    for(size_type d = depth; d-- &gt; 0;) {
      size_type k = mat[d].at(i);
      x |= (static_cast&lt;integer_type&gt;(k) &lt;&lt; d);
      i = mat[d].rank(i, k) + spl[d] * k;
    }
    return x;
  }

  // counting elements that equal to x in range [left, right)
  size_type rank_x(size_type left, size_type right, integer_type x) const {
    for(size_type d = depth; d-- &gt; 0;) {
      size_type k = ((x &gt;&gt; d) &amp; 1);
      if(k) {
        left = mat[d].rank(left, k) + spl[d];
        right = mat[d].rank(right, k) + spl[d];
      }
      else {
        left = mat[d].rank(left, k);
        right = mat[d].rank(right, k);
      }
    }
    return right - left;
  }

  // sorted(arr[left..right])[i]
  integer_type quantile(size_type left, size_type right, size_type i) const {
    integer_type x = static_cast&lt;integer_type&gt;(0);
    for(size_type d = depth; d-- &gt; 0;) {
      size_type cnt = mat[d].rank(right, 0) - mat[d].rank(left, 0);
      size_type k = (i &lt; cnt) ? 0 : 1;
      x |= (k &lt;&lt; d);
      left = mat[d].rank(left, k) + spl[d] * k;
      right = mat[d].rank(right, k) + spl[d] * k;
    }
    return x;
  }

  struct rank_result {
    size_type le;
    size_type eq;
    size_type mo;
  };

  // couting elements that less than x, equal to x, and more than x in range [left, right)
  rank_result rank_less_eq_more(size_type left, size_type right, integer_type x) const {
    size_type le = 0, mo = 0;
    for(size_type d = depth; d --&gt; 0;) {
      size_type k = (x &gt;&gt; d) &amp; 1;
      size_type l = mat[d].rank(left, 1);
      size_type r = mat[d].rank(right, 1);
      if(k == 0) {
        mo += r - l;
        left -= l;
        right -= r;
      }
      else {
        le += (right - left) - (r - l);
        left = l + spl[d];
        right = r + spl[d];
      }
    }
    return rank_result { le, right - left, mo };
  }

  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y, integer_type l, size_type d) const {
    integer_type r = l + (1 &lt;&lt; d);
    if(x &lt;= l &amp;&amp; r &lt;= y) {
      return right - left;
    }
    else if(y &lt;= l || r &lt;= x) {
      return 0;
    }
    else {
      d--;
      size_type lr = mat[d].rank(left, 1);
      size_type rr = mat[d].rank(right, 1);
      return
        rangefreq(left - lr, right - rr, x, y, l, d) +
        rangefreq(lr + spl[d], rr + spl[d], x, y, l + (1 &lt;&lt; d), d);
    }
  }

  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y) const {
    return rangefreq(left, right, x, y, 0, depth);
  }
};

template&lt;class T&gt;
struct burrows_wheeler {
  std::vector&lt;int&gt; sa;
  std::vector&lt;T&gt; L;
  std::vector&lt;int&gt; C;
  wavelet_matrix&lt;T&gt; wm;
  burrows_wheeler(const std::vector&lt;T&gt;&amp; s, int k, int de): sa(sa_is(s, k)), L(s.size() + 1), C(k + 1) {
    for(int i = 0;i &lt; sa.size();i++) {
      if(sa[i] &gt; 0) L[i] = s[sa[i] - 1];
      else L[i] = 0;
    }
    for(int i = 0;i &lt; s.size();i++) {
      C[s[i] + 1]++;
    }
    C[0]++;
    for(int i = 0; i &lt; k; i++) {
      C[i + 1] += C[i];
    }
    wm = wavelet_matrix&lt;T&gt;(L, de);
  }
  int match(const std::string&amp; p) {
    int s = 0;
    int e = sa.size();
    for(int i = p.size();i --&gt; 0;) {
      s = wm.rank_x(0, s, p[i]) + C[p[i]];
      e = wm.rank_x(0, e, p[i]) + C[p[i]];
      if(s &gt;= e) break;
    }
    return e - s;
  }
};
</code></pre>
<h1><a class="header" href="#rolling-hash" id="rolling-hash">Rolling Hash</a></h1>
<h2><a class="header" href="#code-50" id="code-50">Code</a></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

const i64 rhmod = 1e9 + 7;
const i64 BASE_C = 2;
const i64 base[] = {9973, 10007};

struct rolling_hash {
  i64 n;
  vector&lt;i64&gt; hs[BASE_C], pw[BASE_C];
  
  template&lt;class Array&gt;
  rolling_hash(const Array&amp; arr) {
    n = arr.size();
    for(int i = 0;i &lt; BASE_C;i++) {
      hs[i].assign(n + 1, 0);
      pw[i].assign(n + 1, 0);
      hs[i][0] = 0;
      pw[i][0] = 1;
      for(int j = 0;j &lt; n;j++) {
        pw[i][j + 1] = pw[i][j] * base[i] % rhmod;
        hs[i][j + 1] = (hs[i][j] * base[i] + arr[j]) % rhmod;
      }
    }
  }

  pair&lt;i64, i64&gt; hash(i64 l, i64 r) {
    return {
      ((hs[0][r + 1] - hs[0][l] * pw[0][r + 1 - l]) % rhmod + rhmod) % rhmod,
      ((hs[1][r + 1] - hs[1][l] * pw[1][r + 1 - l]) % rhmod + rhmod) % rhmod,
    };
  }
};
</code></pre>
<h1><a class="header" href="#graph" id="graph">Graph</a></h1>
<ul>
<li><a href="graph/./strongly_connected_components.html">Strongly Connected Components</a> \</li>
</ul>
<h1><a class="header" href="#dijkstra" id="dijkstra">Dijkstra</a></h1>
<h3><a class="header" href="#code-51" id="code-51">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;queue&gt;

/*
 * delta(V v, fn (V t, W weight))
 * index(V v) -&gt; int
 */
template&lt;class V, class W, class Delta, class Index&gt;
std::vector&lt;W&gt; dijkstra(std::size_t N, W inf, V s, Delta delta, Index index) {
  std::vector&lt;W&gt; dist(N, inf);
  using P = std::pair&lt;W, V&gt;;
  std::priority_queue&lt;P, std::vector&lt;P&gt;, std::greater&lt;P&gt;&gt; que;
  que.push({ dist[index(s)] = W(), s });
  while(!que.empty()) {
    W d = que.top().first;
    V v = que.top().second;
    que.pop();
    if(dist[index(v)] &lt; d) continue;
    delta(v, [&amp;](V t, W weight) {
        if(dist[index(t)] &gt; dist[index(v)] + weight) {
          que.push({ dist[index(t)] = dist[index(v)] + weight, t });
        }
    });
  }
  return dist;
}
</code></pre>
<h1><a class="header" href="#dijkstra-1" id="dijkstra-1">Dijkstra</a></h1>
<h3><a class="header" href="#code-52" id="code-52">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;queue&gt;

/*
 * delta(V v, fn (V t, W weight))
 * index(V v) -&gt; int
 */
template&lt;class V, class W, class Delta, class Index&gt;
std::vector&lt;W&gt; dijkstra(std::size_t N, W inf, V s, Delta delta, Index index) {
  std::vector&lt;W&gt; dist(N, inf);
  using P = std::pair&lt;W, V&gt;;
  std::priority_queue&lt;P, std::vector&lt;P&gt;, std::greater&lt;P&gt;&gt; que;
  que.push({ dist[index(s)] = W(), s });
  while(!que.empty()) {
    W d = que.top().first;
    V v = que.top().second;
    que.pop();
    if(dist[index(v)] &lt; d) continue;
    delta(v, [&amp;](V t, W weight) {
        if(dist[index(t)] &gt; dist[index(v)] + weight) {
          que.push({ dist[index(t)] = dist[index(v)] + weight, t });
        }
    });
  }
  return dist;
}
</code></pre>
<h1><a class="header" href="#bfs" id="bfs">BFS</a></h1>
<h3><a class="header" href="#code-53" id="code-53">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;queue&gt;
using i64 = long long;

/*
 * delta(V v, fn (V t))
 * index(V v) -&gt; int
 */
template&lt;class V, class Delta, class Index&gt;
std::vector&lt;i64&gt; bfs(std::size_t N, V s, Delta delta, Index index) {
  std::vector&lt;i64&gt; dist(N, -1);
  std::queue&lt;V&gt; que;
  dist[index(s)] = 0;
  que.push(s);
  while(!que.empty()) {
    V v = que.front();
    que.pop();
    delta(v, [&amp;](V t) {
        if(dist[index(t)] == -1) {
          dist[index(t)] = dist[index(v)] + 1;
          que.push(t);
        }
    });
  }
  return dist;
}
</code></pre>
<h1><a class="header" href="#dial-01" id="dial-01">Dial 01</a></h1>
<h3><a class="header" href="#code-54" id="code-54">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;queue&gt;
using i64 = long long;

/*
 * delta(V v, fn (V t, i64 weight))
 * index(V v) -&gt; int
 */
template&lt;class V, class W, class Delta, class Index&gt;
std::vector&lt;i64&gt; dial01(std::size_t N, W inf, V s, Delta delta, Index index) {
  std::vector&lt;i64&gt; dist(N, inf);
  using P = std::pair&lt;V, W&gt;;
  std::deque&lt;P&gt; que;
  dist[index(s)] = 0;
  que.push_back({ s, dist[index(s)]});
  while(!que.empty()) {
    V v = que.front().first;
    W d = que.front().second;
    que.pop_front();
    if(dist[index(v)] &lt; d) continue;
    delta(v, [&amp;](V t, i64 weight) {
        if(dist[index(t)] &gt; dist[index(v)] + weight) {
          dist[index(t)] = dist[index(v)] + weight;
          if(weight == 0) que.push_front({ t, dist[index(t)] });
          else que.push_back({ t, dist[index(t)] });
        }
    });
  }
  return dist;
}
</code></pre>
<h1><a class="header" href="#dinic" id="dinic">Dinic</a></h1>
<h2><a class="header" href="#code-55" id="code-55">Code</a></h2>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;queue&gt;

struct dinic {
  using cap_type = int;
  const cap_type INF = 1e9;
  struct edge {
    int to;
    cap_type cap;
    int rev;
  };
  int n;
  std::vector&lt;std::vector&lt;edge&gt;&gt; g;

  dinic(int n): n(n), g(n) {}

  void add_edge(int from, int to, cap_type cap, cap_type rev_cap = 0) {
    g[from].push_back({ to, cap, (int)(g[to].size()) });
    g[to].push_back({ from, rev_cap, (int)(g[from].size() - 1) });
  }
  
  std::vector&lt;int&gt; level;
  std::vector&lt;int&gt; iter;
  cap_type dfs(const int s, const int v, cap_type mf) {
    if(s == v || mf == 0) return mf;
    for(int&amp; i = iter[v]; i &lt; g[v].size(); i++) {
      int t = g[v][i].to;
      edge&amp; re = g[v][i];
      edge&amp; e = g[t][re.rev];
      if(level[t] &gt;= level[v] || e.cap == 0) continue;
      cap_type f = dfs(s, t, std::min(mf, e.cap));
      if(f == 0) continue;
      e.cap -= f;
      re.cap += f;
      return f;
    }
    return 0;
  }

  cap_type max_flow(int s, int t) {
    std::vector&lt;int&gt; que(n);
    cap_type flow = 0;
    while(true) {
      level.assign(n, -1);
      int qi = 0;
      int qr = 0;
      level[s] = 0;
      que[qr++] = s;
      while(qi &lt; qr &amp;&amp; level[t]) {
        int v = que[qi++];
        for(const auto&amp; e: g[v]) {
          if(e.cap &gt; 0 &amp;&amp; level[e.to] == -1) {
            level[e.to] = level[v] + 1;
            que[qr++] = e.to;
          }
        }
      }
      if(level[t] == -1) break;
      iter.assign(n, 0);
      cap_type tmp;
      while((tmp = dfs(s, t, INF)) &gt; 0) {
        flow += tmp;
      }
    }
    return flow;
  }
};
</code></pre>
<h1><a class="header" href="#dinic-1" id="dinic-1">Dinic</a></h1>
<h2><a class="header" href="#code-56" id="code-56">Code</a></h2>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;queue&gt;

struct dinic {
  using cap_type = int;
  const cap_type INF = 1e9;
  struct edge {
    int to;
    cap_type cap;
    int rev;
  };
  int n;
  std::vector&lt;std::vector&lt;edge&gt;&gt; g;

  dinic(int n): n(n), g(n) {}

  void add_edge(int from, int to, cap_type cap, cap_type rev_cap = 0) {
    g[from].push_back({ to, cap, (int)(g[to].size()) });
    g[to].push_back({ from, rev_cap, (int)(g[from].size() - 1) });
  }
  
  std::vector&lt;int&gt; level;
  std::vector&lt;int&gt; iter;
  cap_type dfs(const int s, const int v, cap_type mf) {
    if(s == v || mf == 0) return mf;
    for(int&amp; i = iter[v]; i &lt; g[v].size(); i++) {
      int t = g[v][i].to;
      edge&amp; re = g[v][i];
      edge&amp; e = g[t][re.rev];
      if(level[t] &gt;= level[v] || e.cap == 0) continue;
      cap_type f = dfs(s, t, std::min(mf, e.cap));
      if(f == 0) continue;
      e.cap -= f;
      re.cap += f;
      return f;
    }
    return 0;
  }

  cap_type max_flow(int s, int t) {
    std::vector&lt;int&gt; que(n);
    cap_type flow = 0;
    while(true) {
      level.assign(n, -1);
      int qi = 0;
      int qr = 0;
      level[s] = 0;
      que[qr++] = s;
      while(qi &lt; qr &amp;&amp; level[t]) {
        int v = que[qi++];
        for(const auto&amp; e: g[v]) {
          if(e.cap &gt; 0 &amp;&amp; level[e.to] == -1) {
            level[e.to] = level[v] + 1;
            que[qr++] = e.to;
          }
        }
      }
      if(level[t] == -1) break;
      iter.assign(n, 0);
      cap_type tmp;
      while((tmp = dfs(s, t, INF)) &gt; 0) {
        flow += tmp;
      }
    }
    return flow;
  }
};
</code></pre>
<h1><a class="header" href="#goldberg-tarjans-preflow-relabel" id="goldberg-tarjans-preflow-relabel">GoldBerg Tarjan's Preflow Relabel</a></h1>
<h3><a class="header" href="#code-57" id="code-57">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;bitset&gt;
#include &lt;tuple&gt;

struct residual_graph {
  using cap_type = long long;
  struct edge {
    int to;
    cap_type cap;
    int rev;
    edge(int t = 0, cap_type c = 0, int r = 0): to(t), cap(c), rev(r) {}
  };
  int N;
  std::vector&lt;int&gt; iter;
  std::vector&lt;std::tuple&lt;int, int, cap_type&gt;&gt; pool;
  std::vector&lt;edge&gt; edges;
  residual_graph(int N): N(N), iter(N + 1) {}

  void add_edge(int from, int to, cap_type cap, cap_type rev_cap) {
    iter[from]++;
    iter[to]++;
    pool.emplace_back(from, to, cap);
  }
  void build() {
    for(int i = 0; i &lt; N; i++) {
      iter[i + 1] += iter[i];
    }
    edges.resize(pool.size() * 2);
    for(auto&amp;&amp; p: pool) {
      int fi = --iter[std::get&lt;0&gt;(p)];
      int ti = --iter[std::get&lt;1&gt;(p)];
      edges[fi] = edge(std::get&lt;1&gt;(p), std::get&lt;2&gt;(p), ti);
      edges[ti] = edge(std::get&lt;0&gt;(p), 0, fi);
    }
  }
  inline edge&amp; operator[](int i) { return edges[i]; }
};

struct goldberg_tarjan {
  using cap_type = long long;
  struct edge {
    int to;
    cap_type cap;
    edge(int t, cap_type c, int r): to(t), cap(c) {}
  };

  int N;
  residual_graph G;
  std::vector&lt;cap_type&gt; exc;
  std::vector&lt;int&gt; h;
  std::vector&lt;std::vector&lt;int&gt;&gt; que;
  std::vector&lt;int&gt; qi;
  std::vector&lt;int&gt; ei;
  std::vector&lt;int&gt; hcnt;
  std::bitset&lt;2048&gt; inque;
  const cap_type INF = 1e18;

  goldberg_tarjan(int n): N(n), G(n) {}
  
  void add_edge(int from, int to, cap_type cap, cap_type rev_cap = 0) {
    G.add_edge(from, to, cap, rev_cap);
  }
  void build() {
    G.build();
  }

  void push(int from, int ei) {
    cap_type fl = std::min(exc[from], G[ei].cap);
    G[ei].cap -= fl;
    G[G[ei].rev].cap += fl;
    exc[from] -= fl;
    exc[G[ei].to] += fl;
  }

  void relabel(int v) {
    hcnt[h[v]]--;
    h[v] = N;
    for(int i = G.iter[v]; i &lt; G.iter[v + 1]; i++) {
      auto&amp; e = G[i];
      if(e.cap &gt; 0 &amp;&amp; h[v] &gt; h[e.to] + 1) {
        ei[v] = i;
        h[v] = h[e.to] + 1;
      }
    }
    hcnt[h[v]]++;
  }

  int global_relabeling(int t) {
    std::fill(std::begin(h), std::end(h), N);
    std::fill(std::begin(hcnt), std::end(hcnt), 0);
    for(int i = 0;i &lt; N;i++) {
      que[i].clear();
    }
    inque.reset();
    int i = 0, qr = 0;
    std::vector&lt;int&gt;&amp; Q = qi;
    Q[qr++] = t;
    h[t] = 0;
    int hi = 0;
    while(i &lt; qr) {
      int v = Q[i++];
      hi = h[v];
      hcnt[hi]++;
      if(exc[v] &gt; 0 &amp;&amp; v != t) {
        que[h[v]].emplace_back(v);
        inque.set(v);
      }
      for(int gi = G.iter[v]; gi &lt; G.iter[v + 1]; gi++) {
        auto&amp; e = G[gi];
        if(G[e.rev].cap &gt; 0 &amp;&amp; h[v] + 1 &lt; h[e.to]) {
          h[e.to] = h[v] + 1;
          Q[qr++] = e.to;
        }
      }
    }
    std::copy(std::begin(G.iter), std::begin(G.iter) + N, std::begin(ei));
    std::fill(std::begin(qi), std::end(qi), 0);
    return hi;
  }

  void gap_relabeling(int g) {
    for(int v = 0; v &lt; N; v++) {
      if(g &lt; h[v] &amp;&amp; h[v] &lt; N) {
        hcnt[h[v]]--;
        h[v] = N;
      }
    }
  }


  cap_type max_flow(int s, int t) {
    exc.assign(N, 0);
    exc[s] = INF;
    h.assign(N, 0);
    int cnt = 0;

    que.resize(N);
    qi.assign(N, 0);
    ei.resize(N);
    hcnt.assign(N + 1, 0);

    global_relabeling(t);

    if(h[s] == N) return 0;

    for(int di = h[s]; di &gt;= 0;) {
      if(qi[di] == que[di].size()) { di--; continue; }
      int v = que[di][qi[di]++];
      inque.reset(v);
      if(exc[v] == 0 || v == t) continue;
      for(int&amp; i = ei[v]; i &lt; G.iter[v + 1]; i++) {
        auto&amp; e = G[i];
        if(e.cap &gt; 0 &amp;&amp; h[v] == h[e.to] + 1) {
          push(v, i);
          if(exc[e.to] &gt; 0 &amp;&amp; e.to != t &amp;&amp; !inque.test(e.to)) {
            que[h[e.to]].emplace_back(e.to);
            inque.set(e.to);
          }
          if(exc[v] == 0) break;
        }
      }
      if(exc[v] == 0) continue;
      relabel(v);
      if(h[v] &lt; N) {
        di = h[v];
        que[h[v]].emplace_back(v);
        inque.set(v);
      }

      if(hcnt[di] == 0) {
        gap_relabeling(di);
        di--;
      }

      if(++cnt % (N * 4) == 0) {
        di = global_relabeling(t);
      }
    }
    return exc[t];
  }
};
#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;
#define rep(i,s,e) for(i64 (i) = (s);(i) &lt; (e);(i)++)
#define all(x) x.begin(),x.end()

template&lt;class T&gt;
static inline std::vector&lt;T&gt; ndvec(size_t&amp;&amp; n, T val) noexcept {
  return std::vector&lt;T&gt;(n, std::forward&lt;T&gt;(val));
}

template&lt;class... Tail&gt;
static inline auto ndvec(size_t&amp;&amp; n, Tail&amp;&amp;... tail) noexcept {
  return std::vector&lt;decltype(ndvec(std::forward&lt;Tail&gt;(tail)...))&gt;(n, ndvec(std::forward&lt;Tail&gt;(tail)...));
}

template&lt;class T, class Cond&gt;
struct chain {
  Cond cond; chain(Cond cond) : cond(cond) {}
  bool operator()(T&amp; a, const T&amp; b) const {
    if(cond(a, b)) { a = b; return true; }
    return false;
  }
};
template&lt;class T, class Cond&gt;
chain&lt;T, Cond&gt; make_chain(Cond cond) { return chain&lt;T, Cond&gt;(cond); }

#ifndef LOCAL
#define getchar getchar_unlocked
#endif

int getint() {
    char c;
    while (not isdigit(c = getchar()))
        ;
    int res = c - '0';
    while (isdigit(c = getchar())) res = res * 10 + (c - '0');
    return res;
}


int main() {
  int H = getint(), W = getint();

  goldberg_tarjan gt(H + W + 2);
  int s = H + W;
  int t = s + 1;
  vector&lt;i64&gt; A(H, 0);
  rep(i,0,H) rep(j,0,W) {
    int g = getint();
    A[i] += g;
    gt.add_edge(i, H + j, g);
  }
  i64 sum = 0;
  rep(i,0,H) {
    i64 r = getint();
    i64 MIN = std::min(A[i], r);
    sum += r - MIN;
    gt.add_edge(s, i, A[i] - MIN);
  }
  rep(i,0,W) {
    i64 r = getint();
    sum += r;
    gt.add_edge(H + i, t, r);
  }
  gt.build();
  cout &lt;&lt; sum - gt.max_flow(s, t) &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h1><a class="header" href="#successive-shortest-path" id="successive-shortest-path">Successive Shortest Path</a></h1>
<h2><a class="header" href="#code-58" id="code-58">Code</a></h2>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
using i64 = long long;

struct dinic {
  using capacity_type = i64;
  struct edge {
    i64 from;
    i64 to;
    capacity_type cap;
    capacity_type cost;
    i64 rev;
  };
  i64 n;
  i64 s, t;
  std::vector&lt;std::vector&lt;edge&gt;&gt; g;

  dinic(i64 n, i64 s, i64 t): n(n), s(s), t(t), g(n) {}
  void add_edge(i64 from, i64 to, i64 cap, i64 cost) {
    g[from].push_back({ from, to, cap, cost, (i64)(g[to].size()) });
    g[to].push_back({ to, from, 0, -cost, (i64)(g[from].size() - 1) });
  }
  std::vector&lt;int&gt; level;
  std::vector&lt;int&gt; iter;
  capacity_type dinic_dfs(int v, capacity_type f) {
    if(v == t) return f;
    else {
      capacity_type now = f;
      for(int&amp; i = iter[v]; i &lt; g[v].size(); i++) {
        auto&amp; e = g[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[e.to] &gt; level[e.from]) {
          capacity_type c = std::min(now , e.cap);
          capacity_type d = dinic_dfs(e.to, c);
          e.cap -= d;
          g[e.to][e.rev].cap += d;
          now -= d;
          if(now == 0) return f - now;
        }
      }
      return f - now;
    }
  }

  capacity_type min_cost_flow(capacity_type f) {
    std::vector&lt;capacity_type&gt; po(n,0);
    capacity_type ans = 0;
    auto sel = [&amp;](const edge&amp; e) {
      return e.cost + po[e.from] - po[e.to];
    };
    while(f &gt; 0) {
      std::vector&lt;capacity_type&gt; dist(n,0);
      std::vector&lt;bool&gt; vis(n,false);
      std::vector&lt;int&gt; p(n,-1);
      std::vector&lt;int&gt; pe(n,-1);
      using P = std::pair&lt;capacity_type,int&gt;;
      std::priority_queue&lt;P,std::vector&lt;P&gt;,std::greater&lt;P&gt;&gt; que;
      que.push({dist[s] ,s});
      vis[s] = true;
      while(!que.empty()) {
        int v = que.top().second;
        capacity_type d = que.top().first;
        que.pop();
        if(dist[v] &lt; d) continue;
        for(int i = 0;i &lt; g[v].size();i++) {
          auto&amp; e = g[v][i];
          int u = e.to;
          if(e.cap == 0) continue;
          if(!vis[u] || dist[u] &gt; dist[v] + sel(e)) {
            vis[u] = true;
            dist[u] = dist[v] + sel(e);
            p[u] = v;
            pe[u] = i;
            que.push({dist[u] , u});
          }
        }
      }
      if(p[t] == -1) break;

      capacity_type ff = f;
      for(int u = t;u != s;u = p[u])
        ff = std::min(ff, g[p[u]][pe[u]].cap);
      for(int u = t;u != s;u = p[u]) {
        ans += ff * g[p[u]][pe[u]].cost;
        g[p[u]][pe[u]].cap -= ff;
        g[u][g[p[u]][pe[u]].rev].cap += ff;
      }
      f -= ff;
      for(int i = 0;i &lt; n;i++)
        po[i] += dist[i];
    }
    if(f != 0) return -1;
    return ans;
  }
};

</code></pre>
<h1><a class="header" href="#successive-shortest-path-1" id="successive-shortest-path-1">Successive Shortest Path</a></h1>
<h2><a class="header" href="#code-59" id="code-59">Code</a></h2>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
using i64 = long long;

struct dinic {
  using capacity_type = i64;
  struct edge {
    i64 from;
    i64 to;
    capacity_type cap;
    capacity_type cost;
    i64 rev;
  };
  i64 n;
  i64 s, t;
  std::vector&lt;std::vector&lt;edge&gt;&gt; g;

  dinic(i64 n, i64 s, i64 t): n(n), s(s), t(t), g(n) {}
  void add_edge(i64 from, i64 to, i64 cap, i64 cost) {
    g[from].push_back({ from, to, cap, cost, (i64)(g[to].size()) });
    g[to].push_back({ to, from, 0, -cost, (i64)(g[from].size() - 1) });
  }
  std::vector&lt;int&gt; level;
  std::vector&lt;int&gt; iter;
  capacity_type dinic_dfs(int v, capacity_type f) {
    if(v == t) return f;
    else {
      capacity_type now = f;
      for(int&amp; i = iter[v]; i &lt; g[v].size(); i++) {
        auto&amp; e = g[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[e.to] &gt; level[e.from]) {
          capacity_type c = std::min(now , e.cap);
          capacity_type d = dinic_dfs(e.to, c);
          e.cap -= d;
          g[e.to][e.rev].cap += d;
          now -= d;
          if(now == 0) return f - now;
        }
      }
      return f - now;
    }
  }

  capacity_type min_cost_flow(capacity_type f) {
    std::vector&lt;capacity_type&gt; po(n,0);
    capacity_type ans = 0;
    auto sel = [&amp;](const edge&amp; e) {
      return e.cost + po[e.from] - po[e.to];
    };
    while(f &gt; 0) {
      std::vector&lt;capacity_type&gt; dist(n,0);
      std::vector&lt;bool&gt; vis(n,false);
      std::vector&lt;int&gt; p(n,-1);
      std::vector&lt;int&gt; pe(n,-1);
      using P = std::pair&lt;capacity_type,int&gt;;
      std::priority_queue&lt;P,std::vector&lt;P&gt;,std::greater&lt;P&gt;&gt; que;
      que.push({dist[s] ,s});
      vis[s] = true;
      while(!que.empty()) {
        int v = que.top().second;
        capacity_type d = que.top().first;
        que.pop();
        if(dist[v] &lt; d) continue;
        for(int i = 0;i &lt; g[v].size();i++) {
          auto&amp; e = g[v][i];
          int u = e.to;
          if(e.cap == 0) continue;
          if(!vis[u] || dist[u] &gt; dist[v] + sel(e)) {
            vis[u] = true;
            dist[u] = dist[v] + sel(e);
            p[u] = v;
            pe[u] = i;
            que.push({dist[u] , u});
          }
        }
      }
      if(p[t] == -1) break;

      capacity_type ff = f;
      for(int u = t;u != s;u = p[u])
        ff = std::min(ff, g[p[u]][pe[u]].cap);
      for(int u = t;u != s;u = p[u]) {
        ans += ff * g[p[u]][pe[u]].cost;
        g[p[u]][pe[u]].cap -= ff;
        g[u][g[p[u]][pe[u]].rev].cap += ff;
      }
      f -= ff;
      for(int i = 0;i &lt; n;i++)
        po[i] += dist[i];
    }
    if(f != 0) return -1;
    return ans;
  }
};

</code></pre>
<h1><a class="header" href="#strongly-connected-components" id="strongly-connected-components">Strongly Connected Components</a></h1>
<h2><a class="header" href="#code-60" id="code-60">Code</a></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

vector&lt;i64&gt; strongly_connected_components(const vector&lt;vector&lt;i64&gt;&gt;&amp; g) {
  i64 n = g.size();
  vector&lt;vector&lt;i64&gt;&gt; rg(n);
  for(int i = 0;i &lt; n;i++) {
    for(auto j: g[i]) {
      rg[j].push_back(i);
    }
  }

  vector&lt;bool&gt; vis(n,false);
  vector&lt;i64&gt; vs;
  vector&lt;i64&gt; res(n,-1);
  function&lt;void(int)&gt; dfs = [&amp;](int v) {
    vis[v] = true;
    for(auto&amp; t : g[v]) {
      if(!vis[t]) dfs(t);
    }
    vs.push_back(v);
  };

  function&lt;void(int,int)&gt; rdfs = [&amp;](int v,int k) {
    vis[v] = true;
    res[v] = k;
    for(auto to : rg[v]) {
      if(!vis[to]) rdfs(to,k);
    }
  };

  for(int i = 0;i &lt; n;i++) {
    if(!vis[i]) dfs(i);
  }

  vis.assign(n,false);
  int k = 0;
  for(int i = n - 1;i &gt;= 0;i--) {
    if(!vis[vs[i]]) rdfs(vs[i] , k++);
  }
  return res;
}
</code></pre>
<h1><a class="header" href="#incremental-bridge-connectivity" id="incremental-bridge-connectivity">Incremental Bridge Connectivity</a></h1>
<h2><a class="header" href="#code-61" id="code-61">Code</a></h2>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;tuple&gt;
#include &lt;bitset&gt;
#include &lt;iostream&gt;


struct union_find {
  std::vector&lt;int&gt; par;
  union_find(int N): par(N, -1) {}
  int root(int x) {
    return par[x] &lt; 0 ? x : par[x] = root(par[x]);
  }
  std::tuple&lt;int, int&gt; unite(int x, int y) {
    x = root(x);
    y = root(y);
    if(x == y) return std::make_tuple(x, y);
    if(par[x] &gt; par[y]) std::swap(x, y);
    par[x] += par[y];
    par[y] = x;
    return std::make_tuple(x, y);
  }
  int size(int x) {
    return -par[root(x)];
  }
};


struct incremental_bridge_connectivity {
  static const int MAX_N = 202020;
  static const int MAX_E = 202020;
  std::vector&lt;int&gt; par;
  std::vector&lt;std::pair&lt;int, int&gt;&gt; edge;
  std::bitset&lt;MAX_N&gt; bit;
  std::bitset&lt;MAX_E&gt; bridge;
  union_find cg;
  union_find bcg;

  incremental_bridge_connectivity(int N)
    : par(N, -1), cg(N), bcg(N) {
    }

  int lca(int u, int v) {
    bit = 0;
    while(1) {
      if(u &gt;= 0) {
        if(bit.test(u)) {
          return u;
        }
        bit.set(u);
        if(par[u] &lt; 0) u = -1;
        else u = edge[par[u]].second;
      }
      std::swap(u, v);
    }
  }

  void compress_path(int v, int w) {
    while(v != w) {
      bcg.unite(v, w);
      bridge.reset(par[v]);
      v = edge[par[v]].second;
    }
  }

  void reverse_path(int v, int p) {
    while(true) {
      std::swap(edge[p].first, edge[p].second);
      std::swap(p, par[v]);
      if(p &lt; 0) break;
      v = edge[p].second;
    }
  }

  int add_edge(int u, int v) {
    int ei = edge.size();
    edge.emplace_back(u, v);
    if(bcg.root(u) == bcg.root(v)) {
    }
    else if(cg.root(u) == cg.root(v)) {
      int w = lca(u, v);
      compress_path(u, w);
      compress_path(v, w);
    }
    else {
      bridge.set(ei);
      if(cg.size(u) &lt; cg.size(v)) {
        std::swap(u, v);
        std::swap(edge.back().first, edge.back().second);
      }
      reverse_path(v, ei);
      cg.unite(u, v);
    }
    return ei;
  }

  int size(int v) {
    return bcg.size(v);
  }

  bool is_bridge(int ei) {
    return bridge.test(ei);
  }
};

</code></pre>
<h1><a class="header" href="#lattice-graph" id="lattice-graph">Lattice Graph</a></h1>
<h3><a class="header" href="#code-62" id="code-62">Code</a></h3>
<pre><code class="language-cpp">#include &lt;set&gt;
#include &lt;vector&gt;
using i64 = long long;

template&lt;class F&gt;
struct lattice_delta {
  i64 H, W;
  F f;
  using P = std::pair&lt;i64, i64&gt;;
  lattice_delta(i64 H, i64 W, F f): H(H), W(W), f(f) {}
  template&lt;class Func&gt;
  void operator()(P v, Func func) {
    const static std::vector&lt;i64&gt; dx { 1, 0, -1, 0 };
    i64 i = v.first;
    i64 j = v.second;
    for(i64 q = 0; q &lt; 2; q++) {
      i64 x = i + dx[q];
      i64 y = j + dx[q ^ 1];
      if(0 &lt;= x &amp;&amp; x &lt; H &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; W) {
        f(P(i, j), P(x, y), func);
      }
    }
  }
};
 
template&lt;class F&gt;
lattice_delta&lt;F&gt; make_lattice_delta(i64 H, i64 W, F f) { return lattice_delta&lt;F&gt;(H, W, f); }
 
struct lattice_index {
  i64 H, W;
  using P = std::pair&lt;i64, i64&gt;;
  lattice_index(i64 H, i64 W): H(H), W(W) {}
  i64 operator()(P v) {
    return v.first * W + v.second;
  }
};
</code></pre>
<h1><a class="header" href="#geometry" id="geometry">Geometry</a></h1>
<p>昔作ったやつが残っていたのでとりあえず貼っておく 要整備</p>
<h3><a class="header" href="#spec-33" id="spec-33">Spec</a></h3>
<ul>
<li><code>Convex_Hull</code>
<ul>
<li>凸包</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-63" id="code-63">Code</a></h3>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;
using namespace std;

using ld = long double;

const ld EPS = 1e-8;
inline bool eq(ld a, ld b) { return abs(a - b) &lt; EPS; }
const ld PI = acos(-1);

namespace Geometory {
  struct Point {
    ld x, y;
    Point(ld x = 0, ld y = 0) : x(x), y(y) {}
    Point operator+(const Point&amp; b) const { return Point(x + b.x, y + b.y); }
    Point operator-(const Point&amp; b) const { return Point(x - b.x, y - b.y); }
    Point operator*(const ld b) const { return Point(x * b, y * b); }
    Point operator/(const ld b) const { return Point(x / b, y / b); }
    bool operator&lt;(const Point&amp; b) const {
      if (x != b.x)
        return x &lt; b.x;
      else
        return y &lt; b.y;
    }
    bool operator==(const Point&amp; b) const { return eq(x, b.x) &amp;&amp; eq(y, b.y); }
    ld norm() const { return x * x + y * y; }
    ld abs() const { return sqrt(norm()); }
    ld arg() const { return atan2(x, y); }
    Point rotate(const ld theta) const {
      ld co = cos(theta);
      ld si = sin(theta);
      return Point(co * x - si * y, si * x + y * co);
    }
    Point rotate90() const { return Point(-y, x); }
  };

  ld dot(const Point&amp; a, const Point&amp; b) { return a.x * b.x + a.y * b.y; }
  ld cross(const Point&amp; a, const Point b) { return a.x * b.y - a.y * b.x; }

  struct Line {
    Point from, to;
    Line(Point from = Point(), Point to = Point()) : from(from), to(to) {}
  };

  struct Segment {
    Point from, to;
    Segment(Point from = Point(), Point to = Point()) : from(from), to(to) {}
  };

  bool is_orthogonal(const Line&amp; la, const Line&amp; lb) {
    return eq(0.0, dot(la.from - la.to, lb.from - lb.from));
  }
  bool is_parallel(const Line&amp; la, const Line&amp; lb) {
    return eq(0.0, cross(la.from - la.to, lb.from - lb.from));
  }
  bool is_Point_on(const Line&amp; l, const Point&amp; p) {
    return eq(0.0, cross(l.to - l.from, p - l.from));
  }
  bool is_Point_on(const Segment&amp; s, const Point&amp; p) {
    return (s.from - p).abs() + (p - s.to).abs() &lt; (s.from - s.to).abs() + EPS;
  }
  ld distance(const Line&amp; l, const Point&amp; p) {
    return abs(cross(l.to - l.from, p - l.from)) / (l.to - l.from).abs();
  }
  ld distance(const Segment&amp; s, const Point&amp; p) {
    if (dot(s.to - s.from, p - s.from) &lt; EPS) return (p - s.from).abs();
    if (dot(s.from - s.to, p - s.to) &lt; EPS) return (p - s.to).abs();
    return abs(cross(s.to - s.from, p - s.from)) / (s.to - s.from).abs();
  }
  ld is_intersected(const Segment&amp; a, const Segment&amp; b) {
    return (cross(a.to - a.from, b.from - a.from) *
                cross(a.to - a.from, b.to - a.from) &lt;
            EPS) &amp;&amp;
           (cross(b.to - b.from, a.from - b.from) *
                cross(b.to - b.from, a.to - b.from) &lt;
            EPS);
  }

  ld is_intersected(const Segment&amp; s, const Line&amp; l) {
    // line -&gt; ax + by + c = 0
    ld a = l.to.y - l.from.y;
    ld b = l.from.x - l.to.x;
    ld c = -a * l.from.x - b * l.from.y;
    ld t1 = a * s.from.x + b * s.from.y + c;
    ld t2 = a * s.to.x + b * s.to.y + c;
    return t1 * t2 &lt;= 0;
  }

  Point intersection_point(const Segment&amp; a, const Segment&amp; b) {
    Point bp = b.to - b.from;
    ld d1 = abs(cross(bp, a.from - b.from));
    ld d2 = abs(cross(bp, a.to - b.from));
    ld t = d1 / (d1 + d2);
    return a.from + (a.to - a.from) * t;
  }

  Point intersection_point(const Line&amp; a, const Line&amp; b) {
    Point ap = a.to - a.from;
    Point bp = b.to - b.from;
    return a.from + ap * cross(bp, b.from - a.from) / cross(bp, ap);
  }
  // counterclockwise
  int ccw(const Point&amp; a, const Point&amp; b, const Point&amp; c) {
    Point ba = b - a;
    Point ca = c - a;
    if (cross(ba, ca) &gt; EPS) return 1;   // a - b --/ c
    if (cross(ba, ca) &lt; EPS) return -1;  // a - b --| c
    if (dot(ba, ca) &lt; 0) return 2;       // b - a - c
    if (b.norm() &lt; c.norm()) return -2;  // a - b - c
    return 0;                            // a -- c -- b
  }

  vector&lt;Point&gt; Convex_Hull(vector&lt;Point&gt;&amp; p) {
    int n = p.size();
    int k = 0;
    if (n &gt;= 3) {
      sort(p.begin(), p.end());
      vector&lt;Point&gt; ch(2 * n);
      for (int i = 0; i &lt; n; ch[k++] = p[i++]) {
        while (k &gt;= 2 &amp;&amp; cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) &lt; 0)
          k--;
      }
      for (int i = n - 2, t = k + 1; i &gt;= 0; ch[k++] = p[i--]) {
        while (k &gt;= t &amp;&amp; cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) &lt; 0)
          k--;
      }
      ch.resize(k - 1);
      return ch;
    } else {
      return p;
    }
  }
};
</code></pre>
<h1><a class="header" href="#tech" id="tech">Tech</a></h1>
<p>テクニック, 分類できなかったもの</p>
<h1><a class="header" href="#compression" id="compression">Compression</a></h1>
<p>座標圧縮をする.</p>
<h3><a class="header" href="#spec-34" id="spec-34">Spec</a></h3>
<ul>
<li>
<p><code>add(T x)</code></p>
<ul>
<li>要素<code>x</code>を追加する</li>
</ul>
</li>
<li>
<p><code>build()</code></p>
<ul>
<li>準備</li>
</ul>
</li>
<li>
<p><code>comp(T x)</code></p>
<ul>
<li>座圧した結果を返す</li>
</ul>
</li>
<li>
<p><code>comp(vector&lt;T&gt; x)</code></p>
<ul>
<li>まとめて座圧</li>
<li><code>x = comp(std::move(x))</code>すると楽です.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-64" id="code-64">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;

template&lt;class T&gt;
struct Compression {
  using size_type = std::size_t;

  std::vector&lt;T&gt; v;

  Compression(){}
  void add(const T&amp; t) { v.push_back(t); }
  void build() {
    sort(begin(v), end(v));
    v.erase(unique(begin(v), end(v)), end(v));
  }
  size_type comp(const T&amp; x) const {
    return lower_bound(begin(v), end(v), x) - begin(v);
  }
  size_type size() const { return v.size(); }
};
</code></pre>
<h1><a class="header" href="#grundy-number" id="grundy-number">Grundy Number</a></h1>
<h3><a class="header" href="#spec-35" id="spec-35">Spec</a></h3>
<ul>
<li><code>grn[(ゲームの状態)]</code>が<code>0</code> -&gt; その状態での手番の人が負ける</li>
<li><code>grn[(ゲームの状態)]</code>が<code>0</code>以外 -&gt; その状態での手番の人が勝つ</li>
</ul>
<h3><a class="header" href="#code-65" id="code-65">Code</a></h3>
<p>このコードでは, 取れる個数に制限がついているNimの勝敗を計算している.</p>
<pre><code class="language-cpp">/*
 N個の正整数からなる集合 A={a1,a2,…,aN}があります。 太郎君と次郎君が次のゲームで勝負します。

最初に、K個の石からなる山を用意します。 二人は次の操作を交互に行います。 先手は太郎君です。
Aの元 xをひとつ選び、山からちょうど x個の石を取り去る。
先に操作を行えなくなった人が負けです。 二人が最適に行動すると仮定したとき、どちらが勝つかを判定してください。
*/

#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

vector&lt;i64&gt; grn(101010, -1);

i64 N, K;
vector&lt;i64&gt; a;

int main() {
  cin &gt;&gt; N &gt;&gt; K;
  a.resize(N);
  for(int i = 0;i &lt; N;i++) cin &gt;&gt; a[i];
  for(i64 k = 0;k &lt;= K;k++) {
    set&lt;i64&gt; st;
    for(auto x: a) {
      if(k - x &gt;= 0) st.insert(grn[k - x]);
    }
    grn[k] = K + 1;
    for(int i = 0;i &lt;= K + 1;i++) {
      if(!st.count(i)) {
        grn[k] = i;
        break;
      }
    }
  }
  if(grn[K]) {
    cout &lt;&lt; &quot;First&quot; &lt;&lt; endl;
  }
  else {
    cout &lt;&lt; &quot;Second&quot; &lt;&lt; endl;
  }
}
</code></pre>
<h1><a class="header" href="#monge-dp" id="monge-dp">Monge DP</a></h1>
<h1><a class="header" href="#mos-algorithm" id="mos-algorithm">Mo's Algorithm</a></h1>
<p>もーもー</p>
<h3><a class="header" href="#code-66" id="code-66">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;
#define rep(i,s,e) for(i64 (i) = (s);(i) &lt; (e);(i)++)
#define rev(i,s,e) for(i64 (i) = (e); (i)-- &gt; (s);)
#define all(x) x.begin(),x.end()

struct Mo {
  vector&lt;i64&gt; left, right, order;
  vector&lt;bool&gt; v;
  

  const i64 width;
  i64 nl, nr, ptr;

  vector&lt;i64&gt; a;
  vector&lt;i64&gt; cnt;
  i64 ans;

  Mo(i64 n, vector&lt;i64&gt; a) : v(n), width((i64)sqrt(n)), nl(0), nr(0), ptr(0), a(a), cnt(1010101), ans(0) {}

  void add_query(i64 l, i64 r) {
    left.push_back(l);
    right.push_back(r);
  }

  void build() {
    order.resize(left.size());
    for(i64 i = 0;i &lt; left.size();i++) order[i] = i;
    sort(begin(order), end(order), [&amp;](i64 a, i64 b) {
        if(left[a] / width != left[b] / width) return left[a] &lt; left[b];
        else return right[a] &lt; right[b];
        });
  }


  void add(i64 idx) {
    if(cnt[a[idx]]++ == 0) ans++;
  }
  void del(i64 idx) {
    if(--cnt[a[idx]] == 0) ans--;
  }

  inline void distribute(i64 idx) {
    v[idx].flip();
    if(v[idx]) add(idx);
    else del(idx);
  }

  i64 process() {
    if(ptr == order.size()) return -1;
    const auto id = order[ptr];
    while(nl &gt; left[id]) distribute(--nl);
    while(nr &lt; right[id]) distribute(nr++);
    while(nl &lt; left[id]) distribute(nl++);
    while(nr &gt; right[id]) distribute(--nr);
    return order[ptr++];
  }
};
</code></pre>
<h1><a class="header" href="#slide-min" id="slide-min">Slide Min</a></h1>
<h1><a class="header" href="#fastio" id="fastio">FastIO</a></h1>
<h3><a class="header" href="#spec-36" id="spec-36">Spec</a></h3>
<h3><a class="header" href="#code-67" id="code-67">Code</a></h3>
<pre><code class="language-cpp">#include &lt;unistd.h&gt;

namespace niu {

  struct fastin {
    static const int bufsize = 1 &lt;&lt; 24;
    char buf[bufsize];
    char* iter;
    fastin() {
      iter = buf;
      for(int t = 0, k; (k = read(STDIN_FILENO, buf + t, sizeof(buf)) - t) &gt; 0; t += k);
    }
    fastin&amp; operator&gt;&gt;(int&amp; num) {
      num = 0;
      bool neg = false;
      while(*iter &lt; '+') iter++;
      if(*iter == '-') { neg = true; iter++; }
      else if(*iter == '+') iter++;
      while(*iter &gt;= '0') num = 10 * num + *(iter++) - '0';
      if(neg) num = -num;
      return *this;
    } 
  } fin;
  struct fastout {
    static const int bufsize = 1 &lt;&lt; 24;
    char buf[bufsize];
    char* iter;
    fastout() {
      iter = buf;
    }
    ~fastout() {
      for(int t = 0, k; (k = write(STDOUT_FILENO, buf + t, iter - buf - t)) &gt; 0; t += k);
    }
    fastout&amp; operator&lt;&lt;(int num) {
      static char tmp[20];
      if(num == 0) {
        *(iter++) = '0';
        return *this;
      }
      if(num &lt; 0) {
        *(iter++) = '-';
        num = -num;
      }
      int i = 0;
      while(num) {
        tmp[i++] = num % 10;
        num /= 10;
      }
      while(i--) {
        *(iter++) = tmp[i] + '0';
      }
      return *this;
    }
    fastout&amp; operator&lt;&lt;(char c) {
      *(iter++) = c;
      return *this;
    }
  } fout;
}
</code></pre>
<h1><a class="header" href="#rerooting" id="rerooting">Rerooting</a></h1>
<h3><a class="header" href="#code-68" id="code-68">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
 
template&lt;class T, class E, class U, class To, class Adj, class Ope, class Merge&gt;
std::vector&lt;T&gt; rerooting(const std::vector&lt;std::vector&lt;E&gt;&gt;&amp; G, int r, U ide, To to, Adj adj, Ope ope, Merge merge) {
  int N = G.size();
  std::vector&lt;T&gt; tdp(N);
  std::vector&lt;int&gt; par(N, -1);
  std::vector&lt;int&gt; que(N);
  int qi = 0;
  que[qi++] = r;
 
  int MAX = 1;
  for(int i = 0;i &lt; qi;i++) {
    int v = que[i];
    for(const auto&amp; e: G[v]) {
      int t = to(e);
      if(t == par[v]) continue;
      par[t] = v;
      que[qi++] = t;
    }
    MAX = std::max(MAX, (int)G[v].size() + 1);
  }
 
  for(int i = qi; i --&gt; 0;) {
    int v = que[i];
    U sum = ide;
    for(const auto&amp; e : G[v]) {
      int t = to(e);
      if(t == par[v]) continue;
      sum = ope(sum, adj(tdp[t], e));
    }
    tdp[v] = merge(sum, v);
  }
 
  std::vector&lt;U&gt; f(MAX);
  std::vector&lt;U&gt; b(MAX);
 
  for(int i = 0; i &lt; qi; i++) {
    int v = que[i];
    for(int j = 0;j &lt; G[v].size();j++) {
      int t = to(G[v][j]);
      f[j + 1] = adj(tdp[t == par[v] ? v : t], G[v][j]);
    }
    b[G[v].size()] = ide;
    for(int j = G[v].size(); j --&gt; 0;) b[j] = ope(f[j + 1], b[j + 1]);
    f[0] = ide;
    for(int j = 0;j &lt; G[v].size(); j++) {
      int t = to(G[v][j]);
      f[j + 1] = ope(f[j], f[j + 1]);
      if(t != par[v]) {
        tdp[t] = merge(ope(f[j], b[j + 1]), v);
      }
    }
    tdp[v] = merge(f[G[v].size()], v);
  }
  return tdp;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-157596444-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
