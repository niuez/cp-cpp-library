<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>cp-cpp-library Document</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/index.html"><strong aria-hidden="true">1.1.</strong> Data Structures</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/segment_tree/index.html"><strong aria-hidden="true">1.1.1.</strong> Segment Trees</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/segment_tree/segment_tree.html"><strong aria-hidden="true">1.1.1.1.</strong> Segment Tree</a></li><li class="expanded "><a href="data_structures/segment_tree/lazy_segment_tree.html"><strong aria-hidden="true">1.1.1.2.</strong> Lazy Segment Tree</a></li><li class="expanded "><a href="data_structures/segment_tree/persistent_segment_tree.html"><strong aria-hidden="true">1.1.1.3.</strong> Persistent Segment Tree</a></li><li class="expanded "><a href="data_structures/segment_tree/dynamic_segment_tree.html"><strong aria-hidden="true">1.1.1.4.</strong> Dynamic Segment Tree</a></li><li class="expanded "><a href="data_structures/segment_tree/li_chao.html"><strong aria-hidden="true">1.1.1.5.</strong> Li-Chao Segment Tree</a></li></ol></li><li class="expanded "><a href="data_structures/trees/index.html"><strong aria-hidden="true">1.1.2.</strong> Trees</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/trees/euler_tour_subtree.html"><strong aria-hidden="true">1.1.2.1.</strong> EulerTour Subtree</a></li><li class="expanded "><a href="data_structures/trees/euler_tour_path.html"><strong aria-hidden="true">1.1.2.2.</strong> EulerTour Path</a></li><li class="expanded "><a href="data_structures/trees/link_cut_tree.html"><strong aria-hidden="true">1.1.2.3.</strong> Link Cut Tree</a></li></ol></li><li class="expanded "><a href="data_structures/union_find/index.html"><strong aria-hidden="true">1.1.3.</strong> Union Find</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/union_find/union_find.html"><strong aria-hidden="true">1.1.3.1.</strong> Union Find</a></li><li class="expanded "><a href="data_structures/union_find/persistent_union_find.html"><strong aria-hidden="true">1.1.3.2.</strong> Persistent Union Find</a></li></ol></li><li class="expanded "><a href="data_structures/bbst/index.html"><strong aria-hidden="true">1.1.4.</strong> self-Balancing Binary Search Trees</a></li><li><ol class="section"><li class="expanded "><a href="data_structures/bbst/splay_tree_array.html"><strong aria-hidden="true">1.1.4.1.</strong> Splay Tree Array</a></li><li class="expanded "><a href="data_structures/bbst/splay_tree_map.html"><strong aria-hidden="true">1.1.4.2.</strong> Splay Tree Map</a></li></ol></li></ol></li><li class="expanded "><a href="math/index.html"><strong aria-hidden="true">1.2.</strong> Math</a></li><li><ol class="section"><li class="expanded "><a href="math/modint.html"><strong aria-hidden="true">1.2.1.</strong> modint</a></li><li class="expanded "><a href="math/matrix.html"><strong aria-hidden="true">1.2.2.</strong> Matrix</a></li><li class="expanded "><a href="math/garner.html"><strong aria-hidden="true">1.2.3.</strong> Garner's Algorithm</a></li><li class="expanded "><a href="math/polynomial.html"><strong aria-hidden="true">1.2.4.</strong> Polynomial</a></li><li class="expanded "><a href="math/runtime_fp.html"><strong aria-hidden="true">1.2.5.</strong> Runtime fp</a></li><li class="expanded "><a href="math/convolution/index.html"><strong aria-hidden="true">1.2.6.</strong> Convolution</a></li><li><ol class="section"><li class="expanded "><a href="math/convolution/multiple_transform.html"><strong aria-hidden="true">1.2.6.1.</strong> Multiple Transform</a></li><li class="expanded "><a href="math/convolution/divisor_transform.html"><strong aria-hidden="true">1.2.6.2.</strong> Divisor Transform</a></li><li class="expanded "><a href="math/convolution/fast_fourier_transform.html"><strong aria-hidden="true">1.2.6.3.</strong> Fast Fourier Transform</a></li><li class="expanded "><a href="math/convolution/numeric_theoretic_transform.html"><strong aria-hidden="true">1.2.6.4.</strong> Number Theoretic Transform</a></li></ol></li></ol></li><li class="expanded "><a href="string/index.html"><strong aria-hidden="true">1.3.</strong> String</a></li><li><ol class="section"><li class="expanded "><a href="string/manacher.html"><strong aria-hidden="true">1.3.1.</strong> Manacher</a></li><li class="expanded "><a href="string/mp.html"><strong aria-hidden="true">1.3.2.</strong> MP (Morris Pratt)</a></li><li class="expanded "><a href="string/rolling_hash.html"><strong aria-hidden="true">1.3.3.</strong> Rolling Hash</a></li><li class="expanded "><a href="string/suffix_array.html"><strong aria-hidden="true">1.3.4.</strong> Suffix Array</a></li><li class="expanded "><a href="string/Z-algorithm.html"><strong aria-hidden="true">1.3.5.</strong> Z-algorithm</a></li></ol></li><li class="expanded "><a href="graph/index.html"><strong aria-hidden="true">1.4.</strong> Graph</a></li><li><ol class="section"><li class="expanded "><a href="graph/low_link.html"><strong aria-hidden="true">1.4.1.</strong> Low Link</a></li><li class="expanded "><a href="graph/strongly_connected_components.html"><strong aria-hidden="true">1.4.2.</strong> Strongly Connected Components</a></li><li class="expanded "><a href="graph/two_edge_connected.html"><strong aria-hidden="true">1.4.3.</strong> Two Edge Connected</a></li><li class="expanded "><a href="graph/two_vertex_connected.html"><strong aria-hidden="true">1.4.4.</strong> Two Vertex Connected</a></li></ol></li><li class="expanded "><a href="geometry/geometry.html"><strong aria-hidden="true">1.5.</strong> Geometry</a></li><li class="expanded "><a href="other/index.html"><strong aria-hidden="true">1.6.</strong> Other</a></li><li><ol class="section"><li class="expanded "><a href="other/grundy.html"><strong aria-hidden="true">1.6.1.</strong> Grundy Number</a></li><li class="expanded "><a href="other/mongeDP.html"><strong aria-hidden="true">1.6.2.</strong> Monge DP</a></li><li class="expanded "><a href="other/slide_min.html"><strong aria-hidden="true">1.6.3.</strong> Slide Min</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">cp-cpp-library Document</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>ここに競技プログラミング用のC++のライブラリをおいていきたい</p>
<h1><a class="header" href="#data-structures" id="data-structures">Data Structures</a></h1>
<p>いろいろ, あるよね</p>
<h1><a class="header" href="#segment-trees" id="segment-trees">Segment Trees</a></h1>
<ul>
<li>
<p><a href="data_structures/segment_tree/./segment_tree.html">Segment Tree</a></p>
</li>
<li>
<p><a href="data_structures/segment_tree/./lazy_segment_tree.html">Lazy Segment Tree</a></p>
</li>
<li>
<p><a href="data_structures/segment_tree/./persistent_segment_tree.html">Persistent Segment Tree</a></p>
</li>
<li>
<p><a href="data_structures/segment_tree/./dynamic_segment_tree.html">Dynamic Segment Tree</a></p>
</li>
<li>
<p><a href="data_structures/segment_tree/./li_chao.html">Li-Chao Segment Tree</a></p>
</li>
</ul>
<h1><a class="header" href="#segment-tree" id="segment-tree">Segment Tree</a></h1>
<h3><a class="header" href="#spec" id="spec">Spec</a></h3>
<ul>
<li>
<p><code>using T = ...</code></p>
<ul>
<li>Segment Treeに載せる型</li>
</ul>
</li>
<li>
<p><code>T ope(const T&amp; a, const T&amp; b)</code></p>
<ul>
<li>Tの演算を指定する</li>
</ul>
</li>
<li>
<p><code>T ide()</code></p>
<ul>
<li>Tの単位元を返す</li>
</ul>
</li>
<li>
<p><code>segment_tree(vector&lt;T&gt; init)</code></p>
<ul>
<li><code>init</code>からSegment Treeを構築する</li>
<li>\( O(n) \)</li>
</ul>
</li>
<li>
<p><code>update(i64 i, T x)</code></p>
<ul>
<li><code>i</code>番目の要素を<code>x</code>にする</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
<li>
<p><code>sum(i64 l, i64 r)</code></p>
<ul>
<li><code>[l, r)</code>の総和を求める</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code" id="code">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;
 
struct segment_tree {
  using T = i64;
  static T ope(const T&amp; a, const T&amp; b) {
    return max(a, b);
  }
  static T ide() { return -1e18; }
 
  i64 n;
  vector&lt;T&gt; node;
 
  segment_tree(const vector&lt;T&gt;&amp; init) {
    n = 1;
    while(n &lt; init.size()) n *= 2;
    node.resize(2 * n);
    for(int i = 0;i &lt; init.size();i++) node[i + n] = init[i];
    for(int i = n - 1; i &gt;= 1;i--) node[i] = ope(node[i * 2], node[i * 2 + 1]);
  }
 
  void update(i64 i, T x) {
    i += n;
    node[i] = x;
    while(i &gt; 1) {
      i = i / 2;
      node[i] = ope(node[i * 2], node[i * 2 + 1]);
    }
  }
  
  /* [l, r) */
  T sum(i64 l, i64 r) {
    T lx = ide();
    T rx = ide();
    l += n;
    r += n - 1;
    while(l &lt; r) {
      if(l &amp; 1) { lx = ope(lx, node[l]); }
      if(!(r &amp; 1)) { rx = ope(node[r], rx); }
      l = (l + 1) &gt;&gt; 1;
      r = (r - 1) &gt;&gt; 1;
    }
    if(l == r) { lx = ope(lx, node[l]); }
    return ope(lx, rx);
  }
};
</code></pre>
<h1><a class="header" href="#lazy-segment-tree" id="lazy-segment-tree">Lazy Segment Tree</a></h1>
<h3><a class="header" href="#spec-1" id="spec-1">Spec</a></h3>
<ul>
<li>
<p><code>using T = ...</code></p>
<ul>
<li>Segment Treeに載せる型</li>
</ul>
</li>
<li>
<p><code>using L = ...</code></p>
<ul>
<li>遅延伝搬させる作用素</li>
</ul>
</li>
<li>
<p><code>T t_ide()</code></p>
<ul>
<li>Tの単位元を返す</li>
</ul>
</li>
<li>
<p><code>L l_ide()</code></p>
<ul>
<li>Lの単位元を返す</li>
</ul>
</li>
<li>
<p><code>T ope(const T&amp; a, const T&amp; b)</code></p>
<ul>
<li>Tの演算を指定する</li>
</ul>
</li>
<li>
<p><code>L lazy_ope(const L&amp; a, const L&amp; b)</code></p>
<ul>
<li>Tの演算を指定する</li>
</ul>
</li>
<li>
<p><code>T effect(const T&amp; t, const L&amp; l, const i64 len)</code></p>
<ul>
<li>長さ<code>len</code>の区間の総和<code>t</code>に作用<code>l</code>をする</li>
</ul>
</li>
<li>
<p><code>lazy_segment_tree(const vector&lt;T&gt;&amp; init)</code></p>
<ul>
<li><code>init</code>からLazy Segment Treeを構築する</li>
<li>\( O(n) \)</li>
</ul>
</li>
<li>
<p><code>update(i64 a, i64 b, L lx)</code></p>
<ul>
<li><code>[a, b)</code>番目の要素に作用<code>lx</code>をする</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
<li>
<p><code>sum(i64 a, i64 b)</code></p>
<ul>
<li><code>[a, b)</code>の総和を求める</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-1" id="code-1">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct lazy_segment_tree {
  using T = i64;
  using L = pair&lt;i64, i64&gt;;
  static T t_ide() { return 0; }
  static L l_ide() { return {0, 0}; }
  static T ope(const T&amp; a, const T&amp; b) { return a + b; }
  static L lazy_ope(const L&amp; a, const L&amp; b) { return { a.first + b.first, a.second + b.second }; }
  static T effect(const T&amp; t, const L&amp; l, const i64 len) { return t + l.first * len; }

  i64 n;
  vector&lt;T&gt; node;
  vector&lt;L&gt; lazy;
  vector&lt;bool&gt; flag;

  /* create lazy_segment_tree for sequence [t_ide; sz]A */
  lazy_segment_tree(const vector&lt;T&gt;&amp; init) {
    n = 1;
    while(n &lt; init.size()) n *= 2;
    node.resize(2 * n - 1);
    lazy.resize(2 * n - 1);
    flag.resize(2 * n - 1);
    for(int i = 0;i &lt; init.size();i++) node[i + n - 1] = init[i];
    for(int i = n - 2; i &gt;= 0;i--) node[i] = ope(node[i * 2 + 1], node[i * 2 + 2]);
  }
  

  void eval(i64 l, i64 r, i64 k) {
    if(flag[k]) {
      node[k] = effect(node[k], lazy[k], r - l);
      
      if(r - l &gt; 1) {
        lazy[k * 2 + 1] = lazy_ope(lazy[k * 2 + 1], lazy[k]);
        flag[k * 2 + 1] = true;
        lazy[k * 2 + 2] = lazy_ope(lazy[k * 2 + 2], lazy[k]);
        flag[k * 2 + 2] = true;
      }

      flag[k] = false;
      lazy[k] = l_ide();
    }
  }
  
  /* for i in [a, b) effect(a[i], lx) */
  void update(i64 a, i64 b, L lx, i64 l = 0, i64 r = -1, i64 k = 0) {
    if(r &lt; 0) r = n;
    eval(l, r, k);
    if(b &lt;= l || r &lt;= a) return;
    else if(a &lt;= l &amp;&amp; r &lt;= b) {
      lazy[k] = lazy_ope(lazy[k], lx);
      flag[k] = true;
      eval(l, r, k);
    }
    else {
      update(a, b, lx, l, (l + r) / 2, k * 2 + 1);
      update(a, b, lx, (l + r) / 2, r, k * 2 + 2);
      node[k] =ope(node[k * 2 + 1], node[k * 2 + 2]);
    }
  }
  
  /* the sum of a[i] for i in [a, b) */
  T sum(i64 a, i64 b, i64 l = 0, i64 r = -1, i64 k = 0) {
    if(r &lt; 0) r = n;
    eval(l, r, k);
    if(b &lt;= l || r &lt;= a) return t_ide();
    else if(a &lt;= l &amp;&amp; r &lt;= b) return node[k];
    else return ope(sum(a, b, l, (l + r) / 2, k * 2 + 1), sum(a, b, (l + r) / 2, r, k * 2 + 2));
  }
};
</code></pre>
<h1><a class="header" href="#persistent-segment-tree" id="persistent-segment-tree">Persistent Segment Tree</a></h1>
<h3><a class="header" href="#spec-2" id="spec-2">Spec</a></h3>
<ul>
<li>
<p><code>using T = ...</code></p>
<ul>
<li>Segment Treeに載せる型</li>
</ul>
</li>
<li>
<p><code>T ope(const T&amp; a, const T&amp; b)</code></p>
<ul>
<li>Tの演算を指定する</li>
</ul>
</li>
<li>
<p><code>T ide()</code></p>
<ul>
<li>Tの単位元を返す</li>
</ul>
</li>
<li>
<p><code>persistent_segment_tree(vector&lt;T&gt; init)</code></p>
<ul>
<li><code>init</code>からPersistent Segment Treeを構築する</li>
<li>\( O(n) \)</li>
</ul>
</li>
<li>
<p><code>update(i64 i, T x)</code></p>
<ul>
<li><code>i</code>番目の要素を<code>x</code>にしたSegment Treeを返す.</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
<li>
<p><code>sum(i64 l, i64 r)</code></p>
<ul>
<li><code>[l, r)</code>の総和を求める</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-2" id="code-2">Code</a></h3>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
using namespace std;
using i64 = long long;

struct persistent_segment_tree {
  using T = pair&lt;i64, i64&gt;;
  struct node {
    using Ptr = node*;
    T data;
    Ptr left;
    Ptr right;
    
    node(T data): data(data), left(), right() {}
    node(T data, Ptr left, Ptr right)
      : data(data), left(left), right(right) {}
  };

  using Ptr = node*;

  static T ope(const T&amp; a, const T&amp; b) { return std::min(a, b); }
  static T ide() { return {(i64)(1e18), (i64)(1e18)}; }

  Ptr root;
  i64 N;

  static Ptr build(i64 l, i64 r, const vector&lt;T&gt;&amp; init) {
    if(l + 1 &gt;= r) return new node(init[l]);
    else {
      Ptr le = build(l , (l + r) / 2, init);
      Ptr ri = build((l + r) / 2, r, init);
      T da = ope(le-&gt;data, ri-&gt;data);
      return new node(da, le, ri);
    }
  }

  static Ptr update(Ptr node, i64 i, T val, i64 l, i64 r) {
    if(i == l &amp;&amp; i + 1 == r) return new struct node(val);
    Ptr left = nullptr;
    Ptr right = nullptr;
    if(l &lt;= i &amp;&amp; i &lt; ((l + r) &gt;&gt; 1)) {
      left = update(node-&gt;left, i, val, l, (l + r) &gt;&gt; 1);
      right = node-&gt;right;
    }
    else {
      left = node-&gt;left;
      right = update(node-&gt;right, i, val, (l + r) &gt;&gt; 1, r);
    }
    return new struct node(ope(left-&gt;data, right-&gt;data), left, right);
  }

  static T sum(Ptr node, i64 a, i64 b, i64 l, i64 r) {
    if(b &lt;= l || r &lt;= a) return ide();
    else if(a &lt;= l &amp;&amp; r &lt;= b) return node-&gt;data;
    else return ope(
        sum(node-&gt;left, a, b, l, (l + r) &gt;&gt; 1),
        sum(node-&gt;right, a, b, (l + r) &gt;&gt; 1, r)
        );
  }

  persistent_segment_tree(const vector&lt;T&gt;&amp; init)
    : root(build(0, init.size(), init)), N(init.size()) {}
  persistent_segment_tree(Ptr root, i64 N): root(root), N(N) {}
  persistent_segment_tree update(i64 i, T x) const {
    return persistent_segment_tree(update(root, i, x, 0, N), N);
  }
  T sum(i64 l, i64 r) { return sum(root, l, r, 0, N); }
};
</code></pre>
<h1><a class="header" href="#dynamic-segment-tree" id="dynamic-segment-tree">Dynamic Segment Tree</a></h1>
<h3><a class="header" href="#spec-3" id="spec-3">Spec</a></h3>
<ul>
<li>
<p><code>using T = ...</code></p>
<ul>
<li>Dynamic Segment Treeに載せる型</li>
</ul>
</li>
<li>
<p><code>T ope(const T&amp; a, const T&amp; b)</code></p>
<ul>
<li>Tの演算を指定する</li>
</ul>
</li>
<li>
<p><code>T ide()</code></p>
<ul>
<li>Tの単位元を返す</li>
</ul>
</li>
<li>
<p><code>dynamic_segment_tree(const i64 n)</code></p>
<ul>
<li><code>[ide; n]</code>の列を扱うDynamic Segment Treeを構築する</li>
<li>\( O(1) \)</li>
</ul>
</li>
<li>
<p><code>update(i64 i, T x)</code></p>
<ul>
<li><code>i</code>番目の要素を<code>x</code>にする</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
<li>
<p><code>sum(i64 l, i64 r)</code></p>
<ul>
<li><code>[l, r)</code>の総和を求める</li>
<li>\( O(\log n) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-3" id="code-3">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct dynamic_segment_tree {
  using T = i64;
  static T ide() { return 0ll; }
  static T ope(const T&amp; a, const T&amp; b) { return a + b; }

  struct node {
    node* left;
    node* right;
    T val;
    node(T v): val(v), left(nullptr), right(nullptr) {}
  };

  i64 n;
  node* root;
  dynamic_segment_tree(const i64 sz): root(new node(ide())) {
    n = 1;
    while(n &lt; sz) n *= 2;
  }
  T value(node* n) {
    if(n) return n-&gt;val;
    else return ide();
  }
  void update(node* n, i64 i, T x, i64 l, i64 r) {
    if(l + 1 == r) {
      n-&gt;val = x;
    }
    else {
      i64 m = (l + r) / 2;
      if(i &lt; m) {
        if(!n-&gt;left) {
          n-&gt;left = new node(ide());
        }
        update(n-&gt;left, i, x, l, m);
      }
      else {
        if(!n-&gt;right) {
          n-&gt;right = new node(ide());
        }
        update(n-&gt;right, i, x, m, r);
      }
      n-&gt;val = ope(value(n-&gt;left), value(n-&gt;right));
    }
  }

  T get(node* n, i64 a, i64 b, i64 l, i64 r) {
    if(!n) return ide();
    if(a &lt;= l &amp;&amp; r &lt;= b) return value(n);
    else if(r &lt;= a || b &lt;= l) return ide();
    else return ope(get(n-&gt;left, a, b, l, (l + r) / 2), get(n-&gt;right, a, b, (l + r) / 2, r));
  }

  void update(i64 i, T x) {
    update(root, i, x, 0, n);
  }

  T sum(i64 a, i64 b) {
    return get(root, a, b, 0, n);
  }
};
</code></pre>
<h1><a class="header" href="#li-chao-segment-tree" id="li-chao-segment-tree">Li-Chao Segment Tree</a></h1>
<h3><a class="header" href="#spec-4" id="spec-4">Spec</a></h3>
<ul>
<li>
<p>template argments</p>
<ul>
<li><code>class T</code>
<ul>
<li>Li-Chao Segment Treeで扱う型</li>
<li><code>+, *, /</code>, 比較ができる必要がある</li>
</ul>
</li>
<li><code>const T ide</code>
<ul>
<li>Tの単位元(?)</li>
<li>例えば, 最大値を返すLiChaoなら小さい数を入れておく</li>
</ul>
</li>
<li><code>class Compare = greater&lt;T&gt;</code>
<ul>
<li>最大値or最小値</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>li_chao(T mi, T, ma)</code></p>
<ul>
<li><code>[mi, ma]</code>の間の範囲を管理するLiChaoを構築する.</li>
</ul>
</li>
<li>
<p><code>void add_line(T a, T b)</code></p>
<ul>
<li><code>a * x + b</code>の直線を追加する</li>
<li>\( O(\log L) \)</li>
</ul>
</li>
<li>
<p><code>T get(T x)</code></p>
<ul>
<li><code>max{a_i * x + b_i}</code>を返す(Compareで<code>min</code>に変えられる)</li>
<li>\( O(\log L) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-4" id="code-4">Code</a></h3>
<pre><code class="language-cpp">#include &lt;functional&gt;
using namespace std;
template&lt;class T,const T ide,class Compare = greater&lt;T&gt;&gt;
struct li_chao{
  struct Line{
    T a,b;
    Line(T a = 0,T b = 0) : a(a) , b(b) {}
    T get(T x){return a * x + b;}
  };
 
  struct Node{
    Line line;
    Node *lhs,*rhs;
    Node(Line l) : line(l) , lhs(nullptr) , rhs(nullptr){}
  };
 
  const T MI,MA;
 
  Node * root;
 
  Compare comp;
 
  T comp_get(const T &amp; x,const T &amp; y){
    if(comp(x , y)) return x;
    else return y;
  }
 
  li_chao(T mi , T ma) : MI(mi), MA(ma) , root(nullptr){}
 
  Node * insert(Node * p,T l,T r,Line &amp; line){
    if(!p) return new Node(line);
    if(comp(p-&gt;line.get(l) , line.get(l)) &amp;&amp; comp(p-&gt;line.get(r) ,line.get(r))){
      return p;
    }
    if(!comp(p-&gt;line.get(l) , line.get(l)) &amp;&amp; !comp(p-&gt;line.get(r) ,line.get(r))){
      p-&gt;line = line;
      return p;
    }
    T mid = (l + r) / 2;
    if(comp(line.get(mid) , p-&gt;line.get(mid))) swap(p-&gt;line , line);
    if(comp(line.get(l) , p-&gt;line.get(l))){
      p-&gt;lhs = insert(p-&gt;lhs , l , mid , line);
    }
    else{
      p-&gt;rhs = insert(p-&gt;rhs , mid, r , line);
    }
    return p;
  }
 
  void add_line(T a,T b){
    Line l(a , b);
    root = insert(root,MI,MA,l);
  }
 
  T get(Node * p,T l,T r,T t){
    if(!p) return ide;
    T mid = (l + r) / 2;
    if(t &lt;= mid) return comp_get(p-&gt;line.get(t) , get(p-&gt;lhs , l, mid,t));
    else return comp_get(p-&gt;line.get(t),get(p-&gt;rhs,mid ,r , t));
  }
 
  T get(T x){
    return get(root,MI,MA,x);
  }
};
</code></pre>
<h1><a class="header" href="#trees" id="trees">Trees</a></h1>
<p>木を処理するやつ</p>
<ul>
<li><a href="data_structures/trees/./euler_tour_subtree.html">EulerTour Subtree</a></li>
<li><a href="data_structures/trees/./euler_tour_path.html">EulerTour Path</a></li>
<li><a href="data_structures/trees/./link_cut_tree.html">Link Cut Tree</a></li>
</ul>
<h1><a class="header" href="#eulertour-subtree" id="eulertour-subtree">EulerTour Subtree</a></h1>
<p>EulerTourの部分木を処理するバージョン<br />
木を列に落とし込んだときの部分木の範囲がわかるので, <a href="data_structures/trees/../segment_tree/segment_tree.html">Segment Tree</a>と合わせて使うといい.</p>
<p>LCAをET Subtree + RMQで求める場合はコメントアウトしてある部分を使う.</p>
<h3><a class="header" href="#spec-5" id="spec-5">Spec</a></h3>
<ul>
<li>
<p><code>eulertour_subtree(i64 n)</code></p>
<ul>
<li><code>n</code>頂点の木を構築する準備</li>
</ul>
</li>
<li>
<p><code>add_edge(i64 u, i64 v)</code></p>
<ul>
<li>頂点<code>u</code>と<code>v</code>を結ぶ辺を追加する</li>
</ul>
</li>
<li>
<p><code>start_tour(i64 r)</code></p>
<ul>
<li><code>r</code>を根としてEulerTourを行う</li>
<li>\( O(n) \)</li>
</ul>
</li>
<li>
<p><code>subtree_range(i64 v)</code></p>
<ul>
<li>頂点<code>v</code>の部分木に対応する範囲を返す</li>
<li>\( O(1) \)</li>
</ul>
</li>
<li>
<p><code>vertex(i64 v)</code></p>
<ul>
<li>頂点<code>v</code>に対応するindexを返す.</li>
<li>\( O(1) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-5" id="code-5">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct eulertour_subtree {
  vector&lt;vector&lt;i64&gt;&gt; G;
  vector&lt;i64&gt; tour;
  vector&lt;i64&gt; L, R;
  vector&lt;i64&gt; depth;
  eulertour_subtree(i64 n): G(n), L(n), R(n), depth(n) {}
  void add_edge(i64 u, i64 v) {
    G[u].push_back(v);
    G[v].push_back(u);
  }

  void dfs(i64 v, i64 f, i64 d) {
    tour.push_back(v);
    L[v] = tour.size() - 1;
    depth[v] = d;
    for(auto to: G[v]) {
      if(to == f) continue;
      dfs(to, v, d + 1);
      //tour.push_back(v);
    }
    R[v] = tour.size() - 1;
  }

  void start_tour(i64 r) {
    dfs(r, -1, 0);
  }

  //[L[v], R[v])
  pair&lt;i64, i64&gt; subtree_range(i64 v) {
    return pair&lt;i64, i64&gt;(L[v], R[v]);
  }

  i64 vertex(i64 v) {
    return L[v];
  }
};
</code></pre>
<h1><a class="header" href="#eulertour-path" id="eulertour-path">EulerTour Path</a></h1>
<p>EulerTourのパスを処理するバージョン<br />
パスとして求められるのは, 上から下に降りるようなパスだけなので, 任意のパスを扱うときはLCAをしないといけない.<br />
扱える要素には, 可逆性, 可換性(?)が必要.</p>
<h3><a class="header" href="#spec-6" id="spec-6">Spec</a></h3>
<ul>
<li>
<p><code>euler_tour_path(i64 n)</code></p>
<ul>
<li><code>n</code>頂点の木を構築する準備</li>
</ul>
</li>
<li>
<p><code>add_edge(i64 u, i64 v)</code></p>
<ul>
<li>頂点<code>u</code>と<code>v</code>を結ぶ辺を追加する</li>
</ul>
</li>
<li>
<p><code>start_tour(i64 r)</code></p>
<ul>
<li><code>r</code>を根としてEulerTourを行う</li>
<li>\( O(n) \)</li>
</ul>
</li>
<li>
<p><code>edge_in(i64 v)</code></p>
<ul>
<li>頂点<code>v</code>に入る辺のindexを返す</li>
<li>\( O(1) \)</li>
</ul>
</li>
<li>
<p><code>edge_out(i64 v)</code></p>
<ul>
<li>頂点<code>v</code>に出る辺のindexを返す</li>
<li>\( O(1) \)</li>
</ul>
</li>
<li>
<p><code>path_range(i64 u, i64 v)</code></p>
<ul>
<li>頂点<code>u</code>から降りて頂点<code>v</code>に辿るパスの範囲を返す.</li>
<li>\( O(1) \)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-6" id="code-6">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct eulartour_path {
  vector&lt;vector&lt;i64&gt;&gt; G;
  vector&lt;i64&gt; in, out;
  i64 cnt;
  eulartour_path(i64 n): G(n), in(n), out(n) {}
  void add_edge(i64 u, i64 v) {
    G[u].push_back(v);
    G[v].push_back(u);
  }

  void dfs(i64 v, i64 f) {
    for(auto to: G[v]) {
      if(to == f) continue;
      in[to] = cnt;
      cnt++;
      dfs(to, v);
      out[to] = cnt;
      cnt++;
    }
  }

  void start_tour(i64 r) {
    in[r] = cnt;
    cnt++;
    dfs(r, -1);
  }

  i64 edge_in(i64 v) { return in[v]; }
  i64 edge_out(i64 v) { return out[v]; }
  pair&lt;i64, i64&gt; path_range(i64 u, i64 v) {
    return { in[u] + 1, in[v] + 1 };
  }
};


</code></pre>
<h1><a class="header" href="#link-cut-tree" id="link-cut-tree">Link Cut Tree</a></h1>
<p>動的木</p>
<p>パスのsumを計算したり, パスに対する作用を遅延伝搬できる.</p>
<h3><a class="header" href="#spec-7" id="spec-7">Spec</a></h3>
<ul>
<li>
<p><code>struct node</code></p>
<ul>
<li>link cut treeで扱うノードの構造体</li>
<li>この中に載せたいデータを載せる</li>
</ul>
</li>
<li>
<p><code>fix(node * n)</code></p>
<ul>
<li>ノードの情報の再計算をする</li>
</ul>
</li>
<li>
<p><code>reverse(node * n)</code></p>
<ul>
<li>平衡二分木の反転</li>
<li>モノイドの演算順序が反転するのでその処理を書く</li>
<li>モノイドが可換であれば問題ない</li>
</ul>
</li>
<li>
<p><code>lazy(node * n, i64 l)</code></p>
<ul>
<li>遅延伝搬するときの演算</li>
<li><code>expose(n); lazy(n, x)</code>をすると, <code>[root, n]</code>のパスに<code>x</code>を作用させることになる</li>
</ul>
</li>
<li>
<p><code>push(node* n)</code></p>
<ul>
<li>遅延伝搬</li>
<li>lazyを変えている場合はここも変更</li>
</ul>
</li>
<li>
<p><code>expose(node* n)</code></p>
<ul>
<li><code>n</code>をLink Cut Treeの根として, その木が<code>[root, n]</code>のパスをあらわすようになる</li>
</ul>
</li>
<li>
<p><code>link(node* p, node* c)</code></p>
<ul>
<li><code>p</code>を親, <code>c</code>を子として繋げる</li>
</ul>
</li>
<li>
<p><code>cut(node* c)</code></p>
<ul>
<li><code>c</code>の親とつながっている辺を切る</li>
</ul>
</li>
<li>
<p><code>evert(node* t)</code></p>
</li>
<li>
<p><code>t</code>を親にする</p>
</li>
</ul>
<h3><a class="header" href="#code-7" id="code-7">Code</a></h3>
<p>パス加算, パスsumを処理している</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

namespace link_cut_tree {
  struct node {
    node* ch[2];
    node* par;
    bool rev;

    i64 sz;
    i64 val;
    i64 fold;

    i64 lazy;
    node(i64 v) {
      ch[0] = nullptr;
      ch[1] = nullptr;
      par = nullptr;
      rev = false;

      sz = 1;
      val = v;
      fold = v;

      lazy = 0;
    }
  };

  i64 size(node* n) {
    if(n) return n-&gt;sz;
    return 0;
  }

  i64 fold(node* n) {
    if(n) return n-&gt;fold;
    return 0;
  }
  

  void fix(node * n) {
    if(n) {
      /* fix operation here */
      n-&gt;sz = 1 + size(n-&gt;ch[0]) + size(n-&gt;ch[1]);
      n-&gt;fold = n-&gt;val + fold(n-&gt;ch[0]) + fold(n-&gt;ch[1]);
    }
  }

  void reverse(node* n) {
    if(n) {
      n-&gt;rev ^= true;
      swap(n-&gt;ch[0], n-&gt;ch[1]);
      /* reverse operation here */
    }
  }

  void lazy(node* n, i64 l) {
    if(n) {
      n-&gt;lazy += l;
      n-&gt;val += l;
      n-&gt;fold += l * size(n);
    }
  }

  void push(node* n) {
    if(n) {
      if(n-&gt;rev) {
        reverse(n-&gt;ch[0]);
        reverse(n-&gt;ch[1]);
      }
      lazy(n-&gt;ch[0], n-&gt;lazy);
      lazy(n-&gt;ch[1], n-&gt;lazy);
      n-&gt;lazy = 0;
    }
  }

  i64 pdir(node* n) {
    if(n-&gt;par) {
      if(n-&gt;par-&gt;ch[0] == n) return 0;
      if(n-&gt;par-&gt;ch[1] == n) return 1;
    }
    return -1;
  }

  void rot(node* n, i64 dir) {
    node* x = n-&gt;par;
    node* y = n-&gt;par-&gt;par;
    i64 pd = pdir(x);
    x-&gt;ch[dir ^ 1] = n-&gt;ch[dir];
    if(n-&gt;ch[dir]) n-&gt;ch[dir]-&gt;par = x;
    n-&gt;ch[dir] = x;
    x-&gt;par = n;
    fix(x);
    fix(n);
    n-&gt;par = y;
    if(pd &gt;= 0) {
      y-&gt;ch[pd] = n;
      fix(y);
    }
  }

  void splay(node* t) {
    while(pdir(t) &gt;= 0) {
      node* q = t-&gt;par;
      if(pdir(q) == -1) {
        push(q);
        push(t);
        rot(t, pdir(t) ^ 1);
      }
      else {
        node* r = q-&gt;par;
        push(r);
        push(q);
        push(t);
        i64 rq = pdir(q) ^ 1;
        i64 qt = pdir(t) ^ 1;
        if(rq == qt) {
          rot(q, rq);
          rot(t, qt);
        }
        else {
          rot(t, qt);
          rot(t, rq);
        }
      }
    }
  }

  /* 一番上のsplay treeが[root, t]を表すようになる */
  void expose(node* t) {
    node* rp = nullptr;
    for(node* cur = t; cur; cur = cur-&gt;par) {
      splay(cur);
      cur-&gt;ch[1] = rp;
      fix(cur);
      rp = cur;
    }
    splay(t);
  }

  void link(node* p, node* c) {
    expose(c);
    expose(p);
    p-&gt;ch[1] = c;
    c-&gt;par = p;
  }
  
  /* cut edge (c-&gt;par, c) */
  void cut(node* c) {
    expose(c);
    node* p = c-&gt;ch[0];
    c-&gt;ch[0] = nullptr;
    p-&gt;par = nullptr;
  }

  void evert(node* t) {
    expose(t);
    reverse(t);
    push(t);
  }
};

int main() {
  i64 n;
  cin &gt;&gt; n;
  
  namespace lct = link_cut_tree;

  vector&lt;lct::node*&gt; ns;
  for(int i = 0;i &lt; n;i++) {
    ns.push_back(new lct::node(0ll));
  }

  for(int i = 0;i &lt; n;i++) {
    i64 k;
    cin &gt;&gt; k;
    for(int j = 0;j &lt; k;j++) {
      i64 c;
      cin &gt;&gt; c;
      lct::link(ns[i], ns[c]);
    }
  }

  i64 Q;
  cin &gt;&gt; Q;
  for(int q = 0; q &lt; Q; q++) {
    i64 type = 0;
    cin &gt;&gt; type;
    if(type == 0) {
      i64 v, w;
      cin &gt;&gt; v &gt;&gt; w;
      lct::expose(ns[v]);
      lct::lazy(ns[v], w);
      push(ns[v]);
    }
    else {
      i64 u;
      cin &gt;&gt; u;
      lct::expose(ns[u]);
      i64 val = ns[u]-&gt;fold;
      lct::expose(ns[0]);
      val -= ns[0]-&gt;val;
      cout &lt;&lt; val &lt;&lt; endl;
    }
  }
}
</code></pre>
<h1><a class="header" href="#union-find" id="union-find">Union Find</a></h1>
<ul>
<li><a href="data_structures/union_find/./data_structures/union_find/union_find.html">Union Find</a></li>
<li><a href="data_structures/union_find/./data_structures/union_find/persistent_union_find.html">Persistent Union Find</a></li>
</ul>
<h1><a class="header" href="#union-find-1" id="union-find-1">Union Find</a></h1>
<h1><a class="header" href="#persistent-union-find" id="persistent-union-find">Persistent Union Find</a></h1>
<h1><a class="header" href="#self-balancing-binary-search-tree" id="self-balancing-binary-search-tree">self-Balancing Binary Search Tree</a></h1>
<ul>
<li><a href="data_structures/bbst/./splay_tree_array.html">Splay Tree Array</a></li>
<li><a href="data_structures/bbst/./splay_tree_map.html">Splay Tree Map</a></li>
</ul>
<h1><a class="header" href="#splay-tree-array" id="splay-tree-array">Splay Tree Array</a></h1>
<p>列を管理するSplay Tree</p>
<h3><a class="header" href="#spec-8" id="spec-8">Spec</a></h3>
<ul>
<li>
<p><code>struct node</code></p>
<ul>
<li>Splay Treeに載せるノードの型</li>
</ul>
</li>
<li>
<p><code>fold(node* x)</code></p>
<ul>
<li><code>fold</code>したいやつを変えたときはここを変える</li>
</ul>
</li>
<li>
<p><code>fix(node* n)</code></p>
<ul>
<li><code>fix</code>操作, foldの仕方をここで定義する</li>
</ul>
</li>
<li>
<p><code>reverse(node* n)</code></p>
<ul>
<li>反転操作, foldを反転する必要がある場合はここに.</li>
</ul>
</li>
<li>
<p><code>push(node* x)</code></p>
<ul>
<li>遅延伝搬させているときはここを変更</li>
</ul>
</li>
<li>
<p><code>split(i64 i)</code></p>
<ul>
<li><code>[0, i) / [i, ..)</code>に分ける</li>
</ul>
</li>
<li>
<p><code>merge(splay_array&amp;&amp; arr)</code></p>
<ul>
<li>mergeする</li>
</ul>
</li>
<li>
<p><code>reverse()</code></p>
<ul>
<li>列全体を反転させる</li>
</ul>
</li>
<li>
<p><code>update(i64 i, T t)</code></p>
<ul>
<li><code>i</code>番目の要素を<code>t</code>に変更する.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-8" id="code-8">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct splay_array {
  using T = i64;

  struct node {
    node* ch[2];
    node* par;
    T val;
    i64 sz;
    bool rev;

    /* option */
    T fold;
    
    node(T v): val(v), par(nullptr), sz(1), rev(false), fold(v) { ch[0] = nullptr; ch[1] = nullptr; }
  };

private:

  i64 subsize(node* x) {
    if(x) return x-&gt;sz;
    else return 0;
  }
  T fold(node* x) {
    if(x) return x-&gt;fold;
    else return 0;
  }
  node* fix(node* n) {
    if(!n) return nullptr;
    n-&gt;sz = subsize(n-&gt;ch[0]) + subsize(n-&gt;ch[1]) + 1;
    /* option */
    n-&gt;fold = fold(n-&gt;ch[0]) + n-&gt;val + fold(n-&gt;ch[1]);
    return n;
  }
  void reverse(node* n) {
    if(!n) return;
    n-&gt;rev ^= true;
    /* here reversing operation */
    /* example swap(fold, revfold) */
  }
  void push(node* x) {
    if(!x) return;
    if(x-&gt;rev) {
      swap(x-&gt;ch[0], x-&gt;ch[1]);
      reverse(x-&gt;ch[0]);
      reverse(x-&gt;ch[1]);
    }
  }
  int parent_dir(node* x) {
    node* p = x-&gt;par;
    if(!p) return -1;
    else if(p-&gt;ch[0] == x) return 0;
    else return 1;
  }
  void set(node* par, node* x, i64 dir) {
    if(par) par-&gt;ch[dir] = x;
    if(x) x-&gt;par = par;
    fix(par);
  }
  void rotate(node* x, i64 dir) {
    node* p = x-&gt;par;
    node* q = p-&gt;par;
    set(p, x-&gt;ch[dir], dir ^ 1);
    int p_dir = parent_dir(p);
    if(p_dir &gt;= 0) {
      set(q, x, p_dir);
    }
    else x-&gt;par = nullptr;
    set(x, p, dir);
  }
  node* splay(node * x) {
    if(!x) return nullptr;
    while(x-&gt;par) {
      push(x-&gt;par-&gt;par);
      push(x-&gt;par);
      push(x);
      int dir = parent_dir(x);
      int eir = parent_dir(x-&gt;par);
      if(eir == -1) {
        rotate(x, dir  ^ 1);
      }
      else if(dir == eir){
        rotate(x-&gt;par, eir ^ 1);
        rotate(x, dir ^ 1);
      }
      else {
        rotate(x, dir ^ 1);
        rotate(x, eir ^ 1);
      }
    }
    return x;
  }

  node* find(node* r, i64 i) {
    push(r);
    assert(0 &lt;= i);
    assert(i &lt; subsize(r));
    node* z = r;
    while(z) {
      push(z);
      if(subsize(z-&gt;ch[0]) == i) return splay(z);
      else if(subsize(z-&gt;ch[0]) &lt; i) {
        i -= subsize(z-&gt;ch[0]) + 1;
        z = z-&gt;ch[1];
      }
      else {
        z = z-&gt;ch[0];
      }
    }
    assert(false);
  }

  pair&lt;node*, node*&gt; split(node* r, size_t i) {
    push(r);
    assert(0 &lt;= i);
    assert(i &lt;= subsize(r));
    if(i == 0) return { nullptr, r };
    if(i == subsize(r)) return { r, nullptr };
    r = find(r, i - 1);
    node* y = r-&gt;ch[1];
    if(y) y-&gt;par = nullptr;
    r-&gt;ch[1] = nullptr;
    fix(r);
    push(y);
    return { r, y };
  }

  node* merge(node* r1, node* r2) {
    push(r1);
    push(r2);
    if(!r1) r1 = r2;
    else if(!r2) {}
    else {
      r1 = find(r1, subsize(r1) - 1);
      set(r1, r2, 1);
    }
    return r1;
  }

  node* root;

  splay_array(node* r): root(r) {}

public:

  using sarr = splay_array;

  splay_array(): root(nullptr) {}
  splay_array(T t): root(new node(t)) {}
  splay_array(splay_array&amp;&amp; arr): root(arr.root) { arr.root = nullptr; }
  splay_array&amp; operator=(splay_array&amp;&amp; arr) {
    root = arr.root;
    arr.root = nullptr;
    return *this;
  }
  /* [0 ... i - 1] +/+ [i ...] */
  pair&lt;splay_array, splay_array&gt; split(i64 i) {
    auto p = split(root, i);
    root = nullptr;
    return { splay_array(p.first), splay_array(p.second) };
  }
  /* [this] ++ [arr] */
  void merge(splay_array&amp;&amp; arr) {
    root = merge(root, arr.root);
    arr.root = nullptr;
  }
  /* reverse array */
  void reverse() { if(root) reverse(root); }
  i64 size() { return subsize(root); }

  /* option */
  T fold() { return fold(root); }
  void update(i64 i, T t) {
    root = find(root, i);
    root-&gt;val += t;
    fix(root);
  }
};
</code></pre>
<h1><a class="header" href="#splay-tree-map" id="splay-tree-map">Splay Tree Map</a></h1>
<p>map型のSplay Tree</p>
<h3><a class="header" href="#spec-9" id="spec-9">Spec</a></h3>
<ul>
<li>
<p><code>struct node</code></p>
<ul>
<li>Splay Treeに載せるノードの型</li>
</ul>
</li>
<li>
<p><code>fold(node* x)</code></p>
<ul>
<li><code>fold</code>したいやつを変えたときはここを変える</li>
</ul>
</li>
<li>
<p><code>fix(node* n)</code></p>
<ul>
<li><code>fix</code>操作, foldの仕方をここで定義する</li>
</ul>
</li>
<li>
<p><code>reverse(node* n)</code></p>
<ul>
<li>反転操作, foldを反転する必要がある場合はここに.</li>
</ul>
</li>
<li>
<p><code>push(node* x)</code></p>
<ul>
<li>遅延伝搬させているときはここを変更</li>
</ul>
</li>
<li>
<p><code>insert(Key key, T t)</code></p>
<ul>
<li><code>{key, t}</code>を入れる, すでに存在する場合はupdate</li>
</ul>
</li>
<li>
<p><code>erase(Key key)</code></p>
<ul>
<li>`{key, ..}のノードを削除する</li>
</ul>
</li>
<li>
<p><code>nth_node(i64 n)</code></p>
<ul>
<li><code>n</code>番目の要素の<code>Key</code>を返す</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-9" id="code-9">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

struct splay_map {
  using T = i64;
  using Key = i64;

  struct node {
    node* ch[2];
    node* par;
    T val;
    Key key;
    i64 sz;
    bool rev;

    /* option */
    //T fold;
    
    node(Key key, T v): key(key), val(v), par(nullptr), sz(1), rev(false)/*, fold(v)*/ { ch[0] = nullptr; ch[1] = nullptr; }
  };

private:

  i64 subsize(node* x) {
    if(x) return x-&gt;sz;
    else return 0;
  }
  /*
  T fold(node* x) {
    if(x) return x-&gt;fold;
    else return 0;
  }
  */
  node* fix(node* n) {
    if(!n) return nullptr;
    n-&gt;sz = subsize(n-&gt;ch[0]) + subsize(n-&gt;ch[1]) + 1;
    /* option */
    //n-&gt;fold = fold(n-&gt;ch[0]) + n-&gt;val + fold(n-&gt;ch[1]);
    return n;
  }
  void reverse(node* n) {
    if(!n) return;
    n-&gt;rev ^= true;
    /* here reversing operation */
    /* example swap(fold, revfold) */
  }
  void push(node* x) {
    if(!x) return;
    if(x-&gt;rev) {
      swap(x-&gt;ch[0], x-&gt;ch[1]);
      reverse(x-&gt;ch[0]);
      reverse(x-&gt;ch[1]);
    }
  }
  int parent_dir(node* x) {
    node* p = x-&gt;par;
    if(!p) return -1;
    else if(p-&gt;ch[0] == x) return 0;
    else return 1;
  }
  void set(node* par, node* x, i64 dir) {
    if(par) par-&gt;ch[dir] = x;
    if(x) x-&gt;par = par;
    fix(par);
  }
  void rotate(node* x, i64 dir) {
    node* p = x-&gt;par;
    node* q = p-&gt;par;
    set(p, x-&gt;ch[dir], dir ^ 1);
    int p_dir = parent_dir(p);
    if(p_dir &gt;= 0) {
      set(q, x, p_dir);
    }
    else x-&gt;par = nullptr;
    set(x, p, dir);
  }
  node* splay(node * x) {
    if(!x) return nullptr;
    while(x-&gt;par) {
      push(x-&gt;par-&gt;par);
      push(x-&gt;par);
      push(x);
      int dir = parent_dir(x);
      int eir = parent_dir(x-&gt;par);
      if(eir == -1) {
        rotate(x, dir  ^ 1);
      }
      else if(dir == eir){
        rotate(x-&gt;par, eir ^ 1);
        rotate(x, dir ^ 1);
      }
      else {
        rotate(x, dir ^ 1);
        rotate(x, eir ^ 1);
      }
    }
    return x;
  }

  node* root;

public:

  splay_map(): root(nullptr) {}

  node* lower_bound(Key key) {
    node* z = root;
    node* x = nullptr;
    while(z) {
      if(key &lt;= z-&gt;key) {
        x = z;
        z = z-&gt;ch[0];
      }
      else {
        z = z-&gt;ch[1];
      }
    }
    return x;
  }

  void insert(Key key, T t) {
    node* z = new node(key, t);
    node* x = lower_bound(key);
    if(!x) {
      set(z, root, 0);
      root = z;
    }
    else {
      root = splay(x);
      node* q = root-&gt;ch[0];
      set(z, q, 0);
      set(root, z, 0);
    }
  }

  void erase(Key key) {
    node* x = lower_bound(key);
    if(x-&gt;key == key) {
      root = splay(x);
      node* p = root-&gt;ch[0];
      node* q = root-&gt;ch[1];
      root-&gt;ch[0] = nullptr;
      root-&gt;ch[1] = nullptr;
      if(p) p-&gt;par = nullptr;
      if(q) q-&gt;par = nullptr;
      if(!p) {
        root = q;
      }
      else {
        while(p-&gt;ch[1]) p = p-&gt;ch[1];
        root = splay(p);
        set(root, q, 1);
      }
    }
  }

  i64 size() {
    return subsize(root);
  }
  Key nth_node(i64 n) {
    node* z = root;
    while(z) {
      if(subsize(z-&gt;ch[0]) == n) {
        return z-&gt;key;
      }
      if(subsize(z-&gt;ch[0]) &lt; n) {
        n -= subsize(z-&gt;ch[0]) + 1;
        z = z-&gt;ch[1];
      }
      else {
        z = z-&gt;ch[0];
      }
    }
    assert(false);
  }
  

  /* option */
  //T fold() { return fold(root); }
};
</code></pre>
<h1><a class="header" href="#math" id="math">Math</a></h1>
<p>数学系を</p>
<ul>
<li><a href="math/./modint.html">modint</a></li>
<li><a href="math/./matrix.html">Matrix</a> \</li>
<li><a href="math/./garner.html">Garner's Algorithm</a></li>
<li><a href="math/./polynomial.html">Polynomial</a> \</li>
<li><a href="math/./runtime_fp.html">Runtime fp</a> \</li>
</ul>
<h1><a class="header" href="#modint" id="modint">modint</a></h1>
<p>xxで割ったあまりを求めよで使える構造体</p>
<h3><a class="header" href="#spec-10" id="spec-10">Spec</a></h3>
<ul>
<li>
<p>template</p>
<ul>
<li><code>i64 M</code>
<ul>
<li>\( \mod M \)の剰余環</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>modint(const i64 x = 0)</code></p>
<ul>
<li>\( x \mod M \)で初期化</li>
</ul>
</li>
<li>
<p><code>value()</code></p>
<ul>
<li>\( x \mod M \)を返す</li>
</ul>
</li>
<li>
<p><code>pow(i64 r)</code></p>
<ul>
<li>\( x^r \mod M \)を返す</li>
</ul>
</li>
<li>
<p><code>+, -, *, /</code></p>
</li>
</ul>
<h3><a class="header" href="#code-10" id="code-10">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

template&lt;i64 M&gt;
struct modint {
  i64 a;
  constexpr modint(const i64 x = 0) noexcept: a((x % M + M) % M) {}
  constexpr i64 value() const noexcept { return a; }
  constexpr modint pow(i64 r) const noexcept {
    modint ans(1);
    modint aa = *this;
    while(r) {
      if(r &amp; 1) {
        ans *= aa;
      }
      aa *= aa;
      r &gt;&gt;= 1;
    }
    return ans;
  }
  constexpr modint&amp; operator+=(const modint r) noexcept {
    a += r.a;
    if(a &gt;= M) a -= M;
    return *this;
  }
  constexpr modint&amp; operator=(const i64 r) {
    a = (r % M + M) % M;
    return *this;
  }
  constexpr modint&amp; operator-=(const modint r) noexcept {
    a -= r.a;
    if(a &lt; 0) a += M;
    return *this;
  }
  constexpr modint&amp; operator*=(const modint r) noexcept {
    a = a * r.a % M;
    return *this;
  }
  constexpr modint&amp; operator/=(modint r) noexcept {
    i64 ex = M - 2;
    while(ex) {
      if(ex &amp; 1) {
        *this *= r;
      }
      r *= r;
      ex &gt;&gt;= 1;
    }
    return *this;
  }

  constexpr modint operator+(const modint r) const {
    return modint(*this) += r;
  }
  constexpr modint operator-(const modint r) const {
    return modint(*this) -= r;
  }
  constexpr modint operator*(const modint r) const {
    return modint(*this) *= r;
  }
  constexpr modint operator/(const modint r) const {
    return modint(*this) /= r;
  }
};

</code></pre>
<h1><a class="header" href="#matrix" id="matrix">Matrix</a></h1>
<h1><a class="header" href="#garners-algorithm" id="garners-algorithm">Garner's Algorithm</a></h1>
<p>FPSで使う</p>
<h3><a class="header" href="#spec-11" id="spec-11">Spec</a></h3>
<p>\(m_0, \cdots, m_{k-1} \)が互いに素とする.<br />
\( x &lt; \prod{m_i} \)を満たす\( x \)について, \( x \mod m_i \)がわかっている時,<br />
\( O(k^2 + k \log m) \)で \( x \mod M \) を求めることができる.</p>
<h3><a class="header" href="#code-11" id="code-11">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

i64 pow_mod(i64 x, i64 r, i64 mod) {
  i64 ans = 1;
  while(r) {
    if(r &amp; 1) ans = (ans * x) % mod;
    r &gt;&gt;= 1;
    x = x * x % mod;
  }
  return ans;
}

i64 inv_mod(i64 x, i64 mod) {
  return pow_mod(x, mod - 2, mod);
}

i64 garner(const vector&lt;i64&gt; &amp;x, vector&lt;i64&gt; mods, i64 mod) {
  mods.emplace_back(mod);
  vector&lt;i64&gt; coeffs(x.size() + 1, 1);
  vector&lt;i64&gt; constants(x.size() + 1, 0);
  for(i64 i = 0; i &lt; x.size(); i++) {
    i64 v = (x[i] - constants[i]) * inv_mod(coeffs[i], mods[i]) % mods[i];
    if(v &lt; 0) v += mods[i];
    for(i64 j = i + 1; j &lt; x.size() + 1; j++) {
      constants[j] = (constants[j] + coeffs[j] * v) % mods[j];
      coeffs[j] = (coeffs[j] * mods[i]) % mods[j];
    }
  }
  return constants.back();
}
</code></pre>
<h1><a class="header" href="#polynomial" id="polynomial">Polynomial</a></h1>
<h1><a class="header" href="#runtime-fp" id="runtime-fp">Runtime fp</a></h1>
<h1><a class="header" href="#convolution" id="convolution">Convolution</a></h1>
<p>畳み込み <a href="http://kazuma8128.hatenablog.com/entry/2018/07/29/231819">参考 - 約数集合でのゼータ変換・メビウス変換的なやつと畳み込み</a></p>
<h2><a class="header" href="#集合の畳み込みについて" id="集合の畳み込みについて">集合の畳み込みについて</a></h2>
<p>\(A \subseteq B\) のとき, \( B \)は\( A \)の上位集合という. また\( A \)は\( B \)の下位集合という.</p>
<p>上位集合について和を求める変換して互いをかけ合わせて逆変換をすると, 積集合(And)の個数が求められる.<br />
下位集合について和を求める変換して互いをかけ合わせて逆変換をすると, 和集合(Or)の個数が求められる.</p>
<p>例) <code>multiple_transform</code>(<code>i</code>について, <code>i</code>を約数に持つ<code>j</code>の<code>a[j]</code>の総和を求める --&gt; 上位集合)をして互いをかけ合わせて逆変換すると, 積集合(<code>gcd</code>についての畳み込み)がの個数が求められる.</p>
<h2><a class="header" href="#transforms" id="transforms">Transforms</a></h2>
<ul>
<li><a href="math/convolution/./multiple_transform.html">Multiple Transform</a></li>
<li><a href="math/convolution/./divisor_transform.html">Divisor Transform</a></li>
<li><a href="math/convolution/./fast_fourier_transform.html">Fast Fourier Transform</a></li>
<li><a href="math/convolution/./numeric_theoretic_transform.html">Number Theoretic Transform</a></li>
</ul>
<h1><a class="header" href="#multiple-transform" id="multiple-transform">Multiple Transform</a></h1>
<p>約数幇助と呼ばれる. <a href="http://noshi91.hatenablog.com/entry/2018/12/27/121649">参考 - 高速ゼータ変換の約数版</a></p>
<h3><a class="header" href="#spec-12" id="spec-12">Spec</a></h3>
<p><code>i</code>について, <code>i</code>を約数に持つ<code>j</code>(上位集合)の<code>a[j]</code>の総和を求める. \( O(N \log{\log N}) \).<br />
<code>inverse multiple transform</code>と共に使うと<code>gcd</code>に関する畳み込みができる. こんな感じ</p>
<p>\[ h(z) = \sum_{\gcd(x, y) = z} {f(x) * g(y)} \]</p>
<h3><a class="header" href="#code-12" id="code-12">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

template &lt;class T&gt;
void multiple_transform(vector&lt;T&gt; &amp;a) {
	int n = a.size();
	vector&lt;bool&gt; sieve(n, true);
	for (int p = 2; p &lt; n; ++p) {
		if (sieve[p]) {
			for (int k = (n - 1) / p; k != 0; --k) {
				sieve[k * p] = false;
				a[k] += a[k * p];
			}
		}
	}
	for (int i = 0; ++i != n;) {
		a[i] += a[0];
	}
}

template &lt;class T&gt;
void inverse_multiple_transform(vector&lt;T&gt; &amp;a) {
	int n = a.size();
	vector&lt;bool&gt; sieve(n, true);
	for (int i = 0; ++i != n;) {
		a[i] -= a[0];
	}
	for (int p = 2; p &lt; n; ++p) {
		if (sieve[p]) {
			for (int k = 1; k * p &lt; n; ++k) {
				sieve[k * p] = false;
				a[k] -= a[k * p];
			}
		}
	}
}
</code></pre>
<h1><a class="header" href="#divisor-transform" id="divisor-transform">Divisor Transform</a></h1>
<p>約数幇助と呼ばれる. <a href="http://noshi91.hatenablog.com/entry/2018/12/27/121649">参考 - 高速ゼータ変換の約数版</a></p>
<h3><a class="header" href="#spec-13" id="spec-13">Spec</a></h3>
<p><code>i</code>について, <code>i</code>の約数である<code>j</code>(下位集合)について<code>a[j]</code>の総和を求める. \( O(N \log{\log N}) \).<br />
<code>inverse divisor transform</code>と共に使うと<code>lcm</code>に関する畳み込みができる. こんな感じ</p>
<p>\[  h(z) = \sum_{ \operatorname{lcm} (x, y) = z } { f(x) * g(y) } \]</p>
<h3><a class="header" href="#code-13" id="code-13">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

template &lt;class T&gt;
void divisor_transform(vector&lt;T&gt; &amp;a) {
	int n = a.size();
	vector&lt;bool&gt; sieve(n, true);
	for (int p = 2; p &lt; n; ++p) {
		if (sieve[p]) {
			for (int k = 1; k * p &lt; n; ++k) {
				sieve[k * p] = false;
				a[k * p] += a[k];
			}
		}
	}
	for (int i = 0; ++i != n;) {
		a[i] += a[0];
	}
}

template &lt;class T&gt;
void inverse_divisor_transform(vector&lt;T&gt; &amp;a) {
	int n = a.size();
	vector&lt;bool&gt; sieve(n, true);
	for (int i = 0; ++i != n;) {
		a[i] -= a[0];
	}
	for (int p = 2; p &lt; n; ++p) {
		if (sieve[p]) {
			for (int k = (n - 1) / p; k != 0; --k) {
				sieve[k * p] = false;
				a[k * p] -= a[k];
			}
		}
	}
}

</code></pre>
<h1><a class="header" href="#fast-fourier-transform" id="fast-fourier-transform">Fast Fourier Transform</a></h1>
<h3><a class="header" href="#spec-14" id="spec-14">Spec</a></h3>
<p>離散フーリエ変換(discrete Fourier transformation)を\( O(n \log n) \)で行う.</p>
<p>誤差厳しい, 整数ならNTT使おう(誤差をなくすようにFFTするのもあるらしい)</p>
<h3><a class="header" href="#code-14" id="code-14">Code</a></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;complex&gt;
using namespace std;
using i64 = long long;

const double pi = std::acos(-1);

vector&lt;complex&lt;double&gt;&gt; fast_fourier_transform(vector&lt;complex&lt;double&gt;&gt; a) {
  i64 n = a.size();
  for(i64 s = n &gt;&gt; 1; s &gt;= 1; s &gt;&gt;= 1) {
    complex&lt;double&gt; zeta = std::polar(1.0, 2 * pi / (double)(s &lt;&lt; 1));
    for(i64 i = 0;i &lt; n;i += (s &lt;&lt; 1)) {
      complex&lt;double&gt; zi = 1.0;
      for(i64 j = 0;j &lt; s;j++) {
        complex&lt;double&gt; t = a[i + j] - a[s + i + j];
        a[i + j] = a[i + j] + a[s + i + j];
        a[s + i + j] = t * zi;
        zi = zi * zeta;
      }
    }
  }
  return a;
}

vector&lt;complex&lt;double&gt;&gt; inverse_fast_fourier_transform(vector&lt;complex&lt;double&gt;&gt; a) {
  i64 n = a.size();
  for(i64 s = 1; s &lt; n; s &lt;&lt;= 1) {
    complex&lt;double&gt; zeta = std::polar(1.0, -1 * 2 * pi / (double)(s &lt;&lt; 1));
    for(i64 i = 0; i &lt; n; i += (s &lt;&lt; 1)) {
      complex&lt;double&gt; zi = 1;
      for(i64 j = 0;j &lt; s;j++) {
        complex&lt;double&gt; t = a[s + i + j] * zi;
        a[s + i + j] = a[i + j] - t;
        a[i + j] = a[i + j] + t;
        zi = zi * zeta;
      }
    }
  }
  i64 inv_n = 1 / (double)n;
  for(int i = 0;i &lt; n;i++) a[i] *= inv_n;
  return a;
}
</code></pre>
<h1><a class="header" href="#numeric-theoretic-transform" id="numeric-theoretic-transform">Numeric Theoretic Transform</a></h1>
<h3><a class="header" href="#spec-15" id="spec-15">Spec</a></h3>
<p>素数\( m = 2^k + 1, 2^k &gt;= n\)として\(F_m \)剰余環上での離散フーリエ変換(discrete Fourier transformation)を\( O(n \log n) \)で行う<br />
<code>NTT_PRIMES</code>は<a href="https://lumakernel.github.io/ecasdqina/math/FFT/NTT">るまライブラリ</a>からお借りしています</p>
<p>ほとんど単体でNTTを使うことはなさそう(FPSで使うね)</p>
<h3><a class="header" href="#code-15" id="code-15">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

template&lt;i64 M&gt;
struct modint {
  i64 a;
  constexpr modint(const i64 x = 0) noexcept: a((x % M + M) % M) {}
  constexpr i64 value() const noexcept { return a; }
  constexpr modint pow(i64 r) const noexcept {
    modint ans(1);
    modint aa = *this;
    while(r) {
      if(r &amp; 1) {
        ans *= aa;
      }
      aa *= aa;
      r &gt;&gt;= 1;
    }
    return ans;
  }
  constexpr modint&amp; operator+=(const modint r) noexcept {
    a += r.a;
    if(a &gt;= M) a -= M;
    return *this;
  }
  constexpr modint&amp; operator=(const i64 r) {
    a = (r % M + M) % M;
    return *this;
  }
  constexpr modint&amp; operator-=(const modint r) noexcept {
    a -= r.a;
    if(a &lt; 0) a += M;
    return *this;
  }
  constexpr modint&amp; operator*=(const modint r) noexcept {
    a = a * r.a % M;
    return *this;
  }
  constexpr modint&amp; operator/=(modint r) noexcept {
    i64 ex = M - 2;
    while(ex) {
      if(ex &amp; 1) {
        *this *= r;
      }
      r *= r;
      ex &gt;&gt;= 1;
    }
    return *this;
  }

  constexpr modint operator+(const modint r) const {
    return modint(*this) += r;
  }
  constexpr modint operator-(const modint r) const {
    return modint(*this) -= r;
  }
  constexpr modint operator*(const modint r) const {
    return modint(*this) *= r;
  }
  constexpr modint operator/(const modint r) const {
    return modint(*this) /= r;
  }
};

constexpr i64 NTT_PRIMES[][2] = {
    {1224736769, 3}, // 2^24 * 73 + 1,
    {1053818881, 7}, // 2^20 * 3 * 5 * 67 + 1
    {1051721729, 6}, // 2^20 * 17 * 59 + 1
    {1045430273, 3}, // 2^20 * 997 + 1
    {1012924417, 5}, // 2^21 * 3 * 7 * 23 + 1
    {1007681537, 3}, // 2^20 * 31^2 + 1
    {1004535809, 3}, // 2^21 * 479 + 1
    {998244353, 3},  // 2^23 * 7 * 17 + 1
    {985661441, 3},  // 2^22 * 5 * 47 + 1
    {976224257, 3},  // 2^20 * 7^2 * 19 + 1
    {975175681, 17}, // 2^21 * 3 * 5 * 31 + 1
    {962592769, 7},  // 2^21 * 3^3 * 17 + 1
    {950009857, 7},  // 2^21 * 4 * 151 + 1
    {943718401, 7},  // 2^22 * 3^2 * 5^2 + 1
    {935329793, 3},  // 2^22 * 223 + 1
    {924844033, 5},  // 2^21 * 3^2 * 7^2 + 1
    {469762049, 3},  // 2^26 * 7 + 1
    {167772161, 3},  // 2^25 * 5 + 1
};

template&lt;const i64 mod, const i64 primitive&gt;
vector&lt;modint&lt;mod&gt;&gt; number_theoretic_transform(vector&lt;modint&lt;mod&gt;&gt; a) {
  i64 n = a.size();
  for(i64 s = n &gt;&gt; 1; s &gt;= 1; s &gt;&gt;= 1) {
    modint&lt;mod&gt; zeta = modint&lt;mod&gt;(primitive).pow((mod - 1) / (s &lt;&lt; 1));
    for(i64 i = 0; i &lt; n; i += (s &lt;&lt; 1)) {
      modint&lt;mod&gt; zi = 1;
      for(i64 j = 0;j &lt; s;j++) {
        modint&lt;mod&gt; t = a[i + j] - a[s + i + j];
        a[i + j] += a[s + i + j];
        a[s + i + j] = t * zi;
        zi = zi * zeta;
      }
    }
  }
  return a;
}

template&lt;const i64 mod, const i64 primitive&gt;
vector&lt;modint&lt;mod&gt;&gt; inverse_number_theoretic_transform(vector&lt;modint&lt;mod&gt;&gt; a) {
  i64 n = a.size();
  for(i64 s = 1; s &lt; n; s &lt;&lt;= 1) {
    modint&lt;mod&gt; zeta = modint&lt;mod&gt;(primitive).pow((mod - 1) / (s &lt;&lt; 1)).pow(mod - 2);
    for(i64 i = 0; i &lt; n; i += (s &lt;&lt; 1)) {
      modint&lt;mod&gt; zi = 1;
      for(i64 j = 0;j &lt; s;j++) {
        modint&lt;mod&gt; t = a[s + i + j] * zi;
        a[s + i + j] = a[i + j] - t;
        a[i + j] = a[i + j] + t;
        zi = zi * zeta;
      }
    }
  }
  auto inv_n = modint&lt;mod&gt;(n).pow(mod - 2);
  for(int i = 0;i &lt; n;i++) a[i] *= inv_n;
  return a;
}
</code></pre>
<h1><a class="header" href="#string" id="string">String</a></h1>
<p><a href="https://snuke.hatenablog.com/entry/2014/12/01/235807">文字列の頭良い感じの線形アルゴリズムたち</a></p>
<ul>
<li><a href="string/./manacher.html">Manacher</a> \</li>
<li><a href="string/./mp.html">MP (Morris Pratt)</a></li>
<li><a href="string/./rolling_hash.html">Rolling Hash</a> \</li>
<li><a href="string/./suffix_array.html">Suffix Array</a> \</li>
<li><a href="string/./Z-algorithm.html">Z-algorithm</a> \</li>
</ul>
<h1><a class="header" href="#manacher" id="manacher">Manacher</a></h1>
<h1><a class="header" href="#mp-morris-pratt" id="mp-morris-pratt">MP (Morris Pratt)</a></h1>
<p><a href="https://snuke.hatenablog.com/entry/2014/12/01/235807">文字列の頭良い感じの線形アルゴリズムたち</a></p>
<h3><a class="header" href="#spec-16" id="spec-16">Spec</a></h3>
<p>文字列S[0, i-1]のprefixとsuffixが最大何文字一致しているかを \( O(|S|) \)で求める.</p>
<h4><a class="header" href="#example" id="example">Example</a></h4>
<pre><code>aabaabaaa
_010123452
</code></pre>
<h3><a class="header" href="#code-16" id="code-16">Code</a></h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

/*
 * 文字列S[0, i-1]のprefixとsuffixが最大何文字一致しているか
 */

vector&lt;i64&gt; mp(string S) {
  vector&lt;i64&gt; A(S.size() + 1);
  A[0] = -1;
  int j = -1;
  for (int i = 0; i &lt; S.size(); i++) {
    while (j &gt;= 0 &amp;&amp; S[i] != S[j]) j = A[j];
    j++;
    A[i+1] = j;
  }
  return A;
}

</code></pre>
<h1><a class="header" href="#rolling-hash" id="rolling-hash">Rolling Hash</a></h1>
<h1><a class="header" href="#suffix-array" id="suffix-array">Suffix Array</a></h1>
<h1><a class="header" href="#z-algorithm" id="z-algorithm">Z-algorithm</a></h1>
<h1><a class="header" href="#graph" id="graph">Graph</a></h1>
<ul>
<li><a href="graph/./low_link.html">Low Link</a> \</li>
<li><a href="graph/./strongly_connected_components.html">Strongly Connected Components</a> \</li>
<li><a href="graph/./two_edge_connected.html">Two Edge Connected</a> \</li>
<li><a href="graph/./two_vertex_connected.html">Two Vertex Connected</a> \</li>
</ul>
<h1><a class="header" href="#low-link" id="low-link">Low Link</a></h1>
<h1><a class="header" href="#strongly-connected-components" id="strongly-connected-components">Strongly Connected Components</a></h1>
<h1><a class="header" href="#two-edge-connected" id="two-edge-connected">Two Edge Connected</a></h1>
<h1><a class="header" href="#two-vertex-connected" id="two-vertex-connected">Two Vertex Connected</a></h1>
<h1><a class="header" href="#geometry" id="geometry">Geometry</a></h1>
<p>昔作ったやつが残っていたのでとりあえず貼っておく 要整備</p>
<h3><a class="header" href="#spec-17" id="spec-17">Spec</a></h3>
<ul>
<li><code>Convex_Hull</code>
<ul>
<li>凸包</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#code-17" id="code-17">Code</a></h3>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;
using namespace std;

using ld = long double;

const ld EPS = 1e-8;
inline bool eq(ld a, ld b) { return abs(a - b) &lt; EPS; }
const ld PI = acos(-1);

namespace Geometory {
  struct Point {
    ld x, y;
    Point(ld x = 0, ld y = 0) : x(x), y(y) {}
    Point operator+(const Point&amp; b) const { return Point(x + b.x, y + b.y); }
    Point operator-(const Point&amp; b) const { return Point(x - b.x, y - b.y); }
    Point operator*(const ld b) const { return Point(x * b, y * b); }
    Point operator/(const ld b) const { return Point(x / b, y / b); }
    bool operator&lt;(const Point&amp; b) const {
      if (x != b.x)
        return x &lt; b.x;
      else
        return y &lt; b.y;
    }
    bool operator==(const Point&amp; b) const { return eq(x, b.x) &amp;&amp; eq(y, b.y); }
    ld norm() const { return x * x + y * y; }
    ld abs() const { return sqrt(norm()); }
    ld arg() const { return atan2(x, y); }
    Point rotate(const ld theta) const {
      ld co = cos(theta);
      ld si = sin(theta);
      return Point(co * x - si * y, si * x + y * co);
    }
    Point rotate90() const { return Point(-y, x); }
  };

  ld dot(const Point&amp; a, const Point&amp; b) { return a.x * b.x + a.y * b.y; }
  ld cross(const Point&amp; a, const Point b) { return a.x * b.y - a.y * b.x; }

  struct Line {
    Point from, to;
    Line(Point from = Point(), Point to = Point()) : from(from), to(to) {}
  };

  struct Segment {
    Point from, to;
    Segment(Point from = Point(), Point to = Point()) : from(from), to(to) {}
  };

  bool is_orthogonal(const Line&amp; la, const Line&amp; lb) {
    return eq(0.0, dot(la.from - la.to, lb.from - lb.from));
  }
  bool is_parallel(const Line&amp; la, const Line&amp; lb) {
    return eq(0.0, cross(la.from - la.to, lb.from - lb.from));
  }
  bool is_Point_on(const Line&amp; l, const Point&amp; p) {
    return eq(0.0, cross(l.to - l.from, p - l.from));
  }
  bool is_Point_on(const Segment&amp; s, const Point&amp; p) {
    return (s.from - p).abs() + (p - s.to).abs() &lt; (s.from - s.to).abs() + EPS;
  }
  ld distance(const Line&amp; l, const Point&amp; p) {
    return abs(cross(l.to - l.from, p - l.from)) / (l.to - l.from).abs();
  }
  ld distance(const Segment&amp; s, const Point&amp; p) {
    if (dot(s.to - s.from, p - s.from) &lt; EPS) return (p - s.from).abs();
    if (dot(s.from - s.to, p - s.to) &lt; EPS) return (p - s.to).abs();
    return abs(cross(s.to - s.from, p - s.from)) / (s.to - s.from).abs();
  }
  ld is_intersected(const Segment&amp; a, const Segment&amp; b) {
    return (cross(a.to - a.from, b.from - a.from) *
                cross(a.to - a.from, b.to - a.from) &lt;
            EPS) &amp;&amp;
           (cross(b.to - b.from, a.from - b.from) *
                cross(b.to - b.from, a.to - b.from) &lt;
            EPS);
  }

  ld is_intersected(const Segment&amp; s, const Line&amp; l) {
    // line -&gt; ax + by + c = 0
    ld a = l.to.y - l.from.y;
    ld b = l.from.x - l.to.x;
    ld c = -a * l.from.x - b * l.from.y;
    ld t1 = a * s.from.x + b * s.from.y + c;
    ld t2 = a * s.to.x + b * s.to.y + c;
    return t1 * t2 &lt;= 0;
  }

  Point intersection_point(const Segment&amp; a, const Segment&amp; b) {
    Point bp = b.to - b.from;
    ld d1 = abs(cross(bp, a.from - b.from));
    ld d2 = abs(cross(bp, a.to - b.from));
    ld t = d1 / (d1 + d2);
    return a.from + (a.to - a.from) * t;
  }

  Point intersection_point(const Line&amp; a, const Line&amp; b) {
    Point ap = a.to - a.from;
    Point bp = b.to - b.from;
    return a.from + ap * cross(bp, b.from - a.from) / cross(bp, ap);
  }
  // counterclockwise
  int ccw(const Point&amp; a, const Point&amp; b, const Point&amp; c) {
    Point ba = b - a;
    Point ca = c - a;
    if (cross(ba, ca) &gt; EPS) return 1;   // a - b --/ c
    if (cross(ba, ca) &lt; EPS) return -1;  // a - b --| c
    if (dot(ba, ca) &lt; 0) return 2;       // b - a - c
    if (b.norm() &lt; c.norm()) return -2;  // a - b - c
    return 0;                            // a -- c -- b
  }

  vector&lt;Point&gt; Convex_Hull(vector&lt;Point&gt;&amp; p) {
    int n = p.size();
    int k = 0;
    if (n &gt;= 3) {
      sort(p.begin(), p.end());
      vector&lt;Point&gt; ch(2 * n);
      for (int i = 0; i &lt; n; ch[k++] = p[i++]) {
        while (k &gt;= 2 &amp;&amp; cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) &lt; 0)
          k--;
      }
      for (int i = n - 2, t = k + 1; i &gt;= 0; ch[k++] = p[i--]) {
        while (k &gt;= t &amp;&amp; cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) &lt; 0)
          k--;
      }
      ch.resize(k - 1);
      return ch;
    } else {
      return p;
    }
  }
};
</code></pre>
<h1><a class="header" href="#other" id="other">Other</a></h1>
<p>実験したりするときに</p>
<ul>
<li><a href="other/./grundy.html">Grundy Number</a></li>
<li><a href="other/./mongeDP.html">Monge DP</a> \</li>
<li><a href="other/./slide_min.html">Slide Min</a> \</li>
</ul>
<h1><a class="header" href="#grundy-number" id="grundy-number">Grundy Number</a></h1>
<h3><a class="header" href="#spec-18" id="spec-18">Spec</a></h3>
<ul>
<li><code>grn[(ゲームの状態)]</code>が<code>0</code> -&gt; その状態での手番の人が負ける</li>
<li><code>grn[(ゲームの状態)]</code>が<code>0</code>以外 -&gt; その状態での手番の人が勝つ</li>
</ul>
<h3><a class="header" href="#code-18" id="code-18">Code</a></h3>
<p>このコードでは, 取れる個数に制限がついているNimの勝敗を計算している.</p>
<pre><code class="language-cpp">/*
 N個の正整数からなる集合 A={a1,a2,…,aN}があります。 太郎君と次郎君が次のゲームで勝負します。

最初に、K個の石からなる山を用意します。 二人は次の操作を交互に行います。 先手は太郎君です。
Aの元 xをひとつ選び、山からちょうど x個の石を取り去る。
先に操作を行えなくなった人が負けです。 二人が最適に行動すると仮定したとき、どちらが勝つかを判定してください。
*/

#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;

vector&lt;i64&gt; grn(101010, -1);

i64 N, K;
vector&lt;i64&gt; a;

int main() {
  cin &gt;&gt; N &gt;&gt; K;
  a.resize(N);
  for(int i = 0;i &lt; N;i++) cin &gt;&gt; a[i];
  for(i64 k = 0;k &lt;= K;k++) {
    set&lt;i64&gt; st;
    for(auto x: a) {
      if(k - x &gt;= 0) st.insert(grn[k - x]);
    }
    grn[k] = K + 1;
    for(int i = 0;i &lt;= K + 1;i++) {
      if(!st.count(i)) {
        grn[k] = i;
        break;
      }
    }
  }
  if(grn[K]) {
    cout &lt;&lt; &quot;First&quot; &lt;&lt; endl;
  }
  else {
    cout &lt;&lt; &quot;Second&quot; &lt;&lt; endl;
  }
}
</code></pre>
<h1><a class="header" href="#monge-dp" id="monge-dp">Monge DP</a></h1>
<h1><a class="header" href="#slide-min" id="slide-min">Slide Min</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
