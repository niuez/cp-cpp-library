<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dynamic Wavelet Matrix - cp-cpp-library Document</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../data_structures/index.html"><strong aria-hidden="true">1.1.</strong> Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../data_structures/segment_tree/index.html"><strong aria-hidden="true">1.1.1.</strong> Segment Trees</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../data_structures/segment_tree/segment_tree.html"><strong aria-hidden="true">1.1.1.1.</strong> Segment Tree</a></li><li class="chapter-item expanded "><a href="../../data_structures/segment_tree/lazy_segment_tree.html"><strong aria-hidden="true">1.1.1.2.</strong> Lazy Segment Tree</a></li><li class="chapter-item expanded "><a href="../../data_structures/segment_tree/persistent_segment_tree.html"><strong aria-hidden="true">1.1.1.3.</strong> Persistent Segment Tree</a></li><li class="chapter-item expanded "><a href="../../data_structures/segment_tree/dynamic_segment_tree.html"><strong aria-hidden="true">1.1.1.4.</strong> Dynamic Segment Tree</a></li><li class="chapter-item expanded "><a href="../../data_structures/segment_tree/li_chao.html"><strong aria-hidden="true">1.1.1.5.</strong> Li-Chao Line Add Tree</a></li><li class="chapter-item expanded "><a href="../../data_structures/segment_tree/li_chao_segment.html"><strong aria-hidden="true">1.1.1.6.</strong> Li-Chao Segment Add Tree</a></li><li class="chapter-item expanded "><a href="../../data_structures/segment_tree/beats_chmin_sum.html"><strong aria-hidden="true">1.1.1.7.</strong> Beats (chmin + sum)</a></li><li class="chapter-item expanded "><a href="../../data_structures/segment_tree/beats_chminmax_sum.html"><strong aria-hidden="true">1.1.1.8.</strong> Beats (chmin + chmax + sum)</a></li><li class="chapter-item expanded "><a href="../../data_structures/segment_tree/beats_chminmaxadd_sum.html"><strong aria-hidden="true">1.1.1.9.</strong> Beats (chmin + chmax + add + sum)</a></li></ol></li><li class="chapter-item expanded "><a href="../../data_structures/heap/index.html"><strong aria-hidden="true">1.1.2.</strong> Heaps</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../data_structures/heap/pairing_heap.html"><strong aria-hidden="true">1.1.2.1.</strong> Pairing Heap</a></li></ol></li><li class="chapter-item expanded "><a href="../../data_structures/trees/index.html"><strong aria-hidden="true">1.1.3.</strong> Trees</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../data_structures/trees/euler_tour_subtree.html"><strong aria-hidden="true">1.1.3.1.</strong> EulerTour Subtree</a></li><li class="chapter-item expanded "><a href="../../data_structures/trees/euler_tour_path.html"><strong aria-hidden="true">1.1.3.2.</strong> EulerTour Path</a></li><li class="chapter-item expanded "><a href="../../data_structures/trees/heavy_light_decomposition.html"><strong aria-hidden="true">1.1.3.3.</strong> Heavy Light Decomposition</a></li><li class="chapter-item expanded "><a href="../../data_structures/trees/link_cut_tree.html"><strong aria-hidden="true">1.1.3.4.</strong> Link Cut Tree</a></li><li class="chapter-item expanded "><a href="../../data_structures/trees/toptree.html"><strong aria-hidden="true">1.1.3.5.</strong> Top Tree</a></li></ol></li><li class="chapter-item expanded "><a href="../../data_structures/union_find/index.html"><strong aria-hidden="true">1.1.4.</strong> Union Find</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../data_structures/union_find/union_find.html"><strong aria-hidden="true">1.1.4.1.</strong> Union Find</a></li><li class="chapter-item expanded "><a href="../../data_structures/union_find/persistent_union_find.html"><strong aria-hidden="true">1.1.4.2.</strong> Persistent Union Find</a></li></ol></li><li class="chapter-item expanded "><a href="../../data_structures/bbst/index.html"><strong aria-hidden="true">1.1.5.</strong> self-Balancing Binary Search Trees</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../data_structures/bbst/splay_tree_array.html"><strong aria-hidden="true">1.1.5.1.</strong> Splay Tree Array</a></li><li class="chapter-item expanded "><a href="../../data_structures/bbst/splay_tree_map.html"><strong aria-hidden="true">1.1.5.2.</strong> Splay Tree Map</a></li><li class="chapter-item expanded "><a href="../../data_structures/bbst/avl_tree_array.html"><strong aria-hidden="true">1.1.5.3.</strong> AVL Tree Array</a></li><li class="chapter-item expanded "><a href="../../data_structures/bbst/avl_tree_array_tuned.html"><strong aria-hidden="true">1.1.5.4.</strong> AVL Tree Array Tuned</a></li><li class="chapter-item expanded "><a href="../../data_structures/bbst/avl_tree_map.html"><strong aria-hidden="true">1.1.5.5.</strong> AVL Tree Map</a></li><li class="chapter-item expanded "><a href="../../data_structures/bbst/avl_tree_map_foldable.html"><strong aria-hidden="true">1.1.5.6.</strong> AVL Tree Map Foldable</a></li><li class="chapter-item expanded "><a href="../../data_structures/bbst/persistent_avl_tree_array.html"><strong aria-hidden="true">1.1.5.7.</strong> Persistent AVL Tree Array</a></li></ol></li><li class="chapter-item expanded "><a href="../../data_structures/sparse_table/sparse_table.html"><strong aria-hidden="true">1.1.6.</strong> Sparse Table</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../data_structures/sparse_table/sparse_table.html"><strong aria-hidden="true">1.1.6.1.</strong> Sparse Table</a></li></ol></li><li class="chapter-item expanded "><a href="../../data_structures/wavelet_matrix/index.html"><strong aria-hidden="true">1.1.7.</strong> Wavelet Matrix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../data_structures/wavelet_matrix/wavelet_matrix.html"><strong aria-hidden="true">1.1.7.1.</strong> Wavelet Matrix</a></li><li class="chapter-item expanded "><a href="../../data_structures/wavelet_matrix/dynamic_wavelet_matrix.html" class="active"><strong aria-hidden="true">1.1.7.2.</strong> Dynamic Wavelet Matrix</a></li></ol></li><li class="chapter-item expanded "><a href="../../data_structures/container/fully_retroactive_stack.html"><strong aria-hidden="true">1.1.8.</strong> Container</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../data_structures/container/fully_retroactive_stack.html"><strong aria-hidden="true">1.1.8.1.</strong> Fully Retroactive Stack</a></li><li class="chapter-item expanded "><a href="../../data_structures/container/hash_map.html"><strong aria-hidden="true">1.1.8.2.</strong> Hash Map</a></li></ol></li><li class="chapter-item expanded "><a href="../../data_structures/other/index.html"><strong aria-hidden="true">1.1.9.</strong> Other</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../data_structures/other/swag.html"><strong aria-hidden="true">1.1.9.1.</strong> SWAG</a></li><li class="chapter-item expanded "><a href="../../data_structures/other/fenwick_tree.html"><strong aria-hidden="true">1.1.9.2.</strong> Fenwick Tree</a></li><li class="chapter-item expanded "><a href="../../data_structures/other/online_dicon.html"><strong aria-hidden="true">1.1.9.3.</strong> Online Dynamic Connectivity</a></li><li class="chapter-item expanded "><a href="../../data_structures/other/range_valued_array.html"><strong aria-hidden="true">1.1.9.4.</strong> Range Valued Array</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../math/index.html"><strong aria-hidden="true">1.2.</strong> Math</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../math/modint.html"><strong aria-hidden="true">1.2.1.</strong> modint</a></li><li class="chapter-item expanded "><a href="../../math/matrix.html"><strong aria-hidden="true">1.2.2.</strong> Matrix</a></li><li class="chapter-item expanded "><a href="../../math/crt.html"><strong aria-hidden="true">1.2.3.</strong> Chinese Remainder Theorem</a></li><li class="chapter-item expanded "><a href="../../math/garner.html"><strong aria-hidden="true">1.2.4.</strong> Garner's Algorithm</a></li><li class="chapter-item expanded "><a href="../../math/formal_power_series.html"><strong aria-hidden="true">1.2.5.</strong> Formal Power Series</a></li><li class="chapter-item expanded "><a href="../../math/mori_fps_division.html"><strong aria-hidden="true">1.2.6.</strong> Mori FPS Division</a></li><li class="chapter-item expanded "><a href="../../math/newton_interpolation.html"><strong aria-hidden="true">1.2.7.</strong> Newton Interpolation</a></li><li class="chapter-item expanded "><a href="../../math/seidels_lp.html"><strong aria-hidden="true">1.2.8.</strong> Seidel's LP</a></li><li class="chapter-item expanded "><a href="../../math/runtime_fp.html"><strong aria-hidden="true">1.2.9.</strong> Runtime fp</a></li><li class="chapter-item expanded "><a href="../../math/binfps.html"><strong aria-hidden="true">1.2.10.</strong> F2FPS</a></li><li class="chapter-item expanded "><a href="../../math/factorial.html"><strong aria-hidden="true">1.2.11.</strong> Factorial</a></li><li class="chapter-item expanded "><a href="../../math/adjucency_matrix_equation.html"><strong aria-hidden="true">1.2.12.</strong> Adjucency Matrix Equation</a></li><li class="chapter-item expanded "><a href="../../math/berlekamp_massey.html"><strong aria-hidden="true">1.2.13.</strong> Berlekamp-Massey</a></li><li class="chapter-item expanded "><a href="../../math/fast_kitamasa.html"><strong aria-hidden="true">1.2.14.</strong> Fast-Kitamasa</a></li><li class="chapter-item expanded "><a href="../../math/black_box_linear_algebra.html"><strong aria-hidden="true">1.2.15.</strong> Black Box Linear Algebra</a></li><li class="chapter-item expanded "><a href="../../math/convolution/index.html"><strong aria-hidden="true">1.2.16.</strong> Convolution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../math/convolution/multiple_transform.html"><strong aria-hidden="true">1.2.16.1.</strong> Multiple Transform</a></li><li class="chapter-item expanded "><a href="../../math/convolution/divisor_transform.html"><strong aria-hidden="true">1.2.16.2.</strong> Divisor Transform</a></li><li class="chapter-item expanded "><a href="../../math/convolution/fast_fourier_transform.html"><strong aria-hidden="true">1.2.16.3.</strong> Fast Fourier Transform</a></li><li class="chapter-item expanded "><a href="../../math/convolution/numeric_theoretic_transform.html"><strong aria-hidden="true">1.2.16.4.</strong> Number Theoretic Transform</a></li><li class="chapter-item expanded "><a href="../../math/comvolution/zeta_mobius_transform.html"><strong aria-hidden="true">1.2.16.5.</strong> Zeta Mobius Transform</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../string/index.html"><strong aria-hidden="true">1.3.</strong> String</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../string/2_31rolling_hash.html"><strong aria-hidden="true">1.3.1.</strong> 2^31 Rolling Hash</a></li><li class="chapter-item expanded "><a href="../../string//manacher.html"><strong aria-hidden="true">1.3.2.</strong> Manacher</a></li><li class="chapter-item expanded "><a href="../../string/mp.html"><strong aria-hidden="true">1.3.3.</strong> MP (Morris Pratt)</a></li><li class="chapter-item expanded "><a href="../../string/suffix_array.html"><strong aria-hidden="true">1.3.4.</strong> Suffix Array</a></li><li class="chapter-item expanded "><a href="../../string/Z-algorithm.html"><strong aria-hidden="true">1.3.5.</strong> Z-algorithm</a></li><li class="chapter-item expanded "><a href="../../string/burrows_wheeler.html"><strong aria-hidden="true">1.3.6.</strong> Burrows Wheeler</a></li><li class="chapter-item expanded "><a href="../../string/rolling_hash.html"><strong aria-hidden="true">1.3.7.</strong> Rolling Hash</a></li></ol></li><li class="chapter-item expanded "><a href="../../graph/index.html"><strong aria-hidden="true">1.4.</strong> Graph</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../graph/sp/dijkstra.html"><strong aria-hidden="true">1.4.1.</strong> Shortest Path</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../graph/sp/dijkstra.html"><strong aria-hidden="true">1.4.1.1.</strong> Dijkstra</a></li><li class="chapter-item expanded "><a href="../../graph/sp/bfs.html"><strong aria-hidden="true">1.4.1.2.</strong> BFS</a></li><li class="chapter-item expanded "><a href="../../graph/sp/dial01.html"><strong aria-hidden="true">1.4.1.3.</strong> Dial 01</a></li></ol></li><li class="chapter-item expanded "><a href="../../graph/max_flow/dinic.html"><strong aria-hidden="true">1.4.2.</strong> Max Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../graph/max_flow/dinic.html"><strong aria-hidden="true">1.4.2.1.</strong> Dinic</a></li><li class="chapter-item expanded "><a href="../../graph/max_flow/goldberg_tarjan_tuned.html"><strong aria-hidden="true">1.4.2.2.</strong> GoldBerg Tarjan's Preflow Relabel</a></li></ol></li><li class="chapter-item expanded "><a href="../../graph/mcf/primal_dual.html"><strong aria-hidden="true">1.4.3.</strong> Minimum Cost Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../graph/mcf/primal_dual.html"><strong aria-hidden="true">1.4.3.1.</strong> Successive Shortest Path</a></li></ol></li><li class="chapter-item expanded "><a href="../../graph/strongly_connected_components.html"><strong aria-hidden="true">1.4.4.</strong> Strongly Connected Components</a></li><li class="chapter-item expanded "><a href="../../graph/incremental_bridge_connectivity.html"><strong aria-hidden="true">1.4.5.</strong> Incremental Bridge Connectivity</a></li><li class="chapter-item expanded "><a href="../../graph/lattice_graph.html"><strong aria-hidden="true">1.4.6.</strong> Lattice Graph</a></li></ol></li><li class="chapter-item expanded "><a href="../../geometry/geometry.html"><strong aria-hidden="true">1.5.</strong> Geometry</a></li><li class="chapter-item expanded "><a href="../../tech/index.html"><strong aria-hidden="true">1.6.</strong> Tech</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../tech/compression.html"><strong aria-hidden="true">1.6.1.</strong> Compression</a></li><li class="chapter-item expanded "><a href="../../tech/grundy.html"><strong aria-hidden="true">1.6.2.</strong> Grundy Number</a></li><li class="chapter-item expanded "><a href="../../tech/mongeDP.html"><strong aria-hidden="true">1.6.3.</strong> Monge DP</a></li><li class="chapter-item expanded "><a href="../../tech/mo.html"><strong aria-hidden="true">1.6.4.</strong> Mo's Algorithm</a></li><li class="chapter-item expanded "><a href="../../tech/slide_min.html"><strong aria-hidden="true">1.6.5.</strong> Slide Min</a></li><li class="chapter-item expanded "><a href="../../tech/fastio.html"><strong aria-hidden="true">1.6.6.</strong> FastIO</a></li><li class="chapter-item expanded "><a href="../../tech/rerooting.html"><strong aria-hidden="true">1.6.7.</strong> Non-recursive Rerooting</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">cp-cpp-library Document</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dynamic-wavelet-matrix"><a class="header" href="#dynamic-wavelet-matrix">Dynamic Wavelet Matrix</a></h1>
<h2 id="spec"><a class="header" href="#spec">Spec</a></h2>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<pre><code class="language-cpp">#include &lt;array&gt;
#include &lt;set&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;cstdint&gt;
#include &lt;cassert&gt;
#include &lt;bitset&gt;

struct dynamic_bitvector {


  struct node;
  using size_type = std::size_t;
  using height_type = long long;
  using node_type = std::unique_ptr&lt;struct node&gt;;
  using node_reference = const node_type&amp;;
  using bits_type = std::uint64_t;
  using children_type = std::array&lt;node_type, 2&gt;;


  const static size_type bit_limit = 32;

  struct bitvector_builder {
    const static size_type bit_size = bit_limit * 2;
    const size_type len;
    std::vector&lt;bits_type&gt; bits;
    bitvector_builder(size_type len): len(len), bits(len / bit_size + !!(len &amp; (bit_size - 1))) {}
    void set(size_type i) { bits[i / bit_size] |= (bits_type(1) &lt;&lt; (i &amp; (bit_size - 1))); }
    dynamic_bitvector build() const {
      return dynamic_bitvector(bits, len);
    }
  };

  static size_type bits_popcount(bits_type bits) {
    return __builtin_popcountll(bits);
  }

  struct section_t {
    height_type he;
    children_type ch;
  };

  struct leaf_t {
    bits_type bits;
  };

  union info_t {
    section_t section;
    leaf_t leaf;
    info_t(section_t sec): section(std::move(sec)) {}
    info_t(leaf_t leaf): leaf(leaf) {}
    ~info_t() {}
  };

  struct node {
    const bool is_leaf;
    size_type sz;
    size_type popcnt;
    info_t info;

    static node_type new_section(node_type left, node_type right) {
      node* n = new node(section_t { 0, children_type { std::move(left), std::move(right) } });
      n-&gt;fix();
      return node_type(n);
    }

    static node_type new_leaf(bits_type bits, size_type sz, size_type popcnt) {
      node* n = new node(leaf_t { bits });
      n-&gt;sz = sz;
      n-&gt;popcnt = popcnt;
      return node_type(n); } node(section_t sec): is_leaf(false), info(std::move(sec)) {}
    node(leaf_t leaf): is_leaf(true), info(leaf) {}

    height_type height() const {
      if(is_leaf) return 0;
      else return info.section.he;
    }
    size_type size() const {
      return sz;
    }

    size_type popcount() const {
      return popcnt;
    }

    // operation for only section node

    node_type take(size_type dir) {
      assert(!is_leaf);
      return std::move(info.section.ch[dir]);
    }

    node_type swap(size_type dir, node_type new_node) {
      assert(!is_leaf);
      node_type old_node = take(dir);
      info.section.ch[dir] = std::move(new_node);
      return old_node;
    }

    const node_type&amp; child(size_type dir) const {
      assert(!is_leaf);
      return info.section.ch[dir];
    }

    height_type diff() const {
      assert(!is_leaf);
      return child(0)-&gt;height() - child(1)-&gt;height();
    }

    void fix() {
      assert(!is_leaf);
      sz = child(0)-&gt;size() + child(1)-&gt;size();
      popcnt = child(0)-&gt;popcount() + child(1)-&gt;popcount();
      info.section.he = std::max(child(0)-&gt;height(), child(1)-&gt;height()) + 1;
    }

    // operation for only leaf node

    bits_type bits() const {
      assert(is_leaf);
      return info.leaf.bits;
    }

    bool at_bits(size_type pos) const {
      assert(is_leaf);
      return (bits() &gt;&gt; pos) &amp; 1;
    }

    size_type rank(size_type pos) const {
      assert(pos &lt;= size());
      return bits_popcount(bits() &amp; ((bits_type(1) &lt;&lt; pos) - 1));
    }

    void set_bits(bits_type bits, size_type sz_, size_type popcnt_) {
      assert(is_leaf);
      sz = sz_;
      popcnt = popcnt_;
      info.leaf.bits = bits;
    }

    // [0, pos) and [pos, sz)
    std::pair&lt;bits_type, bits_type&gt; split_bits(size_type pos) const {
      assert(is_leaf);
      assert(pos &lt;= size());
      return std::make_pair(bits() &amp; ((bits_type(1) &lt;&lt; pos) - 1), bits() &gt;&gt; pos);
    }

    void insert_bit(size_type pos, bool bit) {
      assert(is_leaf);
      assert(sz &lt; bit_limit * 2);
      bits_type l, r;
      std::tie(l, r) = split_bits(pos);
     // std::cout &lt;&lt; &quot;insert &quot; &lt;&lt; bit  &lt;&lt; &quot; to &quot; &lt;&lt; pos &lt;&lt; std::endl;
     // std::cout &lt;&lt; &quot;insert &quot; &lt;&lt; std::bitset&lt;bit_limit * 2&gt;(l) &lt;&lt; &quot; &quot; &lt;&lt; std::bitset&lt;bit_limit * 2&gt;(r) &lt;&lt; std::endl;
     // std::cout &lt;&lt; &quot;insert &quot; &lt;&lt; std::bitset&lt;bit_limit * 2&gt;(bits()) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; std::bitset&lt;bit_limit * 2&gt;(l | ((bits_type(bit) &lt;&lt; pos)) | (r &lt;&lt; (pos + 1))) &lt;&lt; std::endl;
      set_bits(l | ((bits_type(bit) &lt;&lt; pos)) | (r &lt;&lt; (pos + 1)), sz + 1, popcount() + bit);
    } 

    void erase_bit(size_type pos) {
      assert(is_leaf);
      assert(0 &lt; sz);
      bits_type l, r;
      std::tie(l, r) = split_bits(pos);
      size_type pos_bit = r &amp; 1;
      r &gt;&gt;= 1;
      set_bits(l | (r &lt;&lt; pos), sz - 1, popcount() - pos_bit);
    }
  };


  static node_type rotate(node_type x, size_type dir) {
    x-&gt;fix();
    node_type y = x-&gt;take(1 - dir);
    node_type b = y-&gt;take(dir);
    x-&gt;swap(1 - dir, std::move(b));
    x-&gt;fix();
    y-&gt;swap(dir, std::move(x));
    y-&gt;fix();
    return std::move(y);
  }

  static node_type balance(node_type node) {
    node-&gt;fix();
    if(node-&gt;diff() == 2) {
      if(node-&gt;child(0)-&gt;diff() == -1) {
        auto ch = node-&gt;take(0);
        node-&gt;swap(0, rotate(std::move(ch), 0));
      }
      return rotate(std::move(node), 1);
    }
    else if(node-&gt;diff() == -2) {
      if(node-&gt;child(1)-&gt;diff() == 1) {
        auto ch = node-&gt;take(1);
        node-&gt;swap(1, rotate(std::move(ch), 1));
      }
      return rotate(std::move(node), 0);
    }
    else return std::move(node);
  }

  static node_type split_node(node_type node) {
    assert(node-&gt;is_leaf);
    bits_type l, r;
    std::tie(l, r) = node-&gt;split_bits(bit_limit);
    return node::new_section(
        node::new_leaf(l, bit_limit, bits_popcount(l)), node::new_leaf(r, node-&gt;size() - bit_limit, bits_popcount(r))
        );
  }

  static node_type insert(node_type node, size_type pos, bool bit) {
    if(node-&gt;is_leaf) {
      if(node-&gt;size() == 2 * bit_limit) {
        return insert(split_node(std::move(node)), pos, bit);
      }
      else {
        node-&gt;insert_bit(pos, bit);
        return node;
      }
    }
    else if(pos &lt; node-&gt;child(0)-&gt;size()) {
      node-&gt;swap(0, insert(node-&gt;take(0), pos, bit));
      return balance(std::move(node));
    }
    else {
      node-&gt;swap(1, insert(node-&gt;take(1), pos - node-&gt;child(0)-&gt;size(), bit));
      return balance(std::move(node));
    }
  }

  template&lt;const size_type dir&gt;
  static std::tuple&lt;node_type, bits_type, size_type&gt; take_bit(node_type node, size_type len) {
    if(node-&gt;is_leaf) {
      if(node-&gt;size() &lt; bit_limit / 2 + len) {
        return std::tuple&lt;node_type, bits_type, size_type&gt;{ node_type(nullptr), node-&gt;bits(), node-&gt;size() };
      }
      else {
        auto p = node-&gt;split_bits(dir == 0 ? len : node-&gt;size() - len);
        bits_type node_bit = std::get&lt;1 - dir&gt;(p);
        bits_type take = std::get&lt;dir&gt;(p);
        node-&gt;set_bits(node_bit, node-&gt;size() - len, bits_popcount(node_bit));
        return std::tuple&lt;node_type, bits_type, size_type&gt; { std::move(node), take, len };
      }
    }
    else {
      node_type ch;
      bits_type bits;
      size_type take_len;
      std::tie(ch, bits, take_len) = take_bit&lt;dir&gt;(node-&gt;take(dir), len);
      if(ch) {
        node-&gt;swap(dir, std::move(ch));
        return std::tuple&lt;node_type, bits_type, size_type&gt;{ balance(std::move(node)), bits, take_len };
      }
      else {
        return std::tuple&lt;node_type, bits_type, size_type&gt; { node-&gt;take(1 - dir), bits, take_len };
      }
    }
  }

  static node_type erase(node_type node, size_type pos) {
    if(node-&gt;is_leaf) {
      node-&gt;erase_bit(pos);
      return node;
    }
    else if(pos &lt; node-&gt;child(0)-&gt;size()) {
      auto left = erase(node-&gt;take(0), pos);
      if(left-&gt;size() &lt; bit_limit / 2) {
        assert(left-&gt;is_leaf);
        node_type right;
        bits_type bits;
        size_type len;
        std::tie(right, bits, len) = take_bit&lt;0&gt;(node-&gt;take(1), bit_limit / 2 - left-&gt;size());

        left-&gt;set_bits(left-&gt;bits() | (bits &lt;&lt; left-&gt;size()), left-&gt;size() + len, left-&gt;popcount() + bits_popcount(bits));
        if(right) {
          node-&gt;swap(0, std::move(left));
          node-&gt;swap(1, std::move(right));
          return balance(std::move(node));
        }
        else {
          return left;
        }
      }
      else {
        node-&gt;swap(0, std::move(left));
        return balance(std::move(node));
      }
    }
    else {
      auto right = erase(node-&gt;take(1), pos - node-&gt;child(0)-&gt;size());
      if(right-&gt;size() &lt; bit_limit / 2) {
        assert(right-&gt;is_leaf);
        node_type left;
        bits_type bits;
        size_type len;
        std::tie(left, bits, len) = take_bit&lt;1&gt;(node-&gt;take(0), bit_limit / 2 - right-&gt;size());

        right-&gt;set_bits((right-&gt;bits() &lt;&lt; len) | bits, right-&gt;size() + len, right-&gt;popcount() + bits_popcount(bits));
        if(left) {
          node-&gt;swap(0, std::move(left));
          node-&gt;swap(1, std::move(right));
          return balance(std::move(node));
        }
        else {
          return right;
        }
      }
      else {
        node-&gt;swap(1, std::move(right));
        return balance(std::move(node));
      }
    }
  }

  static node_type merge_dir(node_type dst, node_type src, size_type dir) {
    if(std::abs(dst-&gt;height() - src-&gt;height()) &lt;= 1) {
      if(dir == 0)
        return node::new_section(std::move(src), std::move(dst));
      else
        return node::new_section(std::move(dst), std::move(src));
    }
    else {
      node_type ch = dst-&gt;take(dir);
      assert(ch);
      dst-&gt;swap(dir, merge_dir(std::move(ch), std::move(src), dir));
      return balance(std::move(dst));
    }
  }

  static node_type merge(node_type left, node_type right) {
    if(!left) { return std::move(right); }
    else if(!right) { return std::move(left); }
    else if(left-&gt;height() &gt;= right-&gt;height()) {
      return merge_dir(std::move(left), std::move(right), 1);
    }
    else {
      return merge_dir(std::move(right), std::move(left), 0);
    }
  }

  static node_type build(const std::vector&lt;bits_type&gt;&amp; bits, size_type l, size_type r, size_type len) {
    if(len == 0) node::new_leaf(0, 0, 0);
    //std::cout &lt;&lt; &quot;build &quot; &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; len &lt;&lt; std::endl;
    if(l + 1 &gt;= r) {
      //std::cout &lt;&lt; &quot;create leaf&quot; &lt;&lt; std::endl;
      //std::cout &lt;&lt; &quot;-----------&quot; &lt;&lt; std::endl;
      return node::new_leaf(bits[l], len, bits_popcount(bits[l]));
    }
    else {
      size_type m = (l + r) &gt;&gt; 1;
      return merge(build(bits, l, m, (m - l) * 64), build(bits, m, r, len - (m - l) * 64));
    }
  }

  static size_type at(node_reference node, size_type pos) {
    if(node-&gt;is_leaf) {
      return node-&gt;at_bits(pos);
    }
    else if(pos &lt; node-&gt;child(0)-&gt;size()) {
      return at(node-&gt;child(0), pos);
    }
    else {
      return at(node-&gt;child(1), pos - node-&gt;child(0)-&gt;size());
    }
  }

  static size_type rank(node_reference node, size_type pos) {
    if(node-&gt;is_leaf) {
      return node-&gt;rank(pos);
    }
    else if(pos == node-&gt;size()) {
      return node-&gt;popcount();
    }
    else if(pos &lt; node-&gt;child(0)-&gt;size()) {
      return rank(node-&gt;child(0), pos);
    }
    else {
      return node-&gt;child(0)-&gt;popcount() + rank(node-&gt;child(1), pos - node-&gt;child(0)-&gt;size());
    }
  }


  node_type root;

  dynamic_bitvector(): root(node::new_leaf(0, 0, 0)) {}
  dynamic_bitvector(const std::vector&lt;bits_type&gt;&amp; bits, size_type len): root(build(bits, 0, bits.size(), len)) {}
  void insert(size_type pos, bool bit) {
    root = insert(std::move(root), pos, bit);
  }
  void erase(size_type pos) {
    root = erase(std::move(root), pos);
  }
  bool at(size_type pos) const {
    return at(root, pos);
  }
  size_type rank(size_type pos) const {
    return rank(root, pos);
  }
  size_type rank(size_type pos, bool bit) const {
    if(bit) {
      return rank(root, pos);
    }
    else {
      return pos - rank(root, pos);
    }
  }
  size_type size() const {
    return root-&gt;size();
  }

  void debug_tree(node_reference node, std::string d) const {
    if(node-&gt;is_leaf) {
      std::cout &lt;&lt; d &lt;&lt; &quot;leaf &quot; &lt;&lt; node-&gt;size() &lt;&lt; &quot; &quot; &lt;&lt; node-&gt;popcount() &lt;&lt; &quot; -----------&quot; &lt;&lt; std::endl;
      std::cout &lt;&lt; d &lt;&lt; std::bitset&lt;bit_limit * 2&gt;(node-&gt;bits()) &lt;&lt; std::endl;
      std::cout &lt;&lt; d &lt;&lt; &quot;-------------&quot; &lt;&lt; std::endl;
    }
    else {
      std::cout &lt;&lt; d &lt;&lt; &quot;node &quot; &lt;&lt; node-&gt;size() &lt;&lt; &quot; &quot; &lt;&lt; node-&gt;popcount() &lt;&lt; &quot; ----------&quot; &lt;&lt; std::endl;
      std::cout &lt;&lt; d &lt;&lt; &quot;left&quot; &lt;&lt; std::endl;
      debug_tree(node-&gt;child(0), d + &quot;   &quot;);
      std::cout &lt;&lt; d &lt;&lt; &quot;--------------&quot; &lt;&lt; std::endl;
      std::cout &lt;&lt; d &lt;&lt; &quot;right&quot; &lt;&lt; std::endl;
      debug_tree(node-&gt;child(1), d + &quot;   &quot;);
      std::cout &lt;&lt; d &lt;&lt; &quot;--------------&quot; &lt;&lt; std::endl;
    }
  }

  void debug_tree() const {
    debug_tree(root, &quot;&quot;);
  }
};

#include &lt;vector&gt;
struct dynamic_wavelet_matrix {
  using Integer = long long;
  using integer_type = Integer;
  using size_type = std::size_t;


  const size_type depth;
  const size_type len;
  std::vector&lt;dynamic_bitvector&gt; mat;
  std::vector&lt;size_type&gt; spl;

public:

  dynamic_wavelet_matrix(const std::vector&lt;integer_type&gt;&amp; arr, size_type de)
    : depth(de),
      mat(de),
      len(arr.size()),
      spl(std::vector&lt;size_type&gt;(depth, 0)) {
        std::vector&lt;size_type&gt; idx(len);
        std::vector&lt;size_type&gt; left(len), right(len);

        for(size_type i = 0;i &lt; len;i++) idx[i] = i;

        for(size_type d = depth; d-- &gt; 0;) {
          size_type l = 0, r = 0;
          dynamic_bitvector::bitvector_builder builder(len);
          for(size_type i = 0; i &lt; len; i++) {
            size_type k = (arr[idx[i]] &gt;&gt; d) &amp; 1;
            if(k) right[r++] = idx[i], builder.set(i);
            else left[l++] = idx[i];
          }
          mat[d] = builder.build();
          spl[d] = l;
          swap(idx, left);
          for(size_type i = 0; i &lt; r; i++) idx[i + l] = right[i];
        }
      }

  void insert(size_type i, integer_type x) {
    for(size_type d = depth; d --&gt; 0;) {
      size_type k = ((x &gt;&gt; d) &amp; 1);
      mat[d].insert(i, k);
      i = mat[d].rank(i, k) + spl[d] * k;
      if(k == 0) spl[d]++;
    }
  }

  void erase(size_type i) {
    for(size_type d = depth; d--&gt; 0;) {
      size_type k = mat[d].at(i);
      mat[d].erase(i);
      i = mat[d].rank(i, k) + spl[d] * k;
      if(k == 0) spl[d]--;
    }
  }

  integer_type at(size_type i) const {
    integer_type x = static_cast&lt;integer_type&gt;(0);
    for(size_type d = depth; d-- &gt; 0;) {
      size_type k = mat[d].at(i);
      x |= (static_cast&lt;integer_type&gt;(k) &lt;&lt; d);
      i = mat[d].rank(i, k) + spl[d] * k;
    }
    return x;
  }

  // counting elements that equal to x in range [left, right)
  size_type rank_x(size_type left, size_type right, integer_type x) const {
    for(size_type d = depth; d-- &gt; 0;) {
      size_type k = ((x &gt;&gt; d) &amp; 1);
      left = mat[d].rank(left, k) + spl[d] * k;
      right = mat[d].rank(right, k) + spl[d] * k;
    }
    return right - left;
  }

  // sorted(arr[left..right])[i]
  integer_type quantile(size_type left, size_type right, size_type i) const {
    integer_type x = static_cast&lt;integer_type&gt;(0);
    for(size_type d = depth; d-- &gt; 0;) {
      size_type l = mat[d].rank(left, 1);
      size_type r = mat[d].rank(right, 1);
      size_type cnt = (right - left) - (r - l);
      size_type k = (i &lt; cnt) ? 0 : 1;
      if(k == 0) {
        left -= l;
        right -= r;
      }
      else {
        x |= (1 &lt;&lt; d);
        i -= cnt;
        left = l + spl[d];
        right = r + spl[d];
      }
    }
    return x;
  }

  struct rank_result {
    size_type le;
    size_type eq;
    size_type mo;
  };

  // couting elements that less than x, equal to x, and more than x in range [left, right)
  rank_result rank_less_eq_more(size_type left, size_type right, integer_type x) const {
    size_type le = 0, mo = 0;
    for(size_type d = depth; d --&gt; 0;) {
      size_type k = (x &gt;&gt; d) &amp; 1;
      size_type l = mat[d].rank(left, 1);
      size_type r = mat[d].rank(right, 1);
      if(k == 0) {
        mo += r - l;
        left -= l;
        right -= r;
      }
      else {
        le += (right - left) - (r - l);
        left = l + spl[d];
        right = r + spl[d];
      }
    }
    return rank_result { le, right - left, mo };
  }

  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y, integer_type l, size_type d) const {
    integer_type r = l + (1 &lt;&lt; d);
    if(x &lt;= l &amp;&amp; r &lt;= y) {
      return right - left;
    }
    else if(y &lt;= l || r &lt;= x) {
      return 0;
    }
    else {
      d--;
      size_type lr = mat[d].rank(left, 1);
      size_type rr = mat[d].rank(right, 1);
      return
        rangefreq(left - lr, right - rr, x, y, l, d) +
        rangefreq(lr + spl[d], rr + spl[d], x, y, l + (1 &lt;&lt; d), d);
    }
  }

  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y) const {
    return rangefreq(left, right, x, y, 0, depth);
  }

  size_type rangefreq_count(size_type left, size_type right, integer_type x, integer_type y) const {
    auto p = rank_less_eq_more(left, right, x);
    auto q = rank_less_eq_more(left, right, y);
    return p.eq + p.mo - q.eq - q.mo;
  }
};

#include &lt;bits/stdc++.h&gt;
using namespace std;
using i64 = long long;
#define rep(i,s,e) for(i64 (i) = (s);(i) &lt; (e);(i)++)
#define all(x) x.begin(),x.end()

template&lt;class T&gt;
static inline std::vector&lt;T&gt; ndvec(size_t&amp;&amp; n, T val) noexcept {
  return std::vector&lt;T&gt;(n, std::forward&lt;T&gt;(val));
}

template&lt;class... Tail&gt;
static inline auto ndvec(size_t&amp;&amp; n, Tail&amp;&amp;... tail) noexcept {
  return std::vector&lt;decltype(ndvec(std::forward&lt;Tail&gt;(tail)...))&gt;(n, ndvec(std::forward&lt;Tail&gt;(tail)...));
}


int main() {
  cin.tie(nullptr);
  std::ios::sync_with_stdio(false);

  i64 N, Q;
  cin &gt;&gt; N &gt;&gt; Q;
  vector&lt;i64&gt; A(N);
  rep(i,0,N) cin &gt;&gt; A[i];
  
  dynamic_wavelet_matrix wm(A, 30);

  while(Q--) {
    i64 l, r, k;
    cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;
    cout &lt;&lt; wm.quantile(l, r, k) &lt;&lt; &quot;\n&quot;;
  }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../data_structures/wavelet_matrix/wavelet_matrix.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../data_structures/container/fully_retroactive_stack.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../data_structures/wavelet_matrix/wavelet_matrix.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../data_structures/container/fully_retroactive_stack.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-157596444-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
